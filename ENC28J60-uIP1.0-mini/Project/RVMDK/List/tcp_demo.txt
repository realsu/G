; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_demo.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tcp_demo.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tcp_demo.crf ..\..\Source\src\tcp_demo.c]
                          THUMB

                          AREA ||i.TCP_Cmd||, CODE, READONLY, ALIGN=2

                  TCP_Cmd PROC
;;;147    */
;;;148    void TCP_Cmd(struct tcp_demo_appstate *s)
000000  b570              PUSH     {r4-r6,lr}
;;;149    {
000002  4604              MOV      r4,r0
;;;150    	uint8_t led;
;;;151    	
;;;152    	/* 点亮LED
;;;153    		语法：ledon n  (n : 1 - 4) 
;;;154    		例如 ： 
;;;155    		ledon 2 表示点亮LED2	
;;;156    	*/
;;;157    	if ((uip_len == 7) && (memcmp("ledon ", uip_appdata, 6) == 0))
000004  4841              LDR      r0,|L1.268|
000006  8800              LDRH     r0,[r0,#0]  ; uip_len
000008  2807              CMP      r0,#7
00000a  d127              BNE      |L1.92|
00000c  2206              MOVS     r2,#6
00000e  4840              LDR      r0,|L1.272|
000010  6801              LDR      r1,[r0,#0]  ; uip_appdata
000012  a040              ADR      r0,|L1.276|
000014  f7fffffe          BL       memcmp
000018  bb00              CBNZ     r0,|L1.92|
;;;158    	{
;;;159    		led = ((uint8_t *)uip_appdata)[6]; /* 操作的LED序号 */
00001a  483d              LDR      r0,|L1.272|
00001c  6800              LDR      r0,[r0,#0]  ; uip_appdata
00001e  7985              LDRB     r5,[r0,#6]
;;;160    		if (led == '1')
000020  2d31              CMP      r5,#0x31
000022  d10a              BNE      |L1.58|
;;;161    		{
;;;162    			LED1_ON();
000024  f44f7100          MOV      r1,#0x200
000028  483c              LDR      r0,|L1.284|
00002a  f7fffffe          BL       GPIO_ResetBits
;;;163                printf("led 1 on\r\n");
00002e  a03c              ADR      r0,|L1.288|
000030  f7fffffe          BL       __2printf
;;;164    			s->textptr = "Led 1 On!";
000034  a03d              ADR      r0,|L1.300|
000036  6060              STR      r0,[r4,#4]
000038  e00b              B        |L1.82|
                  |L1.58|
;;;165    		}
;;;166    		else if (led == '2')
00003a  2d32              CMP      r5,#0x32
00003c  d109              BNE      |L1.82|
;;;167    		{
;;;168    			LED2_ON();
00003e  f44f6180          MOV      r1,#0x400
000042  4836              LDR      r0,|L1.284|
000044  f7fffffe          BL       GPIO_ResetBits
;;;169                printf("led 2 on\r\n");
000048  a03b              ADR      r0,|L1.312|
00004a  f7fffffe          BL       __2printf
;;;170    			s->textptr = "Led 2 On!";			
00004e  a03d              ADR      r0,|L1.324|
000050  6060              STR      r0,[r4,#4]
                  |L1.82|
;;;171    		}
;;;172    		
;;;173    		s->textlen = strlen((char *)s->textptr);
000052  6860              LDR      r0,[r4,#4]
000054  f7fffffe          BL       strlen
000058  60a0              STR      r0,[r4,#8]
00005a  e056              B        |L1.266|
                  |L1.92|
;;;174    	}
;;;175    	/* 关闭LED
;;;176    		语法：ledoff n  (n : 1 - 4) 
;;;177    		例如 ： 
;;;178    		ledon 2 表示点亮LED2	
;;;179    	*/
;;;180    	else if ((uip_len == 8) && (memcmp("ledoff ", uip_appdata, 7) == 0))
00005c  482b              LDR      r0,|L1.268|
00005e  8800              LDRH     r0,[r0,#0]  ; uip_len
000060  2808              CMP      r0,#8
000062  d127              BNE      |L1.180|
000064  2207              MOVS     r2,#7
000066  482a              LDR      r0,|L1.272|
000068  6801              LDR      r1,[r0,#0]  ; uip_appdata
00006a  a039              ADR      r0,|L1.336|
00006c  f7fffffe          BL       memcmp
000070  bb00              CBNZ     r0,|L1.180|
;;;181    	{
;;;182    		led = ((uint8_t *)uip_appdata)[7]; /* 操作的LED序号 */
000072  4827              LDR      r0,|L1.272|
000074  6800              LDR      r0,[r0,#0]  ; uip_appdata
000076  79c5              LDRB     r5,[r0,#7]
;;;183    		if (led == '1')
000078  2d31              CMP      r5,#0x31
00007a  d10a              BNE      |L1.146|
;;;184    		{
;;;185    			LED1_OFF();
00007c  f44f7100          MOV      r1,#0x200
000080  4826              LDR      r0,|L1.284|
000082  f7fffffe          BL       GPIO_SetBits
;;;186                printf("led 1 off\r\n");
000086  a034              ADR      r0,|L1.344|
000088  f7fffffe          BL       __2printf
;;;187    			s->textptr = "Led 1 Off!";
00008c  a035              ADR      r0,|L1.356|
00008e  6060              STR      r0,[r4,#4]
000090  e00b              B        |L1.170|
                  |L1.146|
;;;188    		}
;;;189    		else if (led == '2')
000092  2d32              CMP      r5,#0x32
000094  d109              BNE      |L1.170|
;;;190    		{
;;;191    			LED2_OFF();
000096  f44f6180          MOV      r1,#0x400
00009a  4820              LDR      r0,|L1.284|
00009c  f7fffffe          BL       GPIO_SetBits
;;;192                printf("led 2 off\r\n");
0000a0  a033              ADR      r0,|L1.368|
0000a2  f7fffffe          BL       __2printf
;;;193    			s->textptr = "Led 2 Off!";				
0000a6  a035              ADR      r0,|L1.380|
0000a8  6060              STR      r0,[r4,#4]
                  |L1.170|
;;;194    		}
;;;195    				
;;;196    		s->textlen = strlen((char *)s->textptr);
0000aa  6860              LDR      r0,[r4,#4]
0000ac  f7fffffe          BL       strlen
0000b0  60a0              STR      r0,[r4,#8]
0000b2  e02a              B        |L1.266|
                  |L1.180|
;;;197    	}
;;;198    	/* 发送数据测试 sendtest
;;;199    		语法：sendtest
;;;200    		例如 ： 
;;;201    		ledon 2 表示点亮LED2	
;;;202    	*/
;;;203    	else if ((uip_len == 6) && (memcmp("txtest", uip_appdata, 6) == 0))
0000b4  4815              LDR      r0,|L1.268|
0000b6  8800              LDRH     r0,[r0,#0]  ; uip_len
0000b8  2806              CMP      r0,#6
0000ba  d10e              BNE      |L1.218|
0000bc  2206              MOVS     r2,#6
0000be  4814              LDR      r0,|L1.272|
0000c0  6801              LDR      r1,[r0,#0]  ; uip_appdata
0000c2  a031              ADR      r0,|L1.392|
0000c4  f7fffffe          BL       memcmp
0000c8  b938              CBNZ     r0,|L1.218|
;;;204    	{
;;;205    		s->state = STATE_TX_TEST;
0000ca  2001              MOVS     r0,#1
0000cc  7020              STRB     r0,[r4,#0]
;;;206    
;;;207    		s->textptr = test_data;
0000ce  4830              LDR      r0,|L1.400|
0000d0  6060              STR      r0,[r4,#4]
;;;208    		s->textlen = 1400;
0000d2  f44f60af          MOV      r0,#0x578
0000d6  60a0              STR      r0,[r4,#8]
0000d8  e017              B        |L1.266|
                  |L1.218|
;;;209    	}
;;;210    	else if ((uip_len == 6) && (memcmp("rxtest", uip_appdata, 6) == 0))
0000da  480c              LDR      r0,|L1.268|
0000dc  8800              LDRH     r0,[r0,#0]  ; uip_len
0000de  2806              CMP      r0,#6
0000e0  d10d              BNE      |L1.254|
0000e2  2206              MOVS     r2,#6
0000e4  480a              LDR      r0,|L1.272|
0000e6  6801              LDR      r1,[r0,#0]  ; uip_appdata
0000e8  a02a              ADR      r0,|L1.404|
0000ea  f7fffffe          BL       memcmp
0000ee  b930              CBNZ     r0,|L1.254|
;;;211    	{
;;;212    		s->state = STATE_RX_TEST;
0000f0  2002              MOVS     r0,#2
0000f2  7020              STRB     r0,[r4,#0]
;;;213    		s->textptr = "Ok";
0000f4  a029              ADR      r0,|L1.412|
0000f6  6060              STR      r0,[r4,#4]
;;;214    		s->textlen = 2;
0000f8  2002              MOVS     r0,#2
0000fa  60a0              STR      r0,[r4,#8]
0000fc  e005              B        |L1.266|
                  |L1.254|
;;;215    	}
;;;216    	else
;;;217    	{
;;;218    		s->textptr = "Unknow Command!\r\n";
0000fe  a028              ADR      r0,|L1.416|
000100  6060              STR      r0,[r4,#4]
;;;219    		s->textlen = strlen((char *)s->textptr);
000102  6860              LDR      r0,[r4,#4]
000104  f7fffffe          BL       strlen
000108  60a0              STR      r0,[r4,#8]
                  |L1.266|
;;;220    	}
;;;221    }
00010a  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

                  |L1.268|
                          DCD      uip_len
                  |L1.272|
                          DCD      uip_appdata
                  |L1.276|
000114  6c65646f          DCB      "ledon ",0
000118  6e2000  
00011b  00                DCB      0
                  |L1.284|
                          DCD      0x40010800
                  |L1.288|
000120  6c656420          DCB      "led 1 on\r\n",0
000124  31206f6e
000128  0d0a00  
00012b  00                DCB      0
                  |L1.300|
00012c  4c656420          DCB      "Led 1 On!",0
000130  31204f6e
000134  2100    
000136  00                DCB      0
000137  00                DCB      0
                  |L1.312|
000138  6c656420          DCB      "led 2 on\r\n",0
00013c  32206f6e
000140  0d0a00  
000143  00                DCB      0
                  |L1.324|
000144  4c656420          DCB      "Led 2 On!",0
000148  32204f6e
00014c  2100    
00014e  00                DCB      0
00014f  00                DCB      0
                  |L1.336|
000150  6c65646f          DCB      "ledoff ",0
000154  66662000
                  |L1.344|
000158  6c656420          DCB      "led 1 off\r\n",0
00015c  31206f66
000160  660d0a00
                  |L1.356|
000164  4c656420          DCB      "Led 1 Off!",0
000168  31204f66
00016c  662100  
00016f  00                DCB      0
                  |L1.368|
000170  6c656420          DCB      "led 2 off\r\n",0
000174  32206f66
000178  660d0a00
                  |L1.380|
00017c  4c656420          DCB      "Led 2 Off!",0
000180  32204f66
000184  662100  
000187  00                DCB      0
                  |L1.392|
000188  74787465          DCB      "txtest",0
00018c  737400  
00018f  00                DCB      0
                  |L1.400|
                          DCD      test_data
                  |L1.404|
000194  72787465          DCB      "rxtest",0
000198  737400  
00019b  00                DCB      0
                  |L1.412|
00019c  4f6b00            DCB      "Ok",0
00019f  00                DCB      0
                  |L1.416|
0001a0  556e6b6e          DCB      "Unknow Command!\r\n",0
0001a4  6f772043
0001a8  6f6d6d61
0001ac  6e64210d
0001b0  0a00    
0001b2  00                DCB      0
0001b3  00                DCB      0

                          AREA ||i.aborted||, CODE, READONLY, ALIGN=1

                  aborted PROC
;;;88     */
;;;89     static void aborted(void)
000000  4770              BX       lr
;;;90     {
;;;91     	;
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.acked||, CODE, READONLY, ALIGN=2

                  acked PROC
;;;276    */
;;;277    static void acked(void)
000000  b510              PUSH     {r4,lr}
;;;278    {
;;;279    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  480e              LDR      r0,|L3.60|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;280    
;;;281    	switch(s->state)
00000a  7820              LDRB     r0,[r4,#0]
00000c  b120              CBZ      r0,|L3.24|
00000e  2801              CMP      r0,#1
000010  d008              BEQ      |L3.36|
000012  2802              CMP      r0,#2
000014  d10f              BNE      |L3.54|
000016  e00b              B        |L3.48|
                  |L3.24|
;;;282    	{
;;;283    		case STATE_CMD:		 /* 在命令状态 */
;;;284    			s->textlen = 0;
000018  2000              MOVS     r0,#0
00001a  60a0              STR      r0,[r4,#8]
;;;285    
;;;286    			/* 
;;;287    				只在命令状态打印调试信息 
;;;288    				避免发送测试时，影响通信速度		
;;;289    			*/
;;;290    			printf("uip_acked!\r\n");
00001c  a008              ADR      r0,|L3.64|
00001e  f7fffffe          BL       __2printf
;;;291    			break;
000022  e008              B        |L3.54|
                  |L3.36|
;;;292    
;;;293    		case STATE_TX_TEST:
;;;294    			s->textptr = test_data;	/* 连续发送 */
000024  480a              LDR      r0,|L3.80|
000026  6060              STR      r0,[r4,#4]
;;;295    			s->textlen = 1400;
000028  f44f60af          MOV      r0,#0x578
00002c  60a0              STR      r0,[r4,#8]
;;;296    			break;
00002e  e002              B        |L3.54|
                  |L3.48|
;;;297    
;;;298    		case STATE_RX_TEST:
;;;299    			s->textlen = 0;
000030  2000              MOVS     r0,#0
000032  60a0              STR      r0,[r4,#8]
;;;300    			break;
000034  bf00              NOP      
                  |L3.54|
000036  bf00              NOP                            ;291
;;;301    	}
;;;302    }
000038  bd10              POP      {r4,pc}
;;;303    
                          ENDP

00003a  0000              DCW      0x0000
                  |L3.60|
                          DCD      uip_conn
                  |L3.64|
000040  7569705f          DCB      "uip_acked!\r\n",0
000044  61636b65
000048  64210d0a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L3.80|
                          DCD      test_data

                          AREA ||i.closed||, CODE, READONLY, ALIGN=1

                  closed PROC
;;;98     
;;;99     static void closed(void)
000000  4770              BX       lr
;;;100    {
;;;101    	;
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.connected||, CODE, READONLY, ALIGN=2

                  connected PROC
;;;109    */
;;;110    static void connected(void)
000000  b510              PUSH     {r4,lr}
;;;111    {  
;;;112        //unsigned char a[2]; 
;;;113    	/*
;;;114    		uip_conn结构体有一个"appstate"字段指向应用程序自定义的结构体。
;;;115    		声明一个s指针，是为了便于使用。
;;;116    
;;;117    		不需要再单独为每个uip_conn分配内存，这个已经在uip中分配好了。
;;;118    		在uip.c 中 的相关代码如下：
;;;119    			struct uip_conn *uip_conn;
;;;120    			struct uip_conn uip_conns[UIP_CONNS]; //UIP_CONNS缺省=10
;;;121    		定义了1个连接的数组，支持同时创建几个连接。
;;;122    		uip_conn是一个全局的指针，指向当前的tcp或udp连接。
;;;123    	*/
;;;124    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4807              LDR      r0,|L5.32|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;125    
;;;126    	//memset(test_data, 0x55, 2048);
;;;127    
;;;128    	s->state = STATE_CMD;
00000a  2000              MOVS     r0,#0
00000c  7020              STRB     r0,[r4,#0]
;;;129    	s->textlen = 0;
00000e  60a0              STR      r0,[r4,#8]
;;;130    
;;;131    	s->textptr = "Connect STM32-FD Board Success!";
000010  a004              ADR      r0,|L5.36|
000012  6060              STR      r0,[r4,#4]
;;;132    	s->textlen = strlen((char *)s->textptr);
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       strlen
00001a  60a0              STR      r0,[r4,#8]
;;;133    	
;;;134    	//senddata();
;;;135    	
;;;136    	//a[0]=0x0d; a[1]=0x0a;
;;;137    	//s->textptr = a;
;;;138    	//s->textlen = 2;
;;;139    
;;;140    }
00001c  bd10              POP      {r4,pc}
;;;141    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      uip_conn
                  |L5.36|
000024  436f6e6e          DCB      "Connect STM32-FD Board Success!",0
000028  65637420
00002c  53544d33
000030  322d4644
000034  20426f61
000038  72642053
00003c  75636365
000040  73732100

                          AREA ||i.newdata||, CODE, READONLY, ALIGN=2

                  newdata PROC
;;;228    */
;;;229    static void newdata(void)
000000  b510              PUSH     {r4,lr}
;;;230    {
;;;231    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  481c              LDR      r0,|L6.116|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;232    	
;;;233    	if (s->state == STATE_CMD)
00000a  7820              LDRB     r0,[r4,#0]
00000c  b930              CBNZ     r0,|L6.28|
;;;234    	{
;;;235    		printf("uip_newdata!\r\n");
00000e  a01a              ADR      r0,|L6.120|
000010  f7fffffe          BL       __2printf
;;;236    		TCP_Cmd(s);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       TCP_Cmd
00001a  e029              B        |L6.112|
                  |L6.28|
;;;237    	}
;;;238    	else if (s->state == STATE_TX_TEST)	/* 上传测试状态 */
00001c  7820              LDRB     r0,[r4,#0]
00001e  2801              CMP      r0,#1
000020  d10c              BNE      |L6.60|
;;;239    	{
;;;240    		/* 在发送测试状态，如果收到PC机发送的任意数据，则退出测试状态 */
;;;241    		if ((uip_len == 1) && (((uint8_t *)uip_appdata)[0] == 'A'))
000022  4819              LDR      r0,|L6.136|
000024  8800              LDRH     r0,[r0,#0]  ; uip_len
000026  2801              CMP      r0,#1
000028  d104              BNE      |L6.52|
00002a  4818              LDR      r0,|L6.140|
00002c  6800              LDR      r0,[r0,#0]  ; uip_appdata
00002e  7800              LDRB     r0,[r0,#0]
000030  2841              CMP      r0,#0x41
000032  d01d              BEQ      |L6.112|
                  |L6.52|
;;;242    		{
;;;243    			;/* 继续测试 */
;;;244    		}
;;;245    		else
;;;246    		{
;;;247    			/* 退到命令状态 */
;;;248    	   		s->state = STATE_CMD;
000034  2000              MOVS     r0,#0
000036  7020              STRB     r0,[r4,#0]
;;;249    			s->textlen = 0;
000038  60a0              STR      r0,[r4,#8]
00003a  e019              B        |L6.112|
                  |L6.60|
;;;250    		}
;;;251    	}
;;;252    	else if (s->state == STATE_RX_TEST)	/* 下传测试状态 */
00003c  7820              LDRB     r0,[r4,#0]
00003e  2802              CMP      r0,#2
000040  d116              BNE      |L6.112|
;;;253    	{				
;;;254    		if ((uip_len == 4) && (memcmp("stop", uip_appdata, 4) == 0))
000042  4811              LDR      r0,|L6.136|
000044  8800              LDRH     r0,[r0,#0]  ; uip_len
000046  2804              CMP      r0,#4
000048  d10a              BNE      |L6.96|
00004a  2204              MOVS     r2,#4
00004c  480f              LDR      r0,|L6.140|
00004e  6801              LDR      r1,[r0,#0]  ; uip_appdata
000050  a00f              ADR      r0,|L6.144|
000052  f7fffffe          BL       memcmp
000056  b918              CBNZ     r0,|L6.96|
;;;255    		{
;;;256    			/* 退到命令状态 */
;;;257    	   		s->state = STATE_CMD;
000058  2000              MOVS     r0,#0
00005a  7020              STRB     r0,[r4,#0]
;;;258    			s->textlen = 0;
00005c  60a0              STR      r0,[r4,#8]
00005e  e007              B        |L6.112|
                  |L6.96|
;;;259    		}
;;;260    		else
;;;261    		{
;;;262    			static int sLen;
;;;263    
;;;264    			sLen = uip_len;
000060  4809              LDR      r0,|L6.136|
000062  8800              LDRH     r0,[r0,#0]  ; uip_len
000064  490c              LDR      r1,|L6.152|
000066  6008              STR      r0,[r1,#0]  ; sLen
;;;265    			s->textptr = (uint8_t *)&sLen;		/* 配合PC机测试软件，应答接收到的数据长度 */
000068  4608              MOV      r0,r1
00006a  6060              STR      r0,[r4,#4]
;;;266    			s->textlen = 4;
00006c  2004              MOVS     r0,#4
00006e  60a0              STR      r0,[r4,#8]
                  |L6.112|
;;;267    		}
;;;268    	}
;;;269    }
000070  bd10              POP      {r4,pc}
;;;270    
                          ENDP

000072  0000              DCW      0x0000
                  |L6.116|
                          DCD      uip_conn
                  |L6.120|
000078  7569705f          DCB      "uip_newdata!\r\n",0
00007c  6e657764
000080  61746121
000084  0d0a00  
000087  00                DCB      0
                  |L6.136|
                          DCD      uip_len
                  |L6.140|
                          DCD      uip_appdata
                  |L6.144|
000090  73746f70          DCB      "stop",0
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L6.152|
                          DCD      sLen

                          AREA ||i.senddata||, CODE, READONLY, ALIGN=2

                  senddata PROC
;;;309    */
;;;310    static void senddata(void)
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4806              LDR      r0,|L7.28|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;313    
;;;314    	if (s->textlen > 0)
00000a  68a0              LDR      r0,[r4,#8]
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L7.24|
;;;315    	{
;;;316    		/*
;;;317    			这个函数将向网络发送TCP数据包,
;;;318    				s->textptr : 发送的数据包缓冲区指针
;;;319    				s->textlen ：数据包的大小（单位字节）
;;;320    		*/
;;;321    		uip_send(s->textptr, s->textlen);
000010  e9d40101          LDRD     r0,r1,[r4,#4]
000014  f7fffffe          BL       uip_send
                  |L7.24|
;;;322    	}
;;;323    }
000018  bd10              POP      {r4,pc}
;;;324    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      uip_conn

                          AREA ||i.tcp_demo_appcall||, CODE, READONLY, ALIGN=2

                  tcp_demo_appcall PROC
;;;38     */
;;;39     void tcp_demo_appcall(void)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	if (uip_aborted())
000002  4829              LDR      r0,|L8.168|
000004  7800              LDRB     r0,[r0,#0]  ; uip_flags
000006  f0000020          AND      r0,r0,#0x20
00000a  b120              CBZ      r0,|L8.22|
;;;42     	{
;;;43     		printf("uip_aborted!\r\n");
00000c  a027              ADR      r0,|L8.172|
00000e  f7fffffe          BL       __2printf
;;;44     		aborted();
000012  f7fffffe          BL       aborted
                  |L8.22|
;;;45     	}
;;;46     
;;;47     	if (uip_timedout())
000016  4824              LDR      r0,|L8.168|
000018  7800              LDRB     r0,[r0,#0]  ; uip_flags
00001a  f0000080          AND      r0,r0,#0x80
00001e  b120              CBZ      r0,|L8.42|
;;;48     	{
;;;49     		printf("uip_timedout!\r\n");
000020  a026              ADR      r0,|L8.188|
000022  f7fffffe          BL       __2printf
;;;50     		timedout();
000026  f7fffffe          BL       timedout
                  |L8.42|
;;;51     	}
;;;52     
;;;53     	if (uip_closed())
00002a  481f              LDR      r0,|L8.168|
00002c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00002e  f0000010          AND      r0,r0,#0x10
000032  b120              CBZ      r0,|L8.62|
;;;54     	{
;;;55     		printf("uip_closed!\r\n");
000034  a025              ADR      r0,|L8.204|
000036  f7fffffe          BL       __2printf
;;;56     		closed();
00003a  f7fffffe          BL       closed
                  |L8.62|
;;;57     	}
;;;58     
;;;59     	if (uip_connected())
00003e  481a              LDR      r0,|L8.168|
000040  7800              LDRB     r0,[r0,#0]  ; uip_flags
000042  f0000040          AND      r0,r0,#0x40
000046  b120              CBZ      r0,|L8.82|
;;;60     	{
;;;61     		printf("uip_connected!\r\n");
000048  a024              ADR      r0,|L8.220|
00004a  f7fffffe          BL       __2printf
;;;62     		connected();
00004e  f7fffffe          BL       connected
                  |L8.82|
;;;63     	}
;;;64     
;;;65     	if (uip_acked())
000052  4815              LDR      r0,|L8.168|
000054  7800              LDRB     r0,[r0,#0]  ; uip_flags
000056  f0000001          AND      r0,r0,#1
00005a  b108              CBZ      r0,|L8.96|
;;;66     	{
;;;67     		acked();
00005c  f7fffffe          BL       acked
                  |L8.96|
;;;68     	}
;;;69     
;;;70     	/* 接收到一个新的TCP数据包，准备需要发送数据 */
;;;71     	if (uip_newdata())
000060  4811              LDR      r0,|L8.168|
000062  7800              LDRB     r0,[r0,#0]  ; uip_flags
000064  f0000002          AND      r0,r0,#2
000068  b108              CBZ      r0,|L8.110|
;;;72     	{
;;;73     		newdata();
00006a  f7fffffe          BL       newdata
                  |L8.110|
;;;74     	}
;;;75     
;;;76     	/* 当需要重发、新数据到达、数据包送达、连接建立时，通知uip发送数据 */
;;;77     	if (uip_rexmit() ||	uip_newdata() || uip_acked() ||	uip_connected() || uip_poll())
00006e  480e              LDR      r0,|L8.168|
000070  7800              LDRB     r0,[r0,#0]  ; uip_flags
000072  f0000004          AND      r0,r0,#4
000076  b998              CBNZ     r0,|L8.160|
000078  480b              LDR      r0,|L8.168|
00007a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00007c  f0000002          AND      r0,r0,#2
000080  b970              CBNZ     r0,|L8.160|
000082  4809              LDR      r0,|L8.168|
000084  7800              LDRB     r0,[r0,#0]  ; uip_flags
000086  f0000001          AND      r0,r0,#1
00008a  b948              CBNZ     r0,|L8.160|
00008c  4806              LDR      r0,|L8.168|
00008e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000090  f0000040          AND      r0,r0,#0x40
000094  b920              CBNZ     r0,|L8.160|
000096  4804              LDR      r0,|L8.168|
000098  7800              LDRB     r0,[r0,#0]  ; uip_flags
00009a  f0000008          AND      r0,r0,#8
00009e  b108              CBZ      r0,|L8.164|
                  |L8.160|
;;;78     	{
;;;79     		senddata();
0000a0  f7fffffe          BL       senddata
                  |L8.164|
;;;80     	}
;;;81     }
0000a4  bd10              POP      {r4,pc}
;;;82     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L8.168|
                          DCD      uip_flags
                  |L8.172|
0000ac  7569705f          DCB      "uip_aborted!\r\n",0
0000b0  61626f72
0000b4  74656421
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L8.188|
0000bc  7569705f          DCB      "uip_timedout!\r\n",0
0000c0  74696d65
0000c4  646f7574
0000c8  210d0a00
                  |L8.204|
0000cc  7569705f          DCB      "uip_closed!\r\n",0
0000d0  636c6f73
0000d4  6564210d
0000d8  0a00    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L8.220|
0000dc  7569705f          DCB      "uip_connected!\r\n",0
0000e0  636f6e6e
0000e4  65637465
0000e8  64210d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0

                          AREA ||i.timedout||, CODE, READONLY, ALIGN=1

                  timedout PROC
;;;93     
;;;94     static void timedout(void)
000000  4770              BX       lr
;;;95     {
;;;96     	;
;;;97     }
;;;98     
                          ENDP


                          AREA ||i.uip_log||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  uip_log PROC
;;;331    */
;;;332    void uip_log(char *m)
000000  b510              PUSH     {r4,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334    	printf("uIP log message: %s\r\n", m);
000004  4621              MOV      r1,r4
000006  a002              ADR      r0,|L10.16|
000008  f7fffffe          BL       __2printf
;;;335    }
00000c  bd10              POP      {r4,pc}
;;;336    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
000010  75495020          DCB      "uIP log message: %s\r\n",0
000014  6c6f6720
000018  6d657373
00001c  6167653a
000020  2025730d
000024  0a00    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  test_data
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  sLen
                          DCD      0x00000000
