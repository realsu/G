; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tcp_demo.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\tcp_demo.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -I..\..\Source\inc -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\tcp_demo.crf ..\..\Source\src\tcp_demo.c]
                          THUMB

                          AREA ||i.TCP_Cmd||, CODE, READONLY, ALIGN=2

                  TCP_Cmd PROC
;;;147    */
;;;148    void TCP_Cmd(struct tcp_demo_appstate *s)
000000  b570              PUSH     {r4-r6,lr}
;;;149    {
000002  4604              MOV      r4,r0
;;;150    	uint8_t led;
;;;151    	
;;;152    	/* 点亮LED
;;;153    		语法：ledon n  (n : 1 - 4) 
;;;154    		例如 ： 
;;;155    		ledon 2 表示点亮LED2	
;;;156    	*/
;;;157    	if ((uip_len == 7) && (memcmp("ledon ", uip_appdata, 6) == 0))
000004  4850              LDR      r0,|L1.328|
000006  8800              LDRH     r0,[r0,#0]  ; uip_len
000008  2807              CMP      r0,#7
00000a  d133              BNE      |L1.116|
00000c  2206              MOVS     r2,#6
00000e  484f              LDR      r0,|L1.332|
000010  6801              LDR      r1,[r0,#0]  ; uip_appdata
000012  a04f              ADR      r0,|L1.336|
000014  f7fffffe          BL       memcmp
000018  2800              CMP      r0,#0
00001a  d12b              BNE      |L1.116|
;;;158    	{
;;;159    		led = ((uint8_t *)uip_appdata)[6]; /* 操作的LED序号 */
00001c  484b              LDR      r0,|L1.332|
00001e  6800              LDR      r0,[r0,#0]  ; uip_appdata
000020  7985              LDRB     r5,[r0,#6]
;;;160    		if (led == '1')
000022  2d31              CMP      r5,#0x31
000024  d118              BNE      |L1.88|
;;;161    		{
;;;162    			LED1_ON();
000026  f44f7100          MOV      r1,#0x200
00002a  484b              LDR      r0,|L1.344|
00002c  f7fffffe          BL       GPIO_ResetBits
;;;163                //printf("on\r\n");
;;;164                
;;;165    			s->textptr = "Motor On!";
000030  a04a              ADR      r0,|L1.348|
000032  6060              STR      r0,[r4,#4]
;;;166    
;;;167                //数据地址A1
;;;168                    data[0] = 0x80; 													
000034  2080              MOVS     r0,#0x80
000036  494c              LDR      r1,|L1.360|
000038  7008              STRB     r0,[r1,#0]
;;;169                //数据高8位
;;;170                    data[1] = 0x00; 													
00003a  2000              MOVS     r0,#0
00003c  7048              STRB     r0,[r1,#1]
;;;171                //数据底8位
;;;172                    data[2] = 0x80;										
00003e  2080              MOVS     r0,#0x80
000040  7088              STRB     r0,[r1,#2]
;;;173                //数据校验和(A1+A2+A3)
;;;174                    data[3] = 0x00;
000042  2000              MOVS     r0,#0
000044  70c8              STRB     r0,[r1,#3]
;;;175                Uart1ASendStr(data,4);
000046  2104              MOVS     r1,#4
000048  4847              LDR      r0,|L1.360|
00004a  f7fffffe          BL       Uart1ASendStr
;;;176                Uart2ASendStr(data,4);
00004e  2104              MOVS     r1,#4
000050  4845              LDR      r0,|L1.360|
000052  f7fffffe          BL       Uart2ASendStr
000056  e008              B        |L1.106|
                  |L1.88|
;;;177    		}
;;;178    		else if (led == '2')
000058  2d32              CMP      r5,#0x32
00005a  d106              BNE      |L1.106|
;;;179    		{
;;;180    			LED2_ON();
00005c  f44f6180          MOV      r1,#0x400
000060  483d              LDR      r0,|L1.344|
000062  f7fffffe          BL       GPIO_ResetBits
;;;181                //printf("led 2 on\r\n");
;;;182    			s->textptr = "Led 2 On!";			
000066  a041              ADR      r0,|L1.364|
000068  6060              STR      r0,[r4,#4]
                  |L1.106|
;;;183    		}
;;;184    		
;;;185    		s->textlen = strlen((char *)s->textptr);
00006a  6860              LDR      r0,[r4,#4]
00006c  f7fffffe          BL       strlen
000070  60a0              STR      r0,[r4,#8]
000072  e068              B        |L1.326|
                  |L1.116|
;;;186    	}
;;;187    	/* 关闭LED
;;;188    		语法：ledoff n  (n : 1 - 4) 
;;;189    		例如 ： 
;;;190    		ledon 2 表示点亮LED2	
;;;191    	*/
;;;192    	else if ((uip_len == 8) && (memcmp("ledoff ", uip_appdata, 7) == 0))
000074  4834              LDR      r0,|L1.328|
000076  8800              LDRH     r0,[r0,#0]  ; uip_len
000078  2808              CMP      r0,#8
00007a  d139              BNE      |L1.240|
00007c  2207              MOVS     r2,#7
00007e  4833              LDR      r0,|L1.332|
000080  6801              LDR      r1,[r0,#0]  ; uip_appdata
000082  a03d              ADR      r0,|L1.376|
000084  f7fffffe          BL       memcmp
000088  2800              CMP      r0,#0
00008a  d131              BNE      |L1.240|
;;;193    	{
;;;194    		led = ((uint8_t *)uip_appdata)[7]; /* 操作的LED序号 */
00008c  482f              LDR      r0,|L1.332|
00008e  6800              LDR      r0,[r0,#0]  ; uip_appdata
000090  79c5              LDRB     r5,[r0,#7]
;;;195    		if (led == '1')
000092  2d31              CMP      r5,#0x31
000094  d11e              BNE      |L1.212|
;;;196    		{
;;;197    			LED1_OFF();
000096  f44f7100          MOV      r1,#0x200
00009a  482f              LDR      r0,|L1.344|
00009c  f7fffffe          BL       GPIO_SetBits
;;;198                //printf("off\r\n");
;;;199                //数据地址A1
;;;200                data[0] = 0x00; 													
0000a0  2000              MOVS     r0,#0
0000a2  4931              LDR      r1,|L1.360|
0000a4  7008              STRB     r0,[r1,#0]
;;;201                //数据高8位
;;;202                data[1] = 0x00; 													
0000a6  7048              STRB     r0,[r1,#1]
;;;203                //数据底8位
;;;204                data[2] = 0x01;										
0000a8  2001              MOVS     r0,#1
0000aa  7088              STRB     r0,[r1,#2]
;;;205                //数据校验和(A1+A2+A3)
;;;206                data[3] = data[0] + data[1] + data[2];
0000ac  4608              MOV      r0,r1
0000ae  7800              LDRB     r0,[r0,#0]  ; data
0000b0  7849              LDRB     r1,[r1,#1]  ; data
0000b2  4408              ADD      r0,r0,r1
0000b4  492c              LDR      r1,|L1.360|
0000b6  7889              LDRB     r1,[r1,#2]  ; data
0000b8  4408              ADD      r0,r0,r1
0000ba  492b              LDR      r1,|L1.360|
0000bc  70c8              STRB     r0,[r1,#3]
;;;207                Uart1ASendStr(data,4);
0000be  2104              MOVS     r1,#4
0000c0  4829              LDR      r0,|L1.360|
0000c2  f7fffffe          BL       Uart1ASendStr
;;;208                Uart2ASendStr(data,4);
0000c6  2104              MOVS     r1,#4
0000c8  4827              LDR      r0,|L1.360|
0000ca  f7fffffe          BL       Uart2ASendStr
;;;209    			s->textptr = "Motor Off!";
0000ce  a02c              ADR      r0,|L1.384|
0000d0  6060              STR      r0,[r4,#4]
0000d2  e008              B        |L1.230|
                  |L1.212|
;;;210    		}
;;;211    		else if (led == '2')
0000d4  2d32              CMP      r5,#0x32
0000d6  d106              BNE      |L1.230|
;;;212    		{
;;;213    			LED2_OFF();
0000d8  f44f6180          MOV      r1,#0x400
0000dc  481e              LDR      r0,|L1.344|
0000de  f7fffffe          BL       GPIO_SetBits
;;;214                //printf("led 2 off\r\n");
;;;215    			s->textptr = "Led 2 Off!";				
0000e2  a02a              ADR      r0,|L1.396|
0000e4  6060              STR      r0,[r4,#4]
                  |L1.230|
;;;216    		}
;;;217    				
;;;218    		s->textlen = strlen((char *)s->textptr);
0000e6  6860              LDR      r0,[r4,#4]
0000e8  f7fffffe          BL       strlen
0000ec  60a0              STR      r0,[r4,#8]
0000ee  e02a              B        |L1.326|
                  |L1.240|
;;;219    	}
;;;220    	/* 发送数据测试 sendtest
;;;221    		语法：sendtest
;;;222    		例如 ：
;;;223    		ledon 2 表示点亮LED2
;;;224    	*/
;;;225    	else if ((uip_len == 6) && (memcmp("txtest", uip_appdata, 6) == 0))
0000f0  4815              LDR      r0,|L1.328|
0000f2  8800              LDRH     r0,[r0,#0]  ; uip_len
0000f4  2806              CMP      r0,#6
0000f6  d10e              BNE      |L1.278|
0000f8  2206              MOVS     r2,#6
0000fa  4814              LDR      r0,|L1.332|
0000fc  6801              LDR      r1,[r0,#0]  ; uip_appdata
0000fe  a026              ADR      r0,|L1.408|
000100  f7fffffe          BL       memcmp
000104  b938              CBNZ     r0,|L1.278|
;;;226    	{
;;;227    		s->state = STATE_TX_TEST;
000106  2001              MOVS     r0,#1
000108  7020              STRB     r0,[r4,#0]
;;;228    
;;;229    		s->textptr = test_data;
00010a  4825              LDR      r0,|L1.416|
00010c  6060              STR      r0,[r4,#4]
;;;230    		s->textlen = 1400;
00010e  f44f60af          MOV      r0,#0x578
000112  60a0              STR      r0,[r4,#8]
000114  e017              B        |L1.326|
                  |L1.278|
;;;231    	}
;;;232    	else if ((uip_len == 6) && (memcmp("rxtest", uip_appdata, 6) == 0))
000116  480c              LDR      r0,|L1.328|
000118  8800              LDRH     r0,[r0,#0]  ; uip_len
00011a  2806              CMP      r0,#6
00011c  d10d              BNE      |L1.314|
00011e  2206              MOVS     r2,#6
000120  480a              LDR      r0,|L1.332|
000122  6801              LDR      r1,[r0,#0]  ; uip_appdata
000124  a01f              ADR      r0,|L1.420|
000126  f7fffffe          BL       memcmp
00012a  b930              CBNZ     r0,|L1.314|
;;;233    	{
;;;234    		s->state = STATE_RX_TEST;
00012c  2002              MOVS     r0,#2
00012e  7020              STRB     r0,[r4,#0]
;;;235    		s->textptr = "Ok";
000130  a01e              ADR      r0,|L1.428|
000132  6060              STR      r0,[r4,#4]
;;;236    		s->textlen = 2;
000134  2002              MOVS     r0,#2
000136  60a0              STR      r0,[r4,#8]
000138  e005              B        |L1.326|
                  |L1.314|
;;;237    	}
;;;238    	else
;;;239    	{
;;;240    		s->textptr = "Unknow Command!\r\n";
00013a  a01d              ADR      r0,|L1.432|
00013c  6060              STR      r0,[r4,#4]
;;;241    		s->textlen = strlen((char *)s->textptr);
00013e  6860              LDR      r0,[r4,#4]
000140  f7fffffe          BL       strlen
000144  60a0              STR      r0,[r4,#8]
                  |L1.326|
;;;242    	}
;;;243    }
000146  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L1.328|
                          DCD      uip_len
                  |L1.332|
                          DCD      uip_appdata
                  |L1.336|
000150  6c65646f          DCB      "ledon ",0
000154  6e2000  
000157  00                DCB      0
                  |L1.344|
                          DCD      0x40010800
                  |L1.348|
00015c  4d6f746f          DCB      "Motor On!",0
000160  72204f6e
000164  2100    
000166  00                DCB      0
000167  00                DCB      0
                  |L1.360|
                          DCD      data
                  |L1.364|
00016c  4c656420          DCB      "Led 2 On!",0
000170  32204f6e
000174  2100    
000176  00                DCB      0
000177  00                DCB      0
                  |L1.376|
000178  6c65646f          DCB      "ledoff ",0
00017c  66662000
                  |L1.384|
000180  4d6f746f          DCB      "Motor Off!",0
000184  72204f66
000188  662100  
00018b  00                DCB      0
                  |L1.396|
00018c  4c656420          DCB      "Led 2 Off!",0
000190  32204f66
000194  662100  
000197  00                DCB      0
                  |L1.408|
000198  74787465          DCB      "txtest",0
00019c  737400  
00019f  00                DCB      0
                  |L1.416|
                          DCD      test_data
                  |L1.420|
0001a4  72787465          DCB      "rxtest",0
0001a8  737400  
0001ab  00                DCB      0
                  |L1.428|
0001ac  4f6b00            DCB      "Ok",0
0001af  00                DCB      0
                  |L1.432|
0001b0  556e6b6e          DCB      "Unknow Command!\r\n",0
0001b4  6f772043
0001b8  6f6d6d61
0001bc  6e64210d
0001c0  0a00    
0001c2  00                DCB      0
0001c3  00                DCB      0

                          AREA ||i.aborted||, CODE, READONLY, ALIGN=1

                  aborted PROC
;;;88     */
;;;89     static void aborted(void)
000000  4770              BX       lr
;;;90     {
;;;91     	;
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.acked||, CODE, READONLY, ALIGN=2

                  acked PROC
;;;298    */
;;;299    static void acked(void)
000000  490c              LDR      r1,|L3.52|
;;;300    {
;;;301    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  6809              LDR      r1,[r1,#0]  ; uip_conn
000004  f101001c          ADD      r0,r1,#0x1c
;;;302    
;;;303    	switch(s->state)
000008  7801              LDRB     r1,[r0,#0]
00000a  b121              CBZ      r1,|L3.22|
00000c  2901              CMP      r1,#1
00000e  d005              BEQ      |L3.28|
000010  2902              CMP      r1,#2
000012  d10c              BNE      |L3.46|
000014  e008              B        |L3.40|
                  |L3.22|
;;;304    	{
;;;305    		case STATE_CMD:		 /* 在命令状态 */
;;;306    			s->textlen = 0;
000016  2100              MOVS     r1,#0
000018  6081              STR      r1,[r0,#8]
;;;307    
;;;308    			/* 
;;;309    				只在命令状态打印调试信息 
;;;310    				避免发送测试时，影响通信速度		
;;;311    			*/
;;;312    			//printf("uip_acked!\r\n");
;;;313    			break;
00001a  e008              B        |L3.46|
                  |L3.28|
;;;314    
;;;315    		case STATE_TX_TEST:
;;;316    			s->textptr = test_data;	/* 连续发送 */
00001c  4906              LDR      r1,|L3.56|
00001e  6041              STR      r1,[r0,#4]
;;;317    			s->textlen = 1400;
000020  f44f61af          MOV      r1,#0x578
000024  6081              STR      r1,[r0,#8]
;;;318    			break;
000026  e002              B        |L3.46|
                  |L3.40|
;;;319    
;;;320    		case STATE_RX_TEST:
;;;321    			s->textlen = 0;
000028  2100              MOVS     r1,#0
00002a  6081              STR      r1,[r0,#8]
;;;322    			break;
00002c  bf00              NOP      
                  |L3.46|
00002e  bf00              NOP                            ;313
;;;323    	}
;;;324    }
000030  4770              BX       lr
;;;325    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      uip_conn
                  |L3.56|
                          DCD      test_data

                          AREA ||i.closed||, CODE, READONLY, ALIGN=1

                  closed PROC
;;;98     
;;;99     static void closed(void)
000000  4770              BX       lr
;;;100    {
;;;101    	;
;;;102    }
;;;103    
                          ENDP


                          AREA ||i.connected||, CODE, READONLY, ALIGN=2

                  connected PROC
;;;109    */
;;;110    static void connected(void)
000000  b510              PUSH     {r4,lr}
;;;111    {  
;;;112        //unsigned char a[2]; 
;;;113    	/*
;;;114    		uip_conn结构体有一个"appstate"字段指向应用程序自定义的结构体。
;;;115    		声明一个s指针，是为了便于使用。
;;;116    
;;;117    		不需要再单独为每个uip_conn分配内存，这个已经在uip中分配好了。
;;;118    		在uip.c 中 的相关代码如下：
;;;119    			struct uip_conn *uip_conn;
;;;120    			struct uip_conn uip_conns[UIP_CONNS]; //UIP_CONNS缺省=10
;;;121    		定义了1个连接的数组，支持同时创建几个连接。
;;;122    		uip_conn是一个全局的指针，指向当前的tcp或udp连接。
;;;123    	*/
;;;124    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4807              LDR      r0,|L5.32|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;125    
;;;126    	//memset(test_data, 0x55, 2048);
;;;127    
;;;128    	s->state = STATE_CMD;
00000a  2000              MOVS     r0,#0
00000c  7020              STRB     r0,[r4,#0]
;;;129    	s->textlen = 0;
00000e  60a0              STR      r0,[r4,#8]
;;;130    
;;;131    	s->textptr = "Connect STM32-FD Board Success!";
000010  a004              ADR      r0,|L5.36|
000012  6060              STR      r0,[r4,#4]
;;;132    	s->textlen = strlen((char *)s->textptr);
000014  6860              LDR      r0,[r4,#4]
000016  f7fffffe          BL       strlen
00001a  60a0              STR      r0,[r4,#8]
;;;133    	
;;;134    	//senddata();
;;;135    	
;;;136    	//a[0]=0x0d; a[1]=0x0a;
;;;137    	//s->textptr = a;
;;;138    	//s->textlen = 2;
;;;139    
;;;140    }
00001c  bd10              POP      {r4,pc}
;;;141    
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      uip_conn
                  |L5.36|
000024  436f6e6e          DCB      "Connect STM32-FD Board Success!",0
000028  65637420
00002c  53544d33
000030  322d4644
000034  20426f61
000038  72642053
00003c  75636365
000040  73732100

                          AREA ||i.newdata||, CODE, READONLY, ALIGN=2

                  newdata PROC
;;;250    */
;;;251    static void newdata(void)
000000  b510              PUSH     {r4,lr}
;;;252    {
;;;253    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  481a              LDR      r0,|L6.108|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;254    	
;;;255    	if (s->state == STATE_CMD)
00000a  7820              LDRB     r0,[r4,#0]
00000c  b918              CBNZ     r0,|L6.22|
;;;256    	{
;;;257    		//printf("uip_newdata!\r\n");
;;;258    		TCP_Cmd(s);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       TCP_Cmd
000014  e029              B        |L6.106|
                  |L6.22|
;;;259    	}
;;;260    	else if (s->state == STATE_TX_TEST)	/* 上传测试状态 */
000016  7820              LDRB     r0,[r4,#0]
000018  2801              CMP      r0,#1
00001a  d10c              BNE      |L6.54|
;;;261    	{
;;;262    		/* 在发送测试状态，如果收到PC机发送的任意数据，则退出测试状态 */
;;;263    		if ((uip_len == 1) && (((uint8_t *)uip_appdata)[0] == 'A'))
00001c  4814              LDR      r0,|L6.112|
00001e  8800              LDRH     r0,[r0,#0]  ; uip_len
000020  2801              CMP      r0,#1
000022  d104              BNE      |L6.46|
000024  4813              LDR      r0,|L6.116|
000026  6800              LDR      r0,[r0,#0]  ; uip_appdata
000028  7800              LDRB     r0,[r0,#0]
00002a  2841              CMP      r0,#0x41
00002c  d01d              BEQ      |L6.106|
                  |L6.46|
;;;264    		{
;;;265    			;/* 继续测试 */
;;;266    		}
;;;267    		else
;;;268    		{
;;;269    			/* 退到命令状态 */
;;;270    	   		s->state = STATE_CMD;
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
;;;271    			s->textlen = 0;
000032  60a0              STR      r0,[r4,#8]
000034  e019              B        |L6.106|
                  |L6.54|
;;;272    		}
;;;273    	}
;;;274    	else if (s->state == STATE_RX_TEST)	/* 下传测试状态 */
000036  7820              LDRB     r0,[r4,#0]
000038  2802              CMP      r0,#2
00003a  d116              BNE      |L6.106|
;;;275    	{				
;;;276    		if ((uip_len == 4) && (memcmp("stop", uip_appdata, 4) == 0))
00003c  480c              LDR      r0,|L6.112|
00003e  8800              LDRH     r0,[r0,#0]  ; uip_len
000040  2804              CMP      r0,#4
000042  d10a              BNE      |L6.90|
000044  2204              MOVS     r2,#4
000046  480b              LDR      r0,|L6.116|
000048  6801              LDR      r1,[r0,#0]  ; uip_appdata
00004a  a00b              ADR      r0,|L6.120|
00004c  f7fffffe          BL       memcmp
000050  b918              CBNZ     r0,|L6.90|
;;;277    		{
;;;278    			/* 退到命令状态 */
;;;279    	   		s->state = STATE_CMD;
000052  2000              MOVS     r0,#0
000054  7020              STRB     r0,[r4,#0]
;;;280    			s->textlen = 0;
000056  60a0              STR      r0,[r4,#8]
000058  e007              B        |L6.106|
                  |L6.90|
;;;281    		}
;;;282    		else
;;;283    		{
;;;284    			static int sLen;
;;;285    
;;;286    			sLen = uip_len;
00005a  4805              LDR      r0,|L6.112|
00005c  8800              LDRH     r0,[r0,#0]  ; uip_len
00005e  4908              LDR      r1,|L6.128|
000060  6008              STR      r0,[r1,#0]  ; sLen
;;;287    			s->textptr = (uint8_t *)&sLen;		/* 配合PC机测试软件，应答接收到的数据长度 */
000062  4608              MOV      r0,r1
000064  6060              STR      r0,[r4,#4]
;;;288    			s->textlen = 4;
000066  2004              MOVS     r0,#4
000068  60a0              STR      r0,[r4,#8]
                  |L6.106|
;;;289    		}
;;;290    	}
;;;291    }
00006a  bd10              POP      {r4,pc}
;;;292    
                          ENDP

                  |L6.108|
                          DCD      uip_conn
                  |L6.112|
                          DCD      uip_len
                  |L6.116|
                          DCD      uip_appdata
                  |L6.120|
000078  73746f70          DCB      "stop",0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L6.128|
                          DCD      sLen

                          AREA ||i.senddata||, CODE, READONLY, ALIGN=2

                  senddata PROC
;;;331    */
;;;332    static void senddata(void)
000000  b510              PUSH     {r4,lr}
;;;333    {
;;;334    	struct tcp_demo_appstate *s = (struct tcp_demo_appstate *)&uip_conn->appstate;
000002  4806              LDR      r0,|L7.28|
000004  6800              LDR      r0,[r0,#0]  ; uip_conn
000006  f100041c          ADD      r4,r0,#0x1c
;;;335    
;;;336    	if (s->textlen > 0)
00000a  68a0              LDR      r0,[r4,#8]
00000c  2800              CMP      r0,#0
00000e  dd03              BLE      |L7.24|
;;;337    	{
;;;338    		/*
;;;339    			这个函数将向网络发送TCP数据包,
;;;340    				s->textptr : 发送的数据包缓冲区指针
;;;341    				s->textlen ：数据包的大小（单位字节）
;;;342    		*/
;;;343    		uip_send(s->textptr, s->textlen);
000010  e9d40101          LDRD     r0,r1,[r4,#4]
000014  f7fffffe          BL       uip_send
                  |L7.24|
;;;344    	}
;;;345    }
000018  bd10              POP      {r4,pc}
;;;346    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      uip_conn

                          AREA ||i.tcp_demo_appcall||, CODE, READONLY, ALIGN=2

                  tcp_demo_appcall PROC
;;;38     */
;;;39     void tcp_demo_appcall(void)
000000  b510              PUSH     {r4,lr}
;;;40     {
;;;41     	if (uip_aborted())
000002  4823              LDR      r0,|L8.144|
000004  7800              LDRB     r0,[r0,#0]  ; uip_flags
000006  f0000020          AND      r0,r0,#0x20
00000a  b108              CBZ      r0,|L8.16|
;;;42     	{
;;;43     		//printf("uip_aborted!\r\n");
;;;44     		aborted();
00000c  f7fffffe          BL       aborted
                  |L8.16|
;;;45     	}
;;;46     
;;;47     	if (uip_timedout())
000010  481f              LDR      r0,|L8.144|
000012  7800              LDRB     r0,[r0,#0]  ; uip_flags
000014  f0000080          AND      r0,r0,#0x80
000018  b108              CBZ      r0,|L8.30|
;;;48     	{
;;;49     		//printf("uip_timedout!\r\n");
;;;50     		timedout();
00001a  f7fffffe          BL       timedout
                  |L8.30|
;;;51     	}
;;;52     
;;;53     	if (uip_closed())
00001e  481c              LDR      r0,|L8.144|
000020  7800              LDRB     r0,[r0,#0]  ; uip_flags
000022  f0000010          AND      r0,r0,#0x10
000026  b108              CBZ      r0,|L8.44|
;;;54     	{
;;;55     		//printf("uip_closed!\r\n");
;;;56     		closed();
000028  f7fffffe          BL       closed
                  |L8.44|
;;;57     	}
;;;58     
;;;59     	if (uip_connected())
00002c  4818              LDR      r0,|L8.144|
00002e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000030  f0000040          AND      r0,r0,#0x40
000034  b108              CBZ      r0,|L8.58|
;;;60     	{
;;;61     		//printf("uip_connected!\r\n");
;;;62     		connected();
000036  f7fffffe          BL       connected
                  |L8.58|
;;;63     	}
;;;64     
;;;65     	if (uip_acked())
00003a  4815              LDR      r0,|L8.144|
00003c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00003e  f0000001          AND      r0,r0,#1
000042  b108              CBZ      r0,|L8.72|
;;;66     	{
;;;67     		acked();
000044  f7fffffe          BL       acked
                  |L8.72|
;;;68     	}
;;;69     
;;;70     	/* 接收到一个新的TCP数据包，准备需要发送数据 */
;;;71     	if (uip_newdata())
000048  4811              LDR      r0,|L8.144|
00004a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00004c  f0000002          AND      r0,r0,#2
000050  b108              CBZ      r0,|L8.86|
;;;72     	{
;;;73     		newdata();
000052  f7fffffe          BL       newdata
                  |L8.86|
;;;74     	}
;;;75     
;;;76     	/* 当需要重发、新数据到达、数据包送达、连接建立时，通知uip发送数据 */
;;;77     	if (uip_rexmit() ||	uip_newdata() || uip_acked() ||	uip_connected() || uip_poll())
000056  480e              LDR      r0,|L8.144|
000058  7800              LDRB     r0,[r0,#0]  ; uip_flags
00005a  f0000004          AND      r0,r0,#4
00005e  b998              CBNZ     r0,|L8.136|
000060  480b              LDR      r0,|L8.144|
000062  7800              LDRB     r0,[r0,#0]  ; uip_flags
000064  f0000002          AND      r0,r0,#2
000068  b970              CBNZ     r0,|L8.136|
00006a  4809              LDR      r0,|L8.144|
00006c  7800              LDRB     r0,[r0,#0]  ; uip_flags
00006e  f0000001          AND      r0,r0,#1
000072  b948              CBNZ     r0,|L8.136|
000074  4806              LDR      r0,|L8.144|
000076  7800              LDRB     r0,[r0,#0]  ; uip_flags
000078  f0000040          AND      r0,r0,#0x40
00007c  b920              CBNZ     r0,|L8.136|
00007e  4804              LDR      r0,|L8.144|
000080  7800              LDRB     r0,[r0,#0]  ; uip_flags
000082  f0000008          AND      r0,r0,#8
000086  b108              CBZ      r0,|L8.140|
                  |L8.136|
;;;78     	{
;;;79     		senddata();
000088  f7fffffe          BL       senddata
                  |L8.140|
;;;80     	}
;;;81     }
00008c  bd10              POP      {r4,pc}
;;;82     
                          ENDP

00008e  0000              DCW      0x0000
                  |L8.144|
                          DCD      uip_flags

                          AREA ||i.timedout||, CODE, READONLY, ALIGN=1

                  timedout PROC
;;;93     
;;;94     static void timedout(void)
000000  4770              BX       lr
;;;95     {
;;;96     	;
;;;97     }
;;;98     
                          ENDP


                          AREA ||i.uip_log||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  uip_log PROC
;;;353    */
;;;354    void uip_log(char *m)
000000  b510              PUSH     {r4,lr}
;;;355    {
000002  4604              MOV      r4,r0
;;;356    	printf("uIP log message: %s\r\n", m);
000004  4621              MOV      r1,r4
000006  a002              ADR      r0,|L10.16|
000008  f7fffffe          BL       __2printf
;;;357    }
00000c  bd10              POP      {r4,pc}
;;;358    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
000010  75495020          DCB      "uIP log message: %s\r\n",0
000014  6c6f6720
000018  6d657373
00001c  6167653a
000020  2025730d
000024  0a00    
000026  00                DCB      0
000027  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  test_data
                          %        2048

                          AREA ||.data||, DATA, ALIGN=2

                  data
                          DCD      0x00000000
                  sLen
                          DCD      0x00000000
