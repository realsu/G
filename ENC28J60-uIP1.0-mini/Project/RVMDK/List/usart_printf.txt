; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usart_printf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\usart_printf.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usart_printf.crf ..\..\Source\src\usart_printf.c]
                          THUMB

                          AREA ||i.PrintfLogo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  PrintfLogo PROC
;;;24     */
;;;25     void PrintfLogo(char *strName, char *strDate)
000000  b570              PUSH     {r4-r6,lr}
;;;26     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;27     	printf("*************************************************************\n\r");
000006  a00f              ADR      r0,|L1.68|
000008  f7fffffe          BL       __2printf
;;;28     	printf("* Example Name : %s\r\n", strName);
00000c  4621              MOV      r1,r4
00000e  a01d              ADR      r0,|L1.132|
000010  f7fffffe          BL       __2printf
;;;29     	printf("* Update Date  : %s\r\n", strDate);
000014  4629              MOV      r1,r5
000016  a021              ADR      r0,|L1.156|
000018  f7fffffe          BL       __2printf
;;;30     	printf("* StdPeriph_Lib Version : V3.1.2\n\r");
00001c  a025              ADR      r0,|L1.180|
00001e  f7fffffe          BL       __2printf
;;;31     	printf("* \n\r");
000022  a02d              ADR      r0,|L1.216|
000024  f7fffffe          BL       __2printf
;;;32     	printf("* Copyright ourstm.5d6d.com \r\n");
000028  a02d              ADR      r0,|L1.224|
00002a  f7fffffe          BL       __2printf
;;;33     	printf("* QQ    : 9191274 \r\n");
00002e  a034              ADR      r0,|L1.256|
000030  f7fffffe          BL       __2printf
;;;34     	printf("* Email : sun68@qq.com \r\n");
000034  a038              ADR      r0,|L1.280|
000036  f7fffffe          BL       __2printf
;;;35     	printf("*************************************************************\n\r");
00003a  a002              ADR      r0,|L1.68|
00003c  f7fffffe          BL       __2printf
;;;36     }
000040  bd70              POP      {r4-r6,pc}
;;;37     
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
000044  2a2a2a2a          DCB      "*******************************************************"
000048  2a2a2a2a
00004c  2a2a2a2a
000050  2a2a2a2a
000054  2a2a2a2a
000058  2a2a2a2a
00005c  2a2a2a2a
000060  2a2a2a2a
000064  2a2a2a2a
000068  2a2a2a2a
00006c  2a2a2a2a
000070  2a2a2a2a
000074  2a2a2a2a
000078  2a2a2a  
00007b  2a2a2a2a          DCB      "******\n\r",0
00007f  2a2a0a0d
000083  00      
                  |L1.132|
000084  2a204578          DCB      "* Example Name : %s\r\n",0
000088  616d706c
00008c  65204e61
000090  6d65203a
000094  2025730d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L1.156|
00009c  2a205570          DCB      "* Update Date  : %s\r\n",0
0000a0  64617465
0000a4  20446174
0000a8  6520203a
0000ac  2025730d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L1.180|
0000b4  2a205374          DCB      "* StdPeriph_Lib Version : V3.1.2\n\r",0
0000b8  64506572
0000bc  6970685f
0000c0  4c696220
0000c4  56657273
0000c8  696f6e20
0000cc  3a205633
0000d0  2e312e32
0000d4  0a0d00  
0000d7  00                DCB      0
                  |L1.216|
0000d8  2a200a0d          DCB      "* \n\r",0
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L1.224|
0000e0  2a20436f          DCB      "* Copyright ourstm.5d6d.com \r\n",0
0000e4  70797269
0000e8  67687420
0000ec  6f757273
0000f0  746d2e35
0000f4  6436642e
0000f8  636f6d20
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L1.256|
000100  2a205151          DCB      "* QQ    : 9191274 \r\n",0
000104  20202020
000108  3a203931
00010c  39313237
000110  34200d0a
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L1.280|
000118  2a20456d          DCB      "* Email : sun68@qq.com \r\n",0
00011c  61696c20
000120  3a207375
000124  6e363840
000128  71712e63
00012c  6f6d200d
000130  0a00    
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;49     */
;;;50     void USART_Configuration(void)
000000  b500              PUSH     {lr}
;;;51     {
000002  b085              SUB      sp,sp,#0x14
;;;52     	GPIO_InitTypeDef GPIO_InitStructure;
;;;53     	USART_InitTypeDef USART_InitStructure;
;;;54     
;;;55     	/* 第1步：打开GPIO和USART部件的时钟 */
;;;56     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;57     	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;58         RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;59         
;;;60     	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;61     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000014  2004              MOVS     r0,#4
000016  f8ad0010          STRH     r0,[sp,#0x10]
;;;62     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001a  2018              MOVS     r0,#0x18
00001c  f88d0013          STRB     r0,[sp,#0x13]
;;;63     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0012          STRB     r0,[sp,#0x12]
;;;64     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  a904              ADD      r1,sp,#0x10
000028  4816              LDR      r0,|L2.132|
00002a  f7fffffe          BL       GPIO_Init
;;;65     
;;;66     	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;67     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;68     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;69     	*/
;;;70     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00002e  2008              MOVS     r0,#8
000030  f8ad0010          STRH     r0,[sp,#0x10]
;;;71     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;72     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003a  a904              ADD      r1,sp,#0x10
00003c  4811              LDR      r0,|L2.132|
00003e  f7fffffe          BL       GPIO_Init
;;;73     	/*  第3步已经做了，因此这步可以不做
;;;74     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;75     	*/
;;;76     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  a904              ADD      r1,sp,#0x10
000044  480f              LDR      r0,|L2.132|
000046  f7fffffe          BL       GPIO_Init
;;;77     
;;;78     
;;;79     	/* 第4步：配置USART参数
;;;80     	    - BaudRate = 115200 baud
;;;81     	    - Word Length = 8 Bits
;;;82     	    - One Stop Bit
;;;83     	    - No parity
;;;84     	    - Hardware flow control disabled (RTS and CTS signals)
;;;85     	    - Receive and transmit enabled
;;;86     	*/
;;;87     	USART_InitStructure.USART_BaudRate = 115200;
00004a  f44f30e1          MOV      r0,#0x1c200
00004e  9000              STR      r0,[sp,#0]
;;;88     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000050  2000              MOVS     r0,#0
000052  f8ad0004          STRH     r0,[sp,#4]
;;;89     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000056  f8ad0006          STRH     r0,[sp,#6]
;;;90     	USART_InitStructure.USART_Parity = USART_Parity_No;
00005a  f8ad0008          STRH     r0,[sp,#8]
;;;91     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005e  f8ad000c          STRH     r0,[sp,#0xc]
;;;92     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000062  200c              MOVS     r0,#0xc
000064  f8ad000a          STRH     r0,[sp,#0xa]
;;;93     	USART_Init(USART2, &USART_InitStructure);
000068  4669              MOV      r1,sp
00006a  4807              LDR      r0,|L2.136|
00006c  f7fffffe          BL       USART_Init
;;;94     
;;;95     	/* 第5步：使能 USART， 配置完毕 */
;;;96     	USART_Cmd(USART2, ENABLE);
000070  2101              MOVS     r1,#1
000072  4805              LDR      r0,|L2.136|
000074  f7fffffe          BL       USART_Cmd
;;;97     
;;;98     	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;99     		如下语句解决第1个字节无法正确发送出去的问题 */
;;;100    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送外城标志，Transmission Complete flag */
000078  2140              MOVS     r1,#0x40
00007a  4803              LDR      r0,|L2.136|
00007c  f7fffffe          BL       USART_ClearFlag
;;;101    }
000080  b005              ADD      sp,sp,#0x14
000082  bd00              POP      {pc}
;;;102    
                          ENDP

                  |L2.132|
                          DCD      0x40010800
                  |L2.136|
                          DCD      0x40004400

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;129    */
;;;130    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;131    {
000002  4604              MOV      r4,r0
;;;132    	/* 等待串口1输入数据 */
;;;133    	while (USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET)
000004  bf00              NOP      
                  |L3.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L3.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L3.6|
;;;134    	{}
;;;135    
;;;136    	return (int)USART_ReceiveData(USART2);
000012  4802              LDR      r0,|L3.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;137    }
000018  bd10              POP      {r4,pc}
;;;138    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40004400

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;109    */
;;;110    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;112    	/* Place your implementation of fputc here */
;;;113    	/* e.g. write a character to the USART */
;;;114    	USART_SendData(USART2, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L4.32|
00000a  f7fffffe          BL       USART_SendData
;;;115    
;;;116    	/* Loop until the end of transmission */
;;;117    	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L4.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L4.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L4.16|
;;;118    	{}
;;;119    
;;;120    	return ch;
00001c  4620              MOV      r0,r4
;;;121    }
00001e  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP

                  |L4.32|
                          DCD      0x40004400
