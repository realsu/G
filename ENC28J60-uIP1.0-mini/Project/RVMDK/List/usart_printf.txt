; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usart_printf.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\usart_printf.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -I..\..\Source\inc -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\usart_printf.crf ..\..\Source\src\usart_printf.c]
                          THUMB

                          AREA ||i.COM_GIIMBot_DRV_Mode_Choice||, CODE, READONLY, ALIGN=1

                  COM_GIIMBot_DRV_Mode_Choice PROC
;;;393    
;;;394    void COM_GIIMBot_DRV_Mode_Choice(unsigned char UARTx, unsigned char ModeChoice)
000000  b538              PUSH     {r3-r5,lr}
;;;395    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;396    	
;;;397    		u8 data[4];
;;;398    		//数据地址A1
;;;399    		data[0] = ModeChoiceAddress; 													
000006  2002              MOVS     r0,#2
000008  f88d0000          STRB     r0,[sp,#0]
;;;400    		//数据高8位
;;;401    		data[1] = 0x00; 													
00000c  2000              MOVS     r0,#0
00000e  f88d0001          STRB     r0,[sp,#1]
;;;402    		//数据底8位
;;;403    		data[2] = ModeChoice;	
000012  f88d5002          STRB     r5,[sp,#2]
;;;404    		//数据校验和(A1+A2+A3)
;;;405    		data[3] = data[0] + data[1] + data[2];
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  f89d1001          LDRB     r1,[sp,#1]
00001e  4408              ADD      r0,r0,r1
000020  f89d1002          LDRB     r1,[sp,#2]
000024  4408              ADD      r0,r0,r1
000026  b2c0              UXTB     r0,r0
000028  f88d0003          STRB     r0,[sp,#3]
;;;406    		if(UARTx == 1)
00002c  2c01              CMP      r4,#1
00002e  d104              BNE      |L1.58|
;;;407    		{
;;;408    			Uart1ASendStr(data,4);
000030  2104              MOVS     r1,#4
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       Uart1ASendStr
000038  e00e              B        |L1.88|
                  |L1.58|
;;;409    		}
;;;410    		else if (UARTx == 2)
00003a  2c02              CMP      r4,#2
00003c  d104              BNE      |L1.72|
;;;411    		{	
;;;412    			Uart2ASendStr(data,4);
00003e  2104              MOVS     r1,#4
000040  4668              MOV      r0,sp
000042  f7fffffe          BL       Uart2ASendStr
000046  e007              B        |L1.88|
                  |L1.72|
;;;413    		}
;;;414    		else
;;;415    		{
;;;416    			Uart1ASendStr(data,4);
000048  2104              MOVS     r1,#4
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       Uart1ASendStr
;;;417    			Uart2ASendStr(data,4);
000050  2104              MOVS     r1,#4
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       Uart2ASendStr
                  |L1.88|
;;;418    		}
;;;419    }
000058  bd38              POP      {r3-r5,pc}
;;;420    
                          ENDP


                          AREA ||i.COM_GIIMBot_DRV_Motor_Mode||, CODE, READONLY, ALIGN=1

                  COM_GIIMBot_DRV_Motor_Mode PROC
;;;366    
;;;367    void COM_GIIMBot_DRV_Motor_Mode(unsigned char UARTx, unsigned char MotorOnOrOff)
000000  b538              PUSH     {r3-r5,lr}
;;;368    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;369    		u8 data[4];
;;;370    	//数据地址A1
;;;371    		data[0] = 0x00; 													
000006  2000              MOVS     r0,#0
000008  f88d0000          STRB     r0,[sp,#0]
;;;372    	//数据高8位
;;;373    		data[1] = 0x00; 													
00000c  f88d0001          STRB     r0,[sp,#1]
;;;374    	//数据底8位
;;;375    		data[2] = MotorOnOrOff;										
000010  f88d5002          STRB     r5,[sp,#2]
;;;376    	//数据校验和(A1+A2+A3)
;;;377    		data[3] = data[0] + data[1] + data[2];
000014  f89d0000          LDRB     r0,[sp,#0]
000018  f89d1001          LDRB     r1,[sp,#1]
00001c  4408              ADD      r0,r0,r1
00001e  f89d1002          LDRB     r1,[sp,#2]
000022  4408              ADD      r0,r0,r1
000024  b2c0              UXTB     r0,r0
000026  f88d0003          STRB     r0,[sp,#3]
;;;378    	
;;;379    		if(UARTx == 1)
00002a  2c01              CMP      r4,#1
00002c  d104              BNE      |L2.56|
;;;380    		{
;;;381    			Uart1ASendStr(data,4);
00002e  2104              MOVS     r1,#4
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       Uart1ASendStr
000036  e00e              B        |L2.86|
                  |L2.56|
;;;382    		}
;;;383    		else if (UARTx == 2)
000038  2c02              CMP      r4,#2
00003a  d104              BNE      |L2.70|
;;;384    		{	
;;;385    			Uart2ASendStr(data,4);
00003c  2104              MOVS     r1,#4
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       Uart2ASendStr
000044  e007              B        |L2.86|
                  |L2.70|
;;;386    		}
;;;387    		else
;;;388    		{
;;;389    			Uart1ASendStr(data,4);
000046  2104              MOVS     r1,#4
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       Uart1ASendStr
;;;390    			Uart2ASendStr(data,4);
00004e  2104              MOVS     r1,#4
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       Uart2ASendStr
                  |L2.86|
;;;391    		}
;;;392    }
000056  bd38              POP      {r3-r5,pc}
;;;393    
                          ENDP


                          AREA ||i.COM_GIIMBot_DRV_Position_Mode||, CODE, READONLY, ALIGN=1

                  COM_GIIMBot_DRV_Position_Mode PROC
;;;427    
;;;428    void COM_GIIMBot_DRV_Position_Mode(unsigned char UARTx, short Temp_PWM, int Temp_Position)
000000  b5fe              PUSH     {r1-r7,lr}
;;;429    {
000002  4605              MOV      r5,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;430    		u8 data_h[4];
;;;431    		u8 data_l[4];
;;;432    		u8 data_vel_limit[4];
;;;433    		short PWM;
;;;434    		PWM = Temp_PWM*16384/6000;
000008  03b8              LSLS     r0,r7,#14
00000a  f2417170          MOV      r1,#0x1770
00000e  fb90f0f1          SDIV     r0,r0,r1
000012  b206              SXTH     r6,r0
;;;435    		//数据地址A1
;;;436    		data_h[0] = PosModSetHighAddress; 													
000014  2050              MOVS     r0,#0x50
000016  f88d0008          STRB     r0,[sp,#8]
;;;437    		//数据高1-8位(number>>8)&0XFF; 
;;;438    		data_h[1] = (u8)(Temp_Position >> 24);													
00001a  0e20              LSRS     r0,r4,#24
00001c  f88d0009          STRB     r0,[sp,#9]
;;;439    		//数据高2-8位
;;;440    		data_h[2] = (u8)(Temp_Position >> 16);	
000020  0c20              LSRS     r0,r4,#16
000022  f88d000a          STRB     r0,[sp,#0xa]
;;;441    		//数据校验和(A1+A2+A3)
;;;442    		data_h[3] = data_h[0] + data_h[1] + data_h[2];
000026  f89d0008          LDRB     r0,[sp,#8]
00002a  f89d1009          LDRB     r1,[sp,#9]
00002e  4408              ADD      r0,r0,r1
000030  f89d100a          LDRB     r1,[sp,#0xa]
000034  4408              ADD      r0,r0,r1
000036  b2c0              UXTB     r0,r0
000038  f88d000b          STRB     r0,[sp,#0xb]
;;;443    		//数据地址A1
;;;444    		data_l[0] = PosModSetLowAddress; 													
00003c  2005              MOVS     r0,#5
00003e  f88d0004          STRB     r0,[sp,#4]
;;;445    		//数据高1-8位(number>>8)&0XFF; 
;;;446    		data_l[1] = (u8)(Temp_Position >> 8);													
000042  0a20              LSRS     r0,r4,#8
000044  f88d0005          STRB     r0,[sp,#5]
;;;447    		//数据高2-8位
;;;448    		data_l[2] = (u8)Temp_Position;
000048  b2e0              UXTB     r0,r4
00004a  f88d0006          STRB     r0,[sp,#6]
;;;449    		//数据校验和(A1+A2+A3)
;;;450    		data_l[3] = data_l[0] + data_l[1] + data_l[2];
00004e  f89d0004          LDRB     r0,[sp,#4]
000052  f89d1005          LDRB     r1,[sp,#5]
000056  4408              ADD      r0,r0,r1
000058  f89d1006          LDRB     r1,[sp,#6]
00005c  4408              ADD      r0,r0,r1
00005e  b2c0              UXTB     r0,r0
000060  f88d0007          STRB     r0,[sp,#7]
;;;451    	
;;;452    		data_vel_limit[0] = PosModSetVelLimitAddress;
000064  201d              MOVS     r0,#0x1d
000066  f88d0000          STRB     r0,[sp,#0]
;;;453    		data_vel_limit[1] = (u8)(PWM >> 8);	
00006a  0a30              LSRS     r0,r6,#8
00006c  f88d0001          STRB     r0,[sp,#1]
;;;454    		data_vel_limit[2] = (u8)PWM;	
000070  b2f0              UXTB     r0,r6
000072  f88d0002          STRB     r0,[sp,#2]
;;;455    		data_vel_limit[3] = data_vel_limit[0] + data_vel_limit[1] + data_vel_limit[2];
000076  f89d0000          LDRB     r0,[sp,#0]
00007a  f89d1001          LDRB     r1,[sp,#1]
00007e  4408              ADD      r0,r0,r1
000080  f89d1002          LDRB     r1,[sp,#2]
000084  4408              ADD      r0,r0,r1
000086  b2c0              UXTB     r0,r0
000088  f88d0003          STRB     r0,[sp,#3]
;;;456    	if( UARTx != 0)
00008c  2d00              CMP      r5,#0
00008e  d03b              BEQ      |L3.264|
;;;457    		{
;;;458    		switch(UARTx)
000090  2d01              CMP      r5,#1
000092  d004              BEQ      |L3.158|
000094  2d02              CMP      r5,#2
000096  d00f              BEQ      |L3.184|
000098  2d03              CMP      r5,#3
00009a  d133              BNE      |L3.260|
00009c  e019              B        |L3.210|
                  |L3.158|
;;;459    			{
;;;460    				case UART1:  	
;;;461    					Uart1ASendStr(data_h,4);
00009e  2104              MOVS     r1,#4
0000a0  a802              ADD      r0,sp,#8
0000a2  f7fffffe          BL       Uart1ASendStr
;;;462    					Uart1ASendStr(data_l,4);
0000a6  2104              MOVS     r1,#4
0000a8  a801              ADD      r0,sp,#4
0000aa  f7fffffe          BL       Uart1ASendStr
;;;463    					Uart1ASendStr(data_vel_limit,4); 
0000ae  2104              MOVS     r1,#4
0000b0  4668              MOV      r0,sp
0000b2  f7fffffe          BL       Uart1ASendStr
;;;464    					break;
0000b6  e026              B        |L3.262|
                  |L3.184|
;;;465    				case UART2:  	
;;;466    					Uart2ASendStr(data_h,4);
0000b8  2104              MOVS     r1,#4
0000ba  a802              ADD      r0,sp,#8
0000bc  f7fffffe          BL       Uart2ASendStr
;;;467    					Uart2ASendStr(data_l,4);	
0000c0  2104              MOVS     r1,#4
0000c2  a801              ADD      r0,sp,#4
0000c4  f7fffffe          BL       Uart2ASendStr
;;;468    					Uart2ASendStr(data_vel_limit,4);				
0000c8  2104              MOVS     r1,#4
0000ca  4668              MOV      r0,sp
0000cc  f7fffffe          BL       Uart2ASendStr
;;;469    					break;
0000d0  e019              B        |L3.262|
                  |L3.210|
;;;470    				case UART1_2:  	
;;;471    					Uart1ASendStr(data_h,4);
0000d2  2104              MOVS     r1,#4
0000d4  a802              ADD      r0,sp,#8
0000d6  f7fffffe          BL       Uart1ASendStr
;;;472    					Uart2ASendStr(data_h,4);
0000da  2104              MOVS     r1,#4
0000dc  a802              ADD      r0,sp,#8
0000de  f7fffffe          BL       Uart2ASendStr
;;;473    					Uart1ASendStr(data_l,4);
0000e2  2104              MOVS     r1,#4
0000e4  a801              ADD      r0,sp,#4
0000e6  f7fffffe          BL       Uart1ASendStr
;;;474    					Uart2ASendStr(data_l,4); 	
0000ea  2104              MOVS     r1,#4
0000ec  a801              ADD      r0,sp,#4
0000ee  f7fffffe          BL       Uart2ASendStr
;;;475    					Uart1ASendStr(data_vel_limit,4);
0000f2  2104              MOVS     r1,#4
0000f4  4668              MOV      r0,sp
0000f6  f7fffffe          BL       Uart1ASendStr
;;;476    					Uart2ASendStr(data_vel_limit,4);				
0000fa  2104              MOVS     r1,#4
0000fc  4668              MOV      r0,sp
0000fe  f7fffffe          BL       Uart2ASendStr
;;;477    					break;
000102  e000              B        |L3.262|
                  |L3.260|
;;;478    				default:  
;;;479    					break; 	
000104  bf00              NOP      
                  |L3.262|
000106  bf00              NOP                            ;464
                  |L3.264|
;;;480    			}
;;;481    		}
;;;482    }
000108  bdfe              POP      {r1-r7,pc}
;;;483    
                          ENDP


                          AREA ||i.PrintfLogo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  PrintfLogo PROC
;;;27     */
;;;28     void PrintfLogo(char *strName, char *strDate)
000000  b570              PUSH     {r4-r6,lr}
;;;29     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;30     	printf("*************************************************************\n\r");
000006  a00f              ADR      r0,|L4.68|
000008  f7fffffe          BL       __2printf
;;;31     	printf("* Example Name : %s\r\n", strName);
00000c  4621              MOV      r1,r4
00000e  a01d              ADR      r0,|L4.132|
000010  f7fffffe          BL       __2printf
;;;32     	printf("* Update Date  : %s\r\n", strDate);
000014  4629              MOV      r1,r5
000016  a021              ADR      r0,|L4.156|
000018  f7fffffe          BL       __2printf
;;;33     	printf("* StdPeriph_Lib Version : V3.1.2\n\r");
00001c  a025              ADR      r0,|L4.180|
00001e  f7fffffe          BL       __2printf
;;;34     	printf("* \n\r");
000022  a02d              ADR      r0,|L4.216|
000024  f7fffffe          BL       __2printf
;;;35     	printf("* Copyright ourstm.5d6d.com \r\n");
000028  a02d              ADR      r0,|L4.224|
00002a  f7fffffe          BL       __2printf
;;;36     	printf("* QQ    : 9191274 \r\n");
00002e  a034              ADR      r0,|L4.256|
000030  f7fffffe          BL       __2printf
;;;37     	printf("* Email : sun68@qq.com \r\n");
000034  a038              ADR      r0,|L4.280|
000036  f7fffffe          BL       __2printf
;;;38     	printf("*************************************************************\n\r");
00003a  a002              ADR      r0,|L4.68|
00003c  f7fffffe          BL       __2printf
;;;39     }
000040  bd70              POP      {r4-r6,pc}
;;;40     
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
000044  2a2a2a2a          DCB      "*******************************************************"
000048  2a2a2a2a
00004c  2a2a2a2a
000050  2a2a2a2a
000054  2a2a2a2a
000058  2a2a2a2a
00005c  2a2a2a2a
000060  2a2a2a2a
000064  2a2a2a2a
000068  2a2a2a2a
00006c  2a2a2a2a
000070  2a2a2a2a
000074  2a2a2a2a
000078  2a2a2a  
00007b  2a2a2a2a          DCB      "******\n\r",0
00007f  2a2a0a0d
000083  00      
                  |L4.132|
000084  2a204578          DCB      "* Example Name : %s\r\n",0
000088  616d706c
00008c  65204e61
000090  6d65203a
000094  2025730d
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L4.156|
00009c  2a205570          DCB      "* Update Date  : %s\r\n",0
0000a0  64617465
0000a4  20446174
0000a8  6520203a
0000ac  2025730d
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L4.180|
0000b4  2a205374          DCB      "* StdPeriph_Lib Version : V3.1.2\n\r",0
0000b8  64506572
0000bc  6970685f
0000c0  4c696220
0000c4  56657273
0000c8  696f6e20
0000cc  3a205633
0000d0  2e312e32
0000d4  0a0d00  
0000d7  00                DCB      0
                  |L4.216|
0000d8  2a200a0d          DCB      "* \n\r",0
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L4.224|
0000e0  2a20436f          DCB      "* Copyright ourstm.5d6d.com \r\n",0
0000e4  70797269
0000e8  67687420
0000ec  6f757273
0000f0  746d2e35
0000f4  6436642e
0000f8  636f6d20
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L4.256|
000100  2a205151          DCB      "* QQ    : 9191274 \r\n",0
000104  20202020
000108  3a203931
00010c  39313237
000110  34200d0a
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L4.280|
000118  2a20456d          DCB      "* Email : sun68@qq.com \r\n",0
00011c  61696c20
000120  3a207375
000124  6e363840
000128  71712e63
00012c  6f6d200d
000130  0a00    
000132  00                DCB      0
000133  00                DCB      0

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  USART1_IRQHandler PROC
;;;484    #if EN_USART1_RX   //如果使能了接收
;;;485    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b510              PUSH     {r4,lr}
;;;486    	{
;;;487    	u8 Res;
;;;488    #ifdef OS_TICKS_PER_SEC	 	//如果时钟节拍数定义了,说明要使用ucosII了.
;;;489    	OSIntEnter();    
;;;490    #endif
;;;491        if(USART_GetITStatus(USART1,USART_IT_RXNE) != RESET) 
000002  f2405125          MOV      r1,#0x525
000006  4816              LDR      r0,|L5.96|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b310              CBZ      r0,|L5.84|
;;;492        {
;;;493    		USART_ClearITPendingBit(USART1,USART_IT_RXNE); 
00000e  f2405125          MOV      r1,#0x525
000012  4813              LDR      r0,|L5.96|
000014  f7fffffe          BL       USART_ClearITPendingBit
;;;494            USART_RX_BUF[USART_RX_STA]=USART_ReceiveData(USART1);
000018  4811              LDR      r0,|L5.96|
00001a  f7fffffe          BL       USART_ReceiveData
00001e  4911              LDR      r1,|L5.100|
000020  4a11              LDR      r2,|L5.104|
000022  8812              LDRH     r2,[r2,#0]  ; USART_RX_STA
000024  5488              STRB     r0,[r1,r2]
;;;495    		USART_RX_STA++; 
000026  4810              LDR      r0,|L5.104|
000028  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00002a  1c40              ADDS     r0,r0,#1
00002c  490e              LDR      r1,|L5.104|
00002e  8008              STRH     r0,[r1,#0]
;;;496    		if(USART_RX_BUF[0] == 0x80 || USART_RX_STA == USART_REC_LEN)    
000030  480c              LDR      r0,|L5.100|
000032  7800              LDRB     r0,[r0,#0]  ; USART_RX_BUF
000034  2880              CMP      r0,#0x80
000036  d003              BEQ      |L5.64|
000038  4608              MOV      r0,r1
00003a  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00003c  28c8              CMP      r0,#0xc8
00003e  d10d              BNE      |L5.92|
                  |L5.64|
;;;497    		{
;;;498    			if(USART_RX_BUF[1] == 0x00)                     
000040  4808              LDR      r0,|L5.100|
000042  7840              LDRB     r0,[r0,#1]  ; USART_RX_BUF
000044  b938              CBNZ     r0,|L5.86|
;;;499    			{
;;;500    				printf("%s\r\n",USART_RX_BUF);
000046  4907              LDR      r1,|L5.100|
000048  a008              ADR      r0,|L5.108|
00004a  f7fffffe          BL       __2printf
;;;501    				USART_RX_STA=0;                                   
00004e  2000              MOVS     r0,#0
000050  4905              LDR      r1,|L5.104|
000052  8008              STRH     r0,[r1,#0]
                  |L5.84|
000054  e002              B        |L5.92|
                  |L5.86|
;;;502    			} 
;;;503    			else
;;;504    			{
;;;505    				USART_RX_STA=0;  
000056  2000              MOVS     r0,#0
000058  4903              LDR      r1,|L5.104|
00005a  8008              STRH     r0,[r1,#0]
                  |L5.92|
;;;506    			}
;;;507    		}
;;;508    	}
;;;509    //	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
;;;510    //		{
;;;511    //		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
;;;512    //		//printf("Res =USART_ReceiveData(USART1);\n\r");
;;;513    //		if((USART_RX_STA&0x8000)==0)//接收未完成
;;;514    //			{
;;;515    //                //printf("if((USART_RX_STA&0x8000)==0)\n\r");
;;;516    //			if(USART_RX_STA&0x4000)//接收到了0x0d
;;;517    //				{
;;;518    //                    //printf("if(USART_RX_STA&0x4000\n\r");
;;;519    //				if(Res!=0x0a)
;;;520    //                {
;;;521    //                    USART_RX_STA=0;//接收错误,重新开始
;;;522    //                    //printf("if(Res!=0x0a)\n\r");
;;;523    //                }
;;;524    //				else USART_RX_STA|=0x8000;	//接收完成了
;;;525    //                    //printf("else USART_RX_STA|=0x8000;	\n\r");
;;;526    //				}
;;;527    //			else //还没收到0X0D
;;;528    //				{	//printf("else no 0x0D\n\r");
;;;529    //				if(Res==0x0d)
;;;530    //                {
;;;531    //                    USART_RX_STA|=0x4000;
;;;532    //                    //printf("if(Res==0x0d)\n\r");
;;;533    //                }
;;;534    //				else
;;;535    //					{
;;;536    //					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
;;;537    //                   // printf("USART_RX_BUF[USART_RX_STA&0X3FFF]=Res\n\r");
;;;538    //					USART_RX_STA++;
;;;539    //                    printf("%x",USART_RX_STA++);
;;;540    //                    //printf("Res = %d",Res);
;;;541    //					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
;;;542    //					}		 
;;;543    //				}
;;;544    //			}   		 
;;;545    //     } 
;;;546        
;;;547    #ifdef OS_TICKS_PER_SEC	 	//如果时钟节拍数定义了,说明要使用ucosII了.
;;;548    	OSIntExit();  											 
;;;549    #endif
;;;550    }	 
00005c  bd10              POP      {r4,pc}
;;;551    #endif
                          ENDP

00005e  0000              DCW      0x0000
                  |L5.96|
                          DCD      0x40013800
                  |L5.100|
                          DCD      USART_RX_BUF
                  |L5.104|
                          DCD      USART_RX_STA
                  |L5.108|
00006c  25730d0a          DCB      "%s\r\n",0
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.USART1_printf||, CODE, READONLY, ALIGN=1

                  USART1_printf PROC
;;;279     */
;;;280    void USART1_printf(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;281    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;282    	const char *s;
;;;283      int d;   
;;;284      char buf[16];
;;;285    
;;;286      va_list ap;
;;;287      va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;288    
;;;289    	while ( *Data != 0)     // 判断是否到达字符串结束符
00000c  e073              B        |L6.246|
                  |L6.14|
;;;290    	{				                          
;;;291    		if ( *Data == 0x5c )  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L6.80|
;;;292    		{									  
;;;293    			switch ( *++Data )
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L6.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L6.70|
;;;294    			{
;;;295    				case 'r':							          //回车符
;;;296    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;297    					Data ++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;298    					break;
000034  e00b              B        |L6.78|
                  |L6.54|
;;;299    
;;;300    				case 'n':							          //换行符
;;;301    					USART_SendData(USARTx, 0x0a);	
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;302    					Data ++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;303    					break;
000044  e003              B        |L6.78|
                  |L6.70|
;;;304    				
;;;305    				default:
;;;306    					Data ++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;307    				    break;
00004c  bf00              NOP      
                  |L6.78|
00004e  e04b              B        |L6.232|
                  |L6.80|
;;;308    			}			 
;;;309    		}
;;;310    		else if ( *Data == '%')
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L6.218|
;;;311    		{									  //
;;;312    			switch ( *++Data )
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L6.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L6.208|
;;;313    			{				
;;;314    				case 's':										  //字符串
;;;315    					s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;316              for ( ; *s; s++) 
00006e  e00b              B        |L6.136|
                  |L6.112|
;;;317    					{
;;;318    						USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;319    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
000078  bf00              NOP      
                  |L6.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L6.122|
000086  1c64              ADDS     r4,r4,#1              ;316
                  |L6.136|
000088  7820              LDRB     r0,[r4,#0]            ;316
00008a  2800              CMP      r0,#0                 ;316
00008c  d1f0              BNE      |L6.112|
;;;320              }
;;;321    					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;322              break;
000094  e020              B        |L6.216|
                  |L6.150|
;;;323    
;;;324            case 'd':										//十进制
;;;325              d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;326              itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;327              for (s = buf; *s; s++) 
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L6.194|
                  |L6.170|
;;;328    					{
;;;329    						USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;330    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000b2  bf00              NOP      
                  |L6.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L6.180|
0000c0  1c64              ADDS     r4,r4,#1              ;327
                  |L6.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;327
0000c4  2800              CMP      r0,#0                 ;327
0000c6  d1f0              BNE      |L6.170|
;;;331              }
;;;332    					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;333              break;
0000ce  e003              B        |L6.216|
                  |L6.208|
;;;334    				 default:
;;;335    						Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;336    				    break;
0000d6  bf00              NOP      
                  |L6.216|
0000d8  e006              B        |L6.232|
                  |L6.218|
;;;337    			}		 
;;;338    		} /* end of else if */
;;;339    		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L6.232|
;;;340    		while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000e8  bf00              NOP      
                  |L6.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L6.234|
                  |L6.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;289
0000f8  7800              LDRB     r0,[r0,#0]            ;289
0000fa  2800              CMP      r0,#0                 ;289
0000fc  d187              BNE      |L6.14|
;;;341    	}
;;;342    }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;343    
                          ENDP


                          AREA ||i.USART2_Configuration||, CODE, READONLY, ALIGN=2

                  USART2_Configuration PROC
;;;52     */
;;;53     void USART2_Configuration(void)
000000  b500              PUSH     {lr}
;;;54     {
000002  b085              SUB      sp,sp,#0x14
;;;55     	GPIO_InitTypeDef GPIO_InitStructure;
;;;56     	USART_InitTypeDef USART_InitStructure;
;;;57     
;;;58     	/* 第1步：打开GPIO和USART部件的时钟 */
;;;59     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;60     	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;61         RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;62         
;;;63     	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;64     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000014  2004              MOVS     r0,#4
000016  f8ad0010          STRH     r0,[sp,#0x10]
;;;65     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001a  2018              MOVS     r0,#0x18
00001c  f88d0013          STRB     r0,[sp,#0x13]
;;;66     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000020  2003              MOVS     r0,#3
000022  f88d0012          STRB     r0,[sp,#0x12]
;;;67     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  a904              ADD      r1,sp,#0x10
000028  4816              LDR      r0,|L7.132|
00002a  f7fffffe          BL       GPIO_Init
;;;68     
;;;69     	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;70     		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;71     		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;72     	*/
;;;73     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00002e  2008              MOVS     r0,#8
000030  f8ad0010          STRH     r0,[sp,#0x10]
;;;74     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;75     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003a  a904              ADD      r1,sp,#0x10
00003c  4811              LDR      r0,|L7.132|
00003e  f7fffffe          BL       GPIO_Init
;;;76     	/*  第3步已经做了，因此这步可以不做
;;;77     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;78     	*/
;;;79     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  a904              ADD      r1,sp,#0x10
000044  480f              LDR      r0,|L7.132|
000046  f7fffffe          BL       GPIO_Init
;;;80     
;;;81     
;;;82     	/* 第4步：配置USART参数
;;;83     	    - BaudRate = 115200 baud
;;;84     	    - Word Length = 8 Bits
;;;85     	    - One Stop Bit
;;;86     	    - No parity
;;;87     	    - Hardware flow control disabled (RTS and CTS signals)
;;;88     	    - Receive and transmit enabled
;;;89     	*/
;;;90     	USART_InitStructure.USART_BaudRate = 57600;
00004a  f44f4061          MOV      r0,#0xe100
00004e  9000              STR      r0,[sp,#0]
;;;91     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000050  2000              MOVS     r0,#0
000052  f8ad0004          STRH     r0,[sp,#4]
;;;92     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000056  f8ad0006          STRH     r0,[sp,#6]
;;;93     	USART_InitStructure.USART_Parity = USART_Parity_No;
00005a  f8ad0008          STRH     r0,[sp,#8]
;;;94     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005e  f8ad000c          STRH     r0,[sp,#0xc]
;;;95     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000062  200c              MOVS     r0,#0xc
000064  f8ad000a          STRH     r0,[sp,#0xa]
;;;96     	USART_Init(USART2, &USART_InitStructure);
000068  4669              MOV      r1,sp
00006a  4807              LDR      r0,|L7.136|
00006c  f7fffffe          BL       USART_Init
;;;97     
;;;98     	/* 第5步：使能 USART， 配置完毕 */
;;;99     	USART_Cmd(USART2, ENABLE);
000070  2101              MOVS     r1,#1
000072  4805              LDR      r0,|L7.136|
000074  f7fffffe          BL       USART_Cmd
;;;100    
;;;101    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;102    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;103    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送外城标志，Transmission Complete flag */
000078  2140              MOVS     r1,#0x40
00007a  4803              LDR      r0,|L7.136|
00007c  f7fffffe          BL       USART_ClearFlag
;;;104    }
000080  b005              ADD      sp,sp,#0x14
000082  bd00              POP      {pc}
;;;105    
                          ENDP

                  |L7.132|
                          DCD      0x40010800
                  |L7.136|
                          DCD      0x40004400

                          AREA ||i.Uart1ASendStr||, CODE, READONLY, ALIGN=2

                  Uart1ASendStr PROC
;;;344    
;;;345    void Uart1ASendStr (u8 *pucStr, u8 ulNum) 
000000  b570              PUSH     {r4-r6,lr}
;;;346    { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;347    	u8 i; 
;;;348    for(i = 0;i<ulNum;i++) 
000006  2600              MOVS     r6,#0
000008  e00d              B        |L8.38|
                  |L8.10|
;;;349    { 
;;;350    	     USART_SendData(USART1,*pucStr++);
00000a  f8141b01          LDRB     r1,[r4],#1
00000e  4807              LDR      r0,|L8.44|
000010  f7fffffe          BL       USART_SendData
;;;351    	while( USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET );  
000014  bf00              NOP      
                  |L8.22|
000016  2180              MOVS     r1,#0x80
000018  4804              LDR      r0,|L8.44|
00001a  f7fffffe          BL       USART_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L8.22|
000022  1c70              ADDS     r0,r6,#1              ;348
000024  b2c6              UXTB     r6,r0                 ;348
                  |L8.38|
000026  42ae              CMP      r6,r5                 ;348
000028  dbef              BLT      |L8.10|
;;;352    
;;;353    }  
;;;354    } 
00002a  bd70              POP      {r4-r6,pc}
;;;355    
                          ENDP

                  |L8.44|
                          DCD      0x40013800

                          AREA ||i.Uart2ASendStr||, CODE, READONLY, ALIGN=2

                  Uart2ASendStr PROC
;;;355    
;;;356    void Uart2ASendStr (u8 *pucStr, u8 ulNum) 
000000  b570              PUSH     {r4-r6,lr}
;;;357    { 
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;358    	u8 i; 
;;;359    for(i = 0;i<ulNum;i++) 
000006  2600              MOVS     r6,#0
000008  e00d              B        |L9.38|
                  |L9.10|
;;;360    { 
;;;361    	USART_SendData(USART2,*pucStr++);
00000a  f8141b01          LDRB     r1,[r4],#1
00000e  4807              LDR      r0,|L9.44|
000010  f7fffffe          BL       USART_SendData
;;;362    	while( USART_GetFlagStatus(USART2,USART_FLAG_TXE) == RESET );
000014  bf00              NOP      
                  |L9.22|
000016  2180              MOVS     r1,#0x80
000018  4804              LDR      r0,|L9.44|
00001a  f7fffffe          BL       USART_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d0f9              BEQ      |L9.22|
000022  1c70              ADDS     r0,r6,#1              ;359
000024  b2c6              UXTB     r6,r0                 ;359
                  |L9.38|
000026  42ae              CMP      r6,r5                 ;359
000028  dbef              BLT      |L9.10|
;;;363         
;;;364    }  
;;;365    }
00002a  bd70              POP      {r4-r6,pc}
;;;366    
                          ENDP

                  |L9.44|
                          DCD      0x40004400

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;132    */
;;;133    int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4604              MOV      r4,r0
;;;135    	/* 等待串口1输入数据 */
;;;136    	while (USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET)
000004  bf00              NOP      
                  |L10.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L10.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L10.6|
;;;137    	{}
;;;138    
;;;139    	return (int)USART_ReceiveData(USART2);
000012  4802              LDR      r0,|L10.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;140    }
000018  bd10              POP      {r4,pc}
;;;141    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40004400

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;112    */
;;;113    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;114    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;115    	/* Place your implementation of fputc here */
;;;116    	/* e.g. write a character to the USART */
;;;117    	USART_SendData(USART2, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L11.32|
00000a  f7fffffe          BL       USART_SendData
;;;118    
;;;119    	/* Loop until the end of transmission */
;;;120    	while (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L11.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L11.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L11.16|
;;;121    	{}
;;;122    
;;;123    	return ch;
00001c  4620              MOV      r0,r4
;;;124    }
00001e  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP

                  |L11.32|
                          DCD      0x40004400

                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;218     */
;;;219    static char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;220    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;221        int     i, d;
;;;222        int     flag = 0;
000008  2700              MOVS     r7,#0
;;;223        char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;224    
;;;225        /* This implementation only works for decimal numbers. */
;;;226        if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L12.24|
;;;227        {
;;;228            *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;229            return string;
000014  4628              MOV      r0,r5
                  |L12.22|
;;;230        }
;;;231    
;;;232        if (!value)
;;;233        {
;;;234            *ptr++ = 0x30;
;;;235            *ptr = 0;
;;;236            return string;
;;;237        }
;;;238    
;;;239        /* if this is a negative value insert the minus sign. */
;;;240        if (value < 0)
;;;241        {
;;;242            *ptr++ = '-';
;;;243    
;;;244            /* Make the value positive. */
;;;245            value *= -1;
;;;246        }
;;;247    
;;;248        for (i = 10000; i > 0; i /= 10)
;;;249        {
;;;250            d = value / i;
;;;251    
;;;252            if (d || flag)
;;;253            {
;;;254                *ptr++ = (char)(d + 0x30);
;;;255                value -= (d * i);
;;;256                flag = 1;
;;;257            }
;;;258        }
;;;259    
;;;260        /* Null terminate the string. */
;;;261        *ptr = 0;
;;;262    
;;;263        return string;
;;;264    
;;;265    } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L12.24|
000018  b933              CBNZ     r3,|L12.40|
00001a  2030              MOVS     r0,#0x30              ;234
00001c  f8010b01          STRB     r0,[r1],#1            ;234
000020  2000              MOVS     r0,#0                 ;235
000022  7008              STRB     r0,[r1,#0]            ;235
000024  4628              MOV      r0,r5                 ;236
000026  e7f6              B        |L12.22|
                  |L12.40|
000028  2b00              CMP      r3,#0                 ;240
00002a  da03              BGE      |L12.52|
00002c  202d              MOVS     r0,#0x2d              ;242
00002e  f8010b01          STRB     r0,[r1],#1            ;242
000032  425b              RSBS     r3,r3,#0              ;245
                  |L12.52|
000034  f2427210          MOV      r2,#0x2710            ;248
000038  e00d              B        |L12.86|
                  |L12.58|
00003a  fb93f4f2          SDIV     r4,r3,r2              ;250
00003e  b904              CBNZ     r4,|L12.66|
000040  b137              CBZ      r7,|L12.80|
                  |L12.66|
000042  f1040030          ADD      r0,r4,#0x30           ;254
000046  f8010b01          STRB     r0,[r1],#1            ;254
00004a  fb043312          MLS      r3,r4,r2,r3           ;255
00004e  2701              MOVS     r7,#1                 ;256
                  |L12.80|
000050  200a              MOVS     r0,#0xa               ;248
000052  fb92f2f0          SDIV     r2,r2,r0              ;248
                  |L12.86|
000056  2a00              CMP      r2,#0                 ;248
000058  dcef              BGT      |L12.58|
00005a  2000              MOVS     r0,#0                 ;261
00005c  7008              STRB     r0,[r1,#0]            ;261
00005e  4628              MOV      r0,r5                 ;263
000060  e7d9              B        |L12.22|
;;;266    
                          ENDP


                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;164    //bound:波特率
;;;165    void uart_init(u32 bound){
000000  b510              PUSH     {r4,lr}
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;166        //GPIO端口设置
;;;167        GPIO_InitTypeDef GPIO_InitStructure;
;;;168    	USART_InitTypeDef USART_InitStructure;
;;;169    	NVIC_InitTypeDef NVIC_InitStructure;
;;;170    	 
;;;171    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;172     	USART_DeInit(USART1);  //复位串口1
000010  4823              LDR      r0,|L13.160|
000012  f7fffffe          BL       USART_DeInit
;;;173    	 //USART1_TX   PA.9
;;;174        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0014          STRH     r0,[sp,#0x14]
;;;175        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0016          STRB     r0,[sp,#0x16]
;;;176        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
000024  2018              MOVS     r0,#0x18
000026  f88d0017          STRB     r0,[sp,#0x17]
;;;177        GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化PA9
00002a  a905              ADD      r1,sp,#0x14
00002c  481d              LDR      r0,|L13.164|
00002e  f7fffffe          BL       GPIO_Init
;;;178       
;;;179        //USART1_RX	  PA.10
;;;180        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  f44f6080          MOV      r0,#0x400
000036  f8ad0014          STRH     r0,[sp,#0x14]
;;;181        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
00003a  2004              MOVS     r0,#4
00003c  f88d0017          STRB     r0,[sp,#0x17]
;;;182        GPIO_Init(GPIOA, &GPIO_InitStructure);  //初始化PA10
000040  a905              ADD      r1,sp,#0x14
000042  4818              LDR      r0,|L13.164|
000044  f7fffffe          BL       GPIO_Init
;;;183    
;;;184       //Usart1 NVIC 配置
;;;185    
;;;186        NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000048  2025              MOVS     r0,#0x25
00004a  f88d0000          STRB     r0,[sp,#0]
;;;187    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;//抢占优先级3
00004e  2001              MOVS     r0,#1
000050  f88d0001          STRB     r0,[sp,#1]
;;;188    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		//子优先级3
000054  2000              MOVS     r0,#0
000056  f88d0002          STRB     r0,[sp,#2]
;;;189    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
00005a  2001              MOVS     r0,#1
00005c  f88d0003          STRB     r0,[sp,#3]
;;;190    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
000060  4668              MOV      r0,sp
000062  f7fffffe          BL       NVIC_Init
;;;191      
;;;192       //USART 初始化设置
;;;193    
;;;194    	USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
000066  9401              STR      r4,[sp,#4]
;;;195    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000068  2000              MOVS     r0,#0
00006a  f8ad0008          STRH     r0,[sp,#8]
;;;196    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
00006e  f8ad000a          STRH     r0,[sp,#0xa]
;;;197    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000072  f8ad000c          STRH     r0,[sp,#0xc]
;;;198    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
000076  f8ad0010          STRH     r0,[sp,#0x10]
;;;199    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
00007a  200c              MOVS     r0,#0xc
00007c  f8ad000e          STRH     r0,[sp,#0xe]
;;;200    
;;;201        USART_Init(USART1, &USART_InitStructure); //初始化串口
000080  a901              ADD      r1,sp,#4
000082  4807              LDR      r0,|L13.160|
000084  f7fffffe          BL       USART_Init
;;;202        USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启中断
000088  2201              MOVS     r2,#1
00008a  f2405125          MOV      r1,#0x525
00008e  4804              LDR      r0,|L13.160|
000090  f7fffffe          BL       USART_ITConfig
;;;203        USART_Cmd(USART1, ENABLE);                    //使能串口 
000094  2101              MOVS     r1,#1
000096  4802              LDR      r0,|L13.160|
000098  f7fffffe          BL       USART_Cmd
;;;204    
;;;205    }
00009c  b006              ADD      sp,sp,#0x18
00009e  bd10              POP      {r4,pc}
;;;206    
                          ENDP

                  |L13.160|
                          DCD      0x40013800
                  |L13.164|
                          DCD      0x40010800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200
                  USART2_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000
                  USART2_RX_STA
000002  0000              DCW      0x0000
