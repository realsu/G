; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uip-fw.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\uip-fw.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\uip-fw.crf ..\..\Libraries\uIP-1.0\uip\uip-fw.c]
                          THUMB

                          AREA ||i.find_netif||, CODE, READONLY, ALIGN=2

                  find_netif PROC
;;;323    static struct uip_fw_netif *
;;;324    find_netif(void)
000000  b510              PUSH     {r4,lr}
;;;325    {
;;;326      struct uip_fw_netif *netif;
;;;327    
;;;328      /* Walk through every network interface to check for a match. */
;;;329      for(netif = netifs; netif != NULL; netif = netif->next) {
000002  4809              LDR      r0,|L1.40|
000004  6804              LDR      r4,[r0,#0]  ; netifs
000006  e009              B        |L1.28|
                  |L1.8|
;;;330        if(ipaddr_maskcmp(BUF->destipaddr, netif->ipaddr,
000008  f1040208          ADD      r2,r4,#8
00000c  1d21              ADDS     r1,r4,#4
00000e  4807              LDR      r0,|L1.44|
000010  f7fffffe          BL       ipaddr_maskcmp
000014  b108              CBZ      r0,|L1.26|
;;;331    		      netif->netmask)) {
;;;332          /* If there was a match, we break the loop. */
;;;333          return netif;
000016  4620              MOV      r0,r4
                  |L1.24|
;;;334        }
;;;335      }
;;;336    
;;;337      /* If no matching netif was found, we use default netif. */
;;;338      return defaultnetif;
;;;339    }
000018  bd10              POP      {r4,pc}
                  |L1.26|
00001a  6824              LDR      r4,[r4,#0]            ;329
                  |L1.28|
00001c  2c00              CMP      r4,#0                 ;329
00001e  d1f3              BNE      |L1.8|
000020  4803              LDR      r0,|L1.48|
000022  6800              LDR      r0,[r0,#0]            ;338  ; defaultnetif
000024  e7f8              B        |L1.24|
;;;340    /*------------------------------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      netifs
                  |L1.44|
                          DCD      uip_buf+0x1e
                  |L1.48|
                          DCD      defaultnetif

                          AREA ||i.fwcache_register||, CODE, READONLY, ALIGN=2

                  fwcache_register PROC
;;;281    static void
;;;282    fwcache_register(void)
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284      struct fwcache_entry *fw;
;;;285      int i, oldest;
;;;286    
;;;287      oldest = FW_TIME;
000002  2214              MOVS     r2,#0x14
;;;288      fw = NULL;
000004  2000              MOVS     r0,#0
;;;289    
;;;290      /* Find the oldest entry in the cache. */
;;;291      for(i = 0; i < FWCACHE_SIZE; ++i) {
000006  2100              MOVS     r1,#0
000008  e01a              B        |L2.64|
                  |L2.10|
;;;292        if(fwcache[i].timer == 0) {
00000a  ebc103c1          RSB      r3,r1,r1,LSL #3
00000e  4c17              LDR      r4,|L2.108|
000010  f8343013          LDRH     r3,[r4,r3,LSL #1]
000014  b923              CBNZ     r3,|L2.32|
;;;293          fw = &fwcache[i];
000016  ebc103c1          RSB      r3,r1,r1,LSL #3
00001a  eb040043          ADD      r0,r4,r3,LSL #1
;;;294          break;
00001e  e011              B        |L2.68|
                  |L2.32|
;;;295        } else if(fwcache[i].timer <= oldest) {
000020  ebc103c1          RSB      r3,r1,r1,LSL #3
000024  4c11              LDR      r4,|L2.108|
000026  f8343013          LDRH     r3,[r4,r3,LSL #1]
00002a  4293              CMP      r3,r2
00002c  dc07              BGT      |L2.62|
;;;296          fw = &fwcache[i];
00002e  ebc103c1          RSB      r3,r1,r1,LSL #3
000032  eb040043          ADD      r0,r4,r3,LSL #1
;;;297          oldest = fwcache[i].timer;
000036  ebc103c1          RSB      r3,r1,r1,LSL #3
00003a  f8342013          LDRH     r2,[r4,r3,LSL #1]
                  |L2.62|
00003e  1c49              ADDS     r1,r1,#1              ;291
                  |L2.64|
000040  2902              CMP      r1,#2                 ;291
000042  dbe2              BLT      |L2.10|
                  |L2.68|
000044  bf00              NOP                            ;294
;;;298        }
;;;299      }
;;;300    
;;;301      fw->timer = FW_TIME;
000046  2314              MOVS     r3,#0x14
000048  8003              STRH     r3,[r0,#0]
;;;302      fw->ipid = BUF->ipid;
00004a  4b09              LDR      r3,|L2.112|
00004c  8a5b              LDRH     r3,[r3,#0x12]
00004e  8143              STRH     r3,[r0,#0xa]
;;;303      fw->srcipaddr[0] = BUF->srcipaddr[0];
000050  4b07              LDR      r3,|L2.112|
000052  8b5b              LDRH     r3,[r3,#0x1a]
000054  8043              STRH     r3,[r0,#2]
;;;304      fw->srcipaddr[1] = BUF->srcipaddr[1];
000056  4b06              LDR      r3,|L2.112|
000058  8b9c              LDRH     r4,[r3,#0x1c]
00005a  8084              STRH     r4,[r0,#4]
;;;305      fw->destipaddr[0] = BUF->destipaddr[0];
00005c  8bdb              LDRH     r3,[r3,#0x1e]
00005e  80c3              STRH     r3,[r0,#6]
;;;306      fw->destipaddr[1] = BUF->destipaddr[1];
000060  4b03              LDR      r3,|L2.112|
000062  8c1c              LDRH     r4,[r3,#0x20]
000064  8104              STRH     r4,[r0,#8]
;;;307      fw->proto = BUF->proto;
000066  7ddb              LDRB     r3,[r3,#0x17]
000068  7303              STRB     r3,[r0,#0xc]
;;;308    #if notdef
;;;309      fw->payload[0] = BUF->srcport;
;;;310      fw->payload[1] = BUF->destport;
;;;311    #endif
;;;312    #if UIP_REASSEMBLY > 0
;;;313      fw->len = BUF->len;
;;;314      fw->offset = BUF->ipoffset;
;;;315    #endif
;;;316    }
00006a  bd10              POP      {r4,pc}
;;;317    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L2.108|
                          DCD      fwcache
                  |L2.112|
                          DCD      uip_buf

                          AREA ||i.ipaddr_maskcmp||, CODE, READONLY, ALIGN=1

                  ipaddr_maskcmp PROC
;;;206    static unsigned char
;;;207    ipaddr_maskcmp(u16_t *ipaddr, u16_t *netipaddr, u16_t *netmask)
000000  b530              PUSH     {r4,r5,lr}
;;;208    {
000002  4603              MOV      r3,r0
;;;209      return (ipaddr[0] & netmask [0]) == (netipaddr[0] & netmask[0]) &&
000004  8818              LDRH     r0,[r3,#0]
000006  8814              LDRH     r4,[r2,#0]
000008  4020              ANDS     r0,r0,r4
00000a  880c              LDRH     r4,[r1,#0]
00000c  8815              LDRH     r5,[r2,#0]
00000e  402c              ANDS     r4,r4,r5
000010  42a0              CMP      r0,r4
000012  d109              BNE      |L3.40|
;;;210        (ipaddr[1] & netmask[1]) == (netipaddr[1] & netmask[1]);
000014  885c              LDRH     r4,[r3,#2]
000016  8850              LDRH     r0,[r2,#2]
000018  4004              ANDS     r4,r4,r0
00001a  8848              LDRH     r0,[r1,#2]
00001c  8855              LDRH     r5,[r2,#2]
00001e  4028              ANDS     r0,r0,r5
000020  4284              CMP      r4,r0
000022  d101              BNE      |L3.40|
000024  2001              MOVS     r0,#1
                  |L3.38|
;;;211    }
000026  bd30              POP      {r4,r5,pc}
                  |L3.40|
000028  2000              MOVS     r0,#0                 ;210
00002a  e7fc              B        |L3.38|
;;;212    /*------------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.time_exceeded||, CODE, READONLY, ALIGN=2

                  time_exceeded PROC
;;;221    static void
;;;222    time_exceeded(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224      u16_t tmp16;
;;;225    
;;;226      /* We don't send out ICMP errors for ICMP messages. */
;;;227      if(ICMPBUF->proto == UIP_PROTO_ICMP) {
000002  4827              LDR      r0,|L4.160|
000004  7dc0              LDRB     r0,[r0,#0x17]
000006  2801              CMP      r0,#1
000008  d103              BNE      |L4.18|
;;;228        uip_len = 0;
00000a  2000              MOVS     r0,#0
00000c  4925              LDR      r1,|L4.164|
00000e  8008              STRH     r0,[r1,#0]
                  |L4.16|
;;;229        return;
;;;230      }
;;;231      /* Copy fields from packet header into payload of this ICMP packet. */
;;;232      memcpy(&(ICMPBUF->payload[0]), ICMPBUF, 28);
;;;233    
;;;234      /* Set the ICMP type and code. */
;;;235      ICMPBUF->type = ICMP_TE;
;;;236      ICMPBUF->icode = 0;
;;;237    
;;;238      /* Calculate the ICMP checksum. */
;;;239      ICMPBUF->icmpchksum = 0;
;;;240      ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
;;;241    
;;;242      /* Set the IP destination address to be the source address of the
;;;243         original packet. */
;;;244      tmp16= BUF->destipaddr[0];
;;;245      BUF->destipaddr[0] = BUF->srcipaddr[0];
;;;246      BUF->srcipaddr[0] = tmp16;
;;;247      tmp16 = BUF->destipaddr[1];
;;;248      BUF->destipaddr[1] = BUF->srcipaddr[1];
;;;249      BUF->srcipaddr[1] = tmp16;
;;;250    
;;;251      /* Set our IP address as the source address. */
;;;252      BUF->srcipaddr[0] = uip_hostaddr[0];
;;;253      BUF->srcipaddr[1] = uip_hostaddr[1];
;;;254    
;;;255      /* The size of the ICMP time exceeded packet is 36 + the size of the
;;;256         IP header (20) = 56. */
;;;257      uip_len = 56;
;;;258      ICMPBUF->len[0] = 0;
;;;259      ICMPBUF->len[1] = uip_len;
;;;260    
;;;261      /* Fill in the other fields in the IP header. */
;;;262      ICMPBUF->vhl = 0x45;
;;;263      ICMPBUF->tos = 0;
;;;264      ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;
;;;265      ICMPBUF->ttl  = UIP_TTL;
;;;266      ICMPBUF->proto = UIP_PROTO_ICMP;
;;;267    
;;;268      /* Calculate IP checksum. */
;;;269      ICMPBUF->ipchksum = 0;
;;;270      ICMPBUF->ipchksum = ~(uip_ipchksum());
;;;271    
;;;272    
;;;273    }
000010  bd10              POP      {r4,pc}
                  |L4.18|
000012  221c              MOVS     r2,#0x1c              ;232
000014  4922              LDR      r1,|L4.160|
000016  310e              ADDS     r1,r1,#0xe            ;232
000018  f101001c          ADD      r0,r1,#0x1c           ;232
00001c  f7fffffe          BL       __aeabi_memcpy
000020  210b              MOVS     r1,#0xb               ;235
000022  481f              LDR      r0,|L4.160|
000024  f8801022          STRB     r1,[r0,#0x22]         ;235
000028  2100              MOVS     r1,#0                 ;236
00002a  f8801023          STRB     r1,[r0,#0x23]         ;236
00002e  8481              STRH     r1,[r0,#0x24]         ;239
000030  2124              MOVS     r1,#0x24              ;240
000032  3022              ADDS     r0,r0,#0x22           ;240
000034  f7fffffe          BL       uip_chksum
000038  43c0              MVNS     r0,r0                 ;240
00003a  b281              UXTH     r1,r0                 ;240
00003c  4818              LDR      r0,|L4.160|
00003e  8481              STRH     r1,[r0,#0x24]         ;240
000040  8bc4              LDRH     r4,[r0,#0x1e]         ;244
000042  8b41              LDRH     r1,[r0,#0x1a]         ;245
000044  83c1              STRH     r1,[r0,#0x1e]         ;245
000046  8344              STRH     r4,[r0,#0x1a]         ;246
000048  8c04              LDRH     r4,[r0,#0x20]         ;247
00004a  8b81              LDRH     r1,[r0,#0x1c]         ;248
00004c  8401              STRH     r1,[r0,#0x20]         ;248
00004e  8384              STRH     r4,[r0,#0x1c]         ;249
000050  4815              LDR      r0,|L4.168|
000052  8801              LDRH     r1,[r0,#0]            ;252  ; uip_hostaddr
000054  4812              LDR      r0,|L4.160|
000056  8341              STRH     r1,[r0,#0x1a]         ;252
000058  4813              LDR      r0,|L4.168|
00005a  8841              LDRH     r1,[r0,#2]            ;253  ; uip_hostaddr
00005c  4810              LDR      r0,|L4.160|
00005e  8381              STRH     r1,[r0,#0x1c]         ;253
000060  2038              MOVS     r0,#0x38              ;257
000062  4910              LDR      r1,|L4.164|
000064  8008              STRH     r0,[r1,#0]            ;257
000066  2100              MOVS     r1,#0                 ;258
000068  480d              LDR      r0,|L4.160|
00006a  7401              STRB     r1,[r0,#0x10]         ;258
00006c  480d              LDR      r0,|L4.164|
00006e  7801              LDRB     r1,[r0,#0]            ;259  ; uip_len
000070  480b              LDR      r0,|L4.160|
000072  7441              STRB     r1,[r0,#0x11]         ;259
000074  2045              MOVS     r0,#0x45              ;262
000076  490a              LDR      r1,|L4.160|
000078  7388              STRB     r0,[r1,#0xe]          ;262
00007a  2100              MOVS     r1,#0                 ;263
00007c  4808              LDR      r0,|L4.160|
00007e  73c1              STRB     r1,[r0,#0xf]          ;263
000080  7541              STRB     r1,[r0,#0x15]         ;264
000082  7501              STRB     r1,[r0,#0x14]         ;264
000084  2140              MOVS     r1,#0x40              ;265
000086  7581              STRB     r1,[r0,#0x16]         ;265
000088  2101              MOVS     r1,#1                 ;266
00008a  75c1              STRB     r1,[r0,#0x17]         ;266
00008c  2100              MOVS     r1,#0                 ;269
00008e  8301              STRH     r1,[r0,#0x18]         ;269
000090  f7fffffe          BL       uip_ipchksum
000094  43c0              MVNS     r0,r0                 ;270
000096  b281              UXTH     r1,r0                 ;270
000098  4801              LDR      r0,|L4.160|
00009a  8301              STRH     r1,[r0,#0x18]         ;270
00009c  bf00              NOP      
00009e  e7b7              B        |L4.16|
;;;274    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L4.160|
                          DCD      uip_buf
                  |L4.164|
                          DCD      uip_len
                  |L4.168|
                          DCD      uip_hostaddr

                          AREA ||i.uip_fw_default||, CODE, READONLY, ALIGN=2

                  uip_fw_default PROC
;;;512    void
;;;513    uip_fw_default(struct uip_fw_netif *netif)
000000  4901              LDR      r1,|L5.8|
;;;514    {
;;;515      defaultnetif = netif;
000002  6008              STR      r0,[r1,#0]  ; defaultnetif
;;;516    }
000004  4770              BX       lr
;;;517    /*------------------------------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      defaultnetif

                          AREA ||i.uip_fw_forward||, CODE, READONLY, ALIGN=2

                  uip_fw_forward PROC
;;;405    u8_t
;;;406    uip_fw_forward(void)
000000  b510              PUSH     {r4,lr}
;;;407    {
;;;408      struct fwcache_entry *fw;
;;;409    
;;;410      /* First check if the packet is destined for ourselves and return 0
;;;411         to indicate that the packet should be processed locally. */
;;;412      if(BUF->destipaddr[0] == uip_hostaddr[0] &&
000002  4836              LDR      r0,|L6.220|
000004  8bc0              LDRH     r0,[r0,#0x1e]
000006  4936              LDR      r1,|L6.224|
000008  8809              LDRH     r1,[r1,#0]  ; uip_hostaddr
00000a  4288              CMP      r0,r1
00000c  d107              BNE      |L6.30|
;;;413         BUF->destipaddr[1] == uip_hostaddr[1]) {
00000e  4833              LDR      r0,|L6.220|
000010  8c00              LDRH     r0,[r0,#0x20]
000012  4933              LDR      r1,|L6.224|
000014  8849              LDRH     r1,[r1,#2]  ; uip_hostaddr
000016  4288              CMP      r0,r1
000018  d101              BNE      |L6.30|
;;;414        return UIP_FW_LOCAL;
00001a  2000              MOVS     r0,#0
                  |L6.28|
;;;415      }
;;;416    
;;;417      /* If we use ping IP address configuration, and our IP address is
;;;418         not yet configured, we should intercept all ICMP echo packets. */
;;;419    #if UIP_PINGADDRCONF
;;;420      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&
;;;421         BUF->proto == UIP_PROTO_ICMP &&
;;;422         ICMPBUF->type == ICMP_ECHO) {
;;;423        return UIP_FW_LOCAL;
;;;424      }
;;;425    #endif /* UIP_PINGADDRCONF */
;;;426    
;;;427      /* Check if the packet is in the forwarding cache already, and if so
;;;428         we drop it. */
;;;429    
;;;430      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
;;;431        if(fw->timer != 0 &&
;;;432    #if UIP_REASSEMBLY > 0
;;;433           fw->len == BUF->len &&
;;;434           fw->offset == BUF->ipoffset &&
;;;435    #endif
;;;436           fw->ipid == BUF->ipid &&
;;;437           fw->srcipaddr[0] == BUF->srcipaddr[0] &&
;;;438           fw->srcipaddr[1] == BUF->srcipaddr[1] &&
;;;439           fw->destipaddr[0] == BUF->destipaddr[0] &&
;;;440           fw->destipaddr[1] == BUF->destipaddr[1] &&
;;;441    #if notdef
;;;442           fw->payload[0] == BUF->srcport &&
;;;443           fw->payload[1] == BUF->destport &&
;;;444    #endif
;;;445           fw->proto == BUF->proto) {
;;;446          /* Drop packet. */
;;;447          return UIP_FW_FORWARDED;
;;;448        }
;;;449      }
;;;450    
;;;451      /* If the TTL reaches zero we produce an ICMP time exceeded message
;;;452         in the uip_buf buffer and forward that packet back to the sender
;;;453         of the packet. */
;;;454      if(BUF->ttl <= 1) {
;;;455        /* No time exceeded for broadcasts and multicasts! */
;;;456        if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;457          return UIP_FW_LOCAL;
;;;458        }
;;;459        time_exceeded();
;;;460      }
;;;461    
;;;462      /* Decrement the TTL (time-to-live) value in the IP header */
;;;463      BUF->ttl = BUF->ttl - 1;
;;;464    
;;;465      /* Update the IP checksum. */
;;;466      if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {
;;;467        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;
;;;468      } else {
;;;469        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);
;;;470      }
;;;471    
;;;472      if(uip_len > 0) {
;;;473        uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];
;;;474        uip_fw_output();
;;;475      }
;;;476    
;;;477    #if UIP_BROADCAST
;;;478      if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;479        return UIP_FW_LOCAL;
;;;480      }
;;;481    #endif /* UIP_BROADCAST */
;;;482    
;;;483      /* Return non-zero to indicate that the packet was forwarded and that no
;;;484         other processing should be made. */
;;;485      return UIP_FW_FORWARDED;
;;;486    }
00001c  bd10              POP      {r4,pc}
                  |L6.30|
00001e  4c31              LDR      r4,|L6.228|
000020  e022              B        |L6.104|
                  |L6.34|
000022  8820              LDRH     r0,[r4,#0]            ;431
000024  b1f8              CBZ      r0,|L6.102|
000026  8961              LDRH     r1,[r4,#0xa]          ;436
000028  482c              LDR      r0,|L6.220|
00002a  8a40              LDRH     r0,[r0,#0x12]         ;436
00002c  4281              CMP      r1,r0                 ;436
00002e  d11a              BNE      |L6.102|
000030  8861              LDRH     r1,[r4,#2]            ;437
000032  482a              LDR      r0,|L6.220|
000034  8b40              LDRH     r0,[r0,#0x1a]         ;437
000036  4281              CMP      r1,r0                 ;437
000038  d115              BNE      |L6.102|
00003a  88a1              LDRH     r1,[r4,#4]            ;438
00003c  4827              LDR      r0,|L6.220|
00003e  8b80              LDRH     r0,[r0,#0x1c]         ;438
000040  4281              CMP      r1,r0                 ;438
000042  d110              BNE      |L6.102|
000044  88e1              LDRH     r1,[r4,#6]            ;439
000046  4825              LDR      r0,|L6.220|
000048  8bc0              LDRH     r0,[r0,#0x1e]         ;439
00004a  4281              CMP      r1,r0                 ;439
00004c  d10b              BNE      |L6.102|
00004e  8921              LDRH     r1,[r4,#8]            ;440
000050  4822              LDR      r0,|L6.220|
000052  8c00              LDRH     r0,[r0,#0x20]         ;440
000054  4281              CMP      r1,r0                 ;440
000056  d106              BNE      |L6.102|
000058  7b21              LDRB     r1,[r4,#0xc]          ;445
00005a  4820              LDR      r0,|L6.220|
00005c  7dc0              LDRB     r0,[r0,#0x17]         ;445
00005e  4281              CMP      r1,r0                 ;445
000060  d101              BNE      |L6.102|
000062  2001              MOVS     r0,#1                 ;447
000064  e7da              B        |L6.28|
                  |L6.102|
000066  340e              ADDS     r4,r4,#0xe            ;430
                  |L6.104|
000068  481e              LDR      r0,|L6.228|
00006a  301c              ADDS     r0,r0,#0x1c           ;430
00006c  4284              CMP      r4,r0                 ;430
00006e  d3d8              BCC      |L6.34|
000070  481a              LDR      r0,|L6.220|
000072  7d80              LDRB     r0,[r0,#0x16]         ;454
000074  2801              CMP      r0,#1                 ;454
000076  dc0d              BGT      |L6.148|
000078  4818              LDR      r0,|L6.220|
00007a  8bc0              LDRH     r0,[r0,#0x1e]         ;456
00007c  f64f71ff          MOV      r1,#0xffff            ;456
000080  4288              CMP      r0,r1                 ;456
000082  d105              BNE      |L6.144|
000084  4815              LDR      r0,|L6.220|
000086  8c00              LDRH     r0,[r0,#0x20]         ;456
000088  4288              CMP      r0,r1                 ;456
00008a  d101              BNE      |L6.144|
00008c  2000              MOVS     r0,#0                 ;457
00008e  e7c5              B        |L6.28|
                  |L6.144|
000090  f7fffffe          BL       time_exceeded
                  |L6.148|
000094  4811              LDR      r0,|L6.220|
000096  7d80              LDRB     r0,[r0,#0x16]         ;463
000098  1e40              SUBS     r0,r0,#1              ;463
00009a  b2c1              UXTB     r1,r0                 ;463
00009c  480f              LDR      r0,|L6.220|
00009e  7581              STRB     r1,[r0,#0x16]         ;463
0000a0  8b00              LDRH     r0,[r0,#0x18]         ;466
0000a2  f64f71fe          MOV      r1,#0xfffe            ;466
0000a6  4288              CMP      r0,r1                 ;466
0000a8  db06              BLT      |L6.184|
0000aa  480c              LDR      r0,|L6.220|
0000ac  8b00              LDRH     r0,[r0,#0x18]         ;467
0000ae  1c80              ADDS     r0,r0,#2              ;467
0000b0  b281              UXTH     r1,r0                 ;467
0000b2  480a              LDR      r0,|L6.220|
0000b4  8301              STRH     r1,[r0,#0x18]         ;467
0000b6  e005              B        |L6.196|
                  |L6.184|
0000b8  4808              LDR      r0,|L6.220|
0000ba  8b00              LDRH     r0,[r0,#0x18]         ;469
0000bc  1c40              ADDS     r0,r0,#1              ;469
0000be  b281              UXTH     r1,r0                 ;469
0000c0  4806              LDR      r0,|L6.220|
0000c2  8301              STRH     r1,[r0,#0x18]         ;469
                  |L6.196|
0000c4  4808              LDR      r0,|L6.232|
0000c6  8800              LDRH     r0,[r0,#0]            ;472  ; uip_len
0000c8  2800              CMP      r0,#0                 ;472
0000ca  dd05              BLE      |L6.216|
0000cc  4803              LDR      r0,|L6.220|
0000ce  3036              ADDS     r0,r0,#0x36           ;473
0000d0  4906              LDR      r1,|L6.236|
0000d2  6008              STR      r0,[r1,#0]            ;473  ; uip_appdata
0000d4  f7fffffe          BL       uip_fw_output
                  |L6.216|
0000d8  2001              MOVS     r0,#1                 ;485
0000da  e79f              B        |L6.28|
;;;487    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L6.220|
                          DCD      uip_buf
                  |L6.224|
                          DCD      uip_hostaddr
                  |L6.228|
                          DCD      fwcache
                  |L6.232|
                          DCD      uip_len
                  |L6.236|
                          DCD      uip_appdata

                          AREA ||i.uip_fw_init||, CODE, READONLY, ALIGN=2

                  uip_fw_init PROC
;;;182    void
;;;183    uip_fw_init(void)
000000  2100              MOVS     r1,#0
;;;184    {
;;;185      struct uip_fw_netif *t;
;;;186      defaultnetif = NULL;
000002  4a08              LDR      r2,|L7.36|
000004  6011              STR      r1,[r2,#0]  ; defaultnetif
;;;187      while(netifs != NULL) {
000006  e007              B        |L7.24|
                  |L7.8|
;;;188        t = netifs;
000008  4907              LDR      r1,|L7.40|
00000a  6808              LDR      r0,[r1,#0]  ; netifs
;;;189        netifs = netifs->next;
00000c  6809              LDR      r1,[r1,#0]  ; netifs
00000e  6809              LDR      r1,[r1,#0]
000010  4a05              LDR      r2,|L7.40|
000012  6011              STR      r1,[r2,#0]  ; netifs
;;;190        t->next = NULL;
000014  2100              MOVS     r1,#0
000016  6001              STR      r1,[r0,#0]
                  |L7.24|
000018  4903              LDR      r1,|L7.40|
00001a  6809              LDR      r1,[r1,#0]            ;187  ; netifs
00001c  2900              CMP      r1,#0                 ;187
00001e  d1f3              BNE      |L7.8|
;;;191      }
;;;192    }
000020  4770              BX       lr
;;;193    /*------------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      defaultnetif
                  |L7.40|
                          DCD      netifs

                          AREA ||i.uip_fw_output||, CODE, READONLY, ALIGN=2

                  uip_fw_output PROC
;;;357    u8_t
;;;358    uip_fw_output(void)
000000  b510              PUSH     {r4,lr}
;;;359    {
;;;360      struct uip_fw_netif *netif;
;;;361    
;;;362      if(uip_len == 0) {
000002  4808              LDR      r0,|L8.36|
000004  8800              LDRH     r0,[r0,#0]  ; uip_len
000006  b908              CBNZ     r0,|L8.12|
;;;363        return UIP_FW_ZEROLEN;
000008  2002              MOVS     r0,#2
                  |L8.10|
;;;364      }
;;;365    
;;;366      fwcache_register();
;;;367    
;;;368    #if UIP_BROADCAST
;;;369      /* Link local broadcasts go out on all interfaces. */
;;;370      if(/*BUF->proto == UIP_PROTO_UDP &&*/
;;;371         BUF->destipaddr[0] == 0xffff &&
;;;372         BUF->destipaddr[1] == 0xffff) {
;;;373        if(defaultnetif != NULL) {
;;;374          defaultnetif->output();
;;;375        }
;;;376        for(netif = netifs; netif != NULL; netif = netif->next) {
;;;377          netif->output();
;;;378        }
;;;379        return UIP_FW_OK;
;;;380      }
;;;381    #endif /* UIP_BROADCAST */
;;;382    
;;;383      netif = find_netif();
;;;384      /*  printf("uip_fw_output: netif %p ->output %p len %d\n", netif,
;;;385    	 netif->output,
;;;386    	 uip_len);*/
;;;387    
;;;388      if(netif == NULL) {
;;;389        return UIP_FW_NOROUTE;
;;;390      }
;;;391      /* If we now have found a suitable network interface, we call its
;;;392         output function to send out the packet. */
;;;393      return netif->output();
;;;394    }
00000a  bd10              POP      {r4,pc}
                  |L8.12|
00000c  f7fffffe          BL       fwcache_register
000010  f7fffffe          BL       find_netif
000014  4604              MOV      r4,r0                 ;383
000016  b90c              CBNZ     r4,|L8.28|
000018  2004              MOVS     r0,#4                 ;389
00001a  e7f6              B        |L8.10|
                  |L8.28|
00001c  68e0              LDR      r0,[r4,#0xc]          ;393
00001e  4780              BLX      r0                    ;393
000020  e7f3              B        |L8.10|
;;;395    /*------------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      uip_len

                          AREA ||i.uip_fw_periodic||, CODE, READONLY, ALIGN=2

                  uip_fw_periodic PROC
;;;522    void
;;;523    uip_fw_periodic(void)
000000  4806              LDR      r0,|L9.28|
;;;524    {
;;;525      struct fwcache_entry *fw;
;;;526      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
000002  e006              B        |L9.18|
                  |L9.4|
;;;527        if(fw->timer > 0) {
000004  8801              LDRH     r1,[r0,#0]
000006  2900              CMP      r1,#0
000008  dd02              BLE      |L9.16|
;;;528          --fw->timer;
00000a  8801              LDRH     r1,[r0,#0]
00000c  1e49              SUBS     r1,r1,#1
00000e  8001              STRH     r1,[r0,#0]
                  |L9.16|
000010  300e              ADDS     r0,r0,#0xe            ;526
                  |L9.18|
000012  4902              LDR      r1,|L9.28|
000014  311c              ADDS     r1,r1,#0x1c           ;526
000016  4288              CMP      r0,r1                 ;526
000018  d3f4              BCC      |L9.4|
;;;529        }
;;;530      }
;;;531    }
00001a  4770              BX       lr
;;;532    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L9.28|
                          DCD      fwcache

                          AREA ||i.uip_fw_register||, CODE, READONLY, ALIGN=2

                  uip_fw_register PROC
;;;495    void
;;;496    uip_fw_register(struct uip_fw_netif *netif)
000000  4902              LDR      r1,|L10.12|
;;;497    {
;;;498      netif->next = netifs;
000002  6809              LDR      r1,[r1,#0]  ; netifs
000004  6001              STR      r1,[r0,#0]
;;;499      netifs = netif;
000006  4901              LDR      r1,|L10.12|
000008  6008              STR      r0,[r1,#0]  ; netifs
;;;500    }
00000a  4770              BX       lr
;;;501    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L10.12|
                          DCD      netifs

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  fwcache
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  netifs
                          DCD      0x00000000
                  defaultnetif
                          DCD      0x00000000
