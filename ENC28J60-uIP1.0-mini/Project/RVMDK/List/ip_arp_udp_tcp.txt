; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\ip_arp_udp_tcp.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\ip_arp_udp_tcp.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\ip_arp_udp_tcp.crf ..\..\Source\src\uIP_enc28j60\ip_arp_udp_tcp.c]
                          THUMB

                          AREA ||i.checksum||, CODE, READONLY, ALIGN=1

                  checksum PROC
;;;39     // The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
;;;40     unsigned  int checksum(unsigned char *buf, unsigned  int len,unsigned char type)
000000  b530              PUSH     {r4,r5,lr}
;;;41     	{
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;42     	// type 0=ip 
;;;43     	//      1=udp
;;;44     	//      2=tcp
;;;45     	unsigned long sum = 0;
000006  2100              MOVS     r1,#0
;;;46     	
;;;47     	//if(type==0){
;;;48     	//        // do not add anything
;;;49     	//}
;;;50     	if(type==1)
000008  2a01              CMP      r2,#1
00000a  d103              BNE      |L1.20|
;;;51     		{
;;;52     		sum+=IP_PROTO_UDP_V; // protocol udp
00000c  3111              ADDS     r1,r1,#0x11
;;;53     		// the length here is the length of udp (data+header len)
;;;54     		// =length given to this function - (IP.scr+IP.dst length)
;;;55     		sum+=len-8; // = real tcp len
00000e  f1a30008          SUB      r0,r3,#8
000012  4401              ADD      r1,r1,r0
                  |L1.20|
;;;56     		}
;;;57     	if(type==2)
000014  2a02              CMP      r2,#2
000016  d103              BNE      |L1.32|
;;;58     		{
;;;59     		sum+=IP_PROTO_TCP_V; 
000018  1d89              ADDS     r1,r1,#6
;;;60     		// the length here is the length of tcp (data+header len)
;;;61     		// =length given to this function - (IP.scr+IP.dst length)
;;;62     		sum+=len-8; // = real tcp len
00001a  f1a30008          SUB      r0,r3,#8
00001e  4401              ADD      r1,r1,r0
                  |L1.32|
;;;63     		}
;;;64     	// build the sum of 16bit words
;;;65     	while(len >1)
000020  e006              B        |L1.48|
                  |L1.34|
;;;66     		{
;;;67     		sum += 0xFFFF & (*buf<<8|*(buf+1));
000022  7860              LDRB     r0,[r4,#1]
000024  7825              LDRB     r5,[r4,#0]
000026  ea402005          ORR      r0,r0,r5,LSL #8
00002a  4401              ADD      r1,r1,r0
;;;68     		buf+=2;
00002c  1ca4              ADDS     r4,r4,#2
;;;69     		len-=2;
00002e  1e9b              SUBS     r3,r3,#2
                  |L1.48|
000030  2b01              CMP      r3,#1                 ;65
000032  d8f6              BHI      |L1.34|
;;;70     		}
;;;71     	// if there is a byte left then add it (padded with zero)
;;;72     	if (len)
000034  b113              CBZ      r3,|L1.60|
;;;73     		{
;;;74     		sum += (0xFF & *buf)<<8;
000036  7820              LDRB     r0,[r4,#0]
000038  eb012100          ADD      r1,r1,r0,LSL #8
                  |L1.60|
;;;75     		}
;;;76     	// now calculate the sum over the bytes in the sum
;;;77     	// until the result is only 16bit long
;;;78     	while (sum>>16)
00003c  e002              B        |L1.68|
                  |L1.62|
;;;79     		{
;;;80     		sum = (sum & 0xFFFF)+(sum >> 16);
00003e  b288              UXTH     r0,r1
000040  eb004111          ADD      r1,r0,r1,LSR #16
                  |L1.68|
000044  0c08              LSRS     r0,r1,#16             ;78
000046  2800              CMP      r0,#0                 ;78
000048  d1f9              BNE      |L1.62|
;;;81     		}
;;;82     	// build 1's complement:
;;;83     	return( (unsigned  int) sum ^ 0xFFFF);
00004a  f64f75ff          MOV      r5,#0xffff
00004e  ea810005          EOR      r0,r1,r5
;;;84     	}
000052  bd30              POP      {r4,r5,pc}
;;;85     
                          ENDP


                          AREA ||i.eth_type_is_arp_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_arp_and_my_ip PROC
;;;103    
;;;104    unsigned char eth_type_is_arp_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;105    	{
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;106    	unsigned char i=0;
000006  2100              MOVS     r1,#0
;;;107    	//  
;;;108    	if (len<41)
000008  2b29              CMP      r3,#0x29
00000a  d201              BCS      |L2.16|
;;;109    		{
;;;110    	    return(0);
00000c  2000              MOVS     r0,#0
                  |L2.14|
;;;111    		}
;;;112    	if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V)
;;;113    		{
;;;114    	    return(0);
;;;115    		}
;;;116    	while(i<4)
;;;117    		{
;;;118    	    if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i])
;;;119    			{
;;;120    	        return(0);
;;;121    	    	}
;;;122    	    i++;
;;;123    		}
;;;124    	return(1);
;;;125    	}
00000e  bd10              POP      {r4,pc}
                  |L2.16|
000010  7b10              LDRB     r0,[r2,#0xc]          ;112
000012  2808              CMP      r0,#8                 ;112
000014  d102              BNE      |L2.28|
000016  7b50              LDRB     r0,[r2,#0xd]          ;112
000018  2806              CMP      r0,#6                 ;112
00001a  d001              BEQ      |L2.32|
                  |L2.28|
00001c  2000              MOVS     r0,#0                 ;114
00001e  e7f6              B        |L2.14|
                  |L2.32|
000020  e00a              B        |L2.56|
                  |L2.34|
000022  f1010026          ADD      r0,r1,#0x26           ;118
000026  5c10              LDRB     r0,[r2,r0]            ;118
000028  4c05              LDR      r4,|L2.64|
00002a  5c64              LDRB     r4,[r4,r1]            ;118
00002c  42a0              CMP      r0,r4                 ;118
00002e  d001              BEQ      |L2.52|
000030  2000              MOVS     r0,#0                 ;120
000032  e7ec              B        |L2.14|
                  |L2.52|
000034  1c48              ADDS     r0,r1,#1              ;122
000036  b2c1              UXTB     r1,r0                 ;122
                  |L2.56|
000038  2904              CMP      r1,#4                 ;116
00003a  dbf2              BLT      |L2.34|
00003c  2001              MOVS     r0,#1                 ;124
00003e  e7e6              B        |L2.14|
;;;126    
                          ENDP

                  |L2.64|
                          DCD      ipaddr

                          AREA ||i.eth_type_is_ip_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_ip_and_my_ip PROC
;;;126    
;;;127    unsigned char eth_type_is_ip_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;128    	{
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;129    	unsigned char i=0;
000006  2100              MOVS     r1,#0
;;;130    	//eth+ip+udp header is 42
;;;131    	if (len<42)
000008  2b2a              CMP      r3,#0x2a
00000a  d201              BCS      |L3.16|
;;;132    		{
;;;133    	    return(0);
00000c  2000              MOVS     r0,#0
                  |L3.14|
;;;134    		}
;;;135    	if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V)
;;;136    		{
;;;137    	    return(0);
;;;138    		}
;;;139    	if (buf[IP_HEADER_LEN_VER_P]!=0x45)
;;;140    		{
;;;141    	    // must be IP V4 and 20 byte header
;;;142    	    return(0);
;;;143    		}
;;;144    	while(i<4)
;;;145    		{
;;;146    	    if(buf[IP_DST_P+i]!=ipaddr[i])
;;;147    			{
;;;148    	        return(0);
;;;149    	    	}
;;;150    	    i++;
;;;151    		}
;;;152    	return(1);
;;;153    	}
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  7b10              LDRB     r0,[r2,#0xc]          ;135
000012  2808              CMP      r0,#8                 ;135
000014  d101              BNE      |L3.26|
000016  7b50              LDRB     r0,[r2,#0xd]          ;135
000018  b108              CBZ      r0,|L3.30|
                  |L3.26|
00001a  2000              MOVS     r0,#0                 ;137
00001c  e7f7              B        |L3.14|
                  |L3.30|
00001e  7b90              LDRB     r0,[r2,#0xe]          ;139
000020  2845              CMP      r0,#0x45              ;139
000022  d001              BEQ      |L3.40|
000024  2000              MOVS     r0,#0                 ;142
000026  e7f2              B        |L3.14|
                  |L3.40|
000028  e00a              B        |L3.64|
                  |L3.42|
00002a  f101001e          ADD      r0,r1,#0x1e           ;146
00002e  5c10              LDRB     r0,[r2,r0]            ;146
000030  4c05              LDR      r4,|L3.72|
000032  5c64              LDRB     r4,[r4,r1]            ;146
000034  42a0              CMP      r0,r4                 ;146
000036  d001              BEQ      |L3.60|
000038  2000              MOVS     r0,#0                 ;148
00003a  e7e8              B        |L3.14|
                  |L3.60|
00003c  1c48              ADDS     r0,r1,#1              ;150
00003e  b2c1              UXTB     r1,r0                 ;150
                  |L3.64|
000040  2904              CMP      r1,#4                 ;144
000042  dbf2              BLT      |L3.42|
000044  2001              MOVS     r0,#1                 ;152
000046  e7e2              B        |L3.14|
;;;154    // make a return eth header from a received eth packet
                          ENDP

                  |L3.72|
                          DCD      ipaddr

                          AREA ||i.fill_ip_hdr_checksum||, CODE, READONLY, ALIGN=1

                  fill_ip_hdr_checksum PROC
;;;166    	}
;;;167    void fill_ip_hdr_checksum(unsigned char *buf)
000000  b530              PUSH     {r4,r5,lr}
;;;168    	{
000002  4604              MOV      r4,r0
;;;169    	unsigned  int ck;
;;;170    	// clear the 2 byte checksum
;;;171    	buf[IP_CHECKSUM_P]=0;
000004  2000              MOVS     r0,#0
000006  7620              STRB     r0,[r4,#0x18]
;;;172    	buf[IP_CHECKSUM_P+1]=0;
000008  7660              STRB     r0,[r4,#0x19]
;;;173    	buf[IP_FLAGS_P]=0x40; // don't fragment
00000a  2040              MOVS     r0,#0x40
00000c  7520              STRB     r0,[r4,#0x14]
;;;174    	buf[IP_FLAGS_P+1]=0;  // fragement offset
00000e  2000              MOVS     r0,#0
000010  7560              STRB     r0,[r4,#0x15]
;;;175    	buf[IP_TTL_P]=64; // ttl
000012  2040              MOVS     r0,#0x40
000014  75a0              STRB     r0,[r4,#0x16]
;;;176    	// calculate the checksum:
;;;177    	ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
000016  2200              MOVS     r2,#0
000018  2114              MOVS     r1,#0x14
00001a  f104000e          ADD      r0,r4,#0xe
00001e  f7fffffe          BL       checksum
000022  4605              MOV      r5,r0
;;;178    	buf[IP_CHECKSUM_P]=ck>>8;
000024  0a28              LSRS     r0,r5,#8
000026  7620              STRB     r0,[r4,#0x18]
;;;179    	buf[IP_CHECKSUM_P+1]=ck& 0xff;
000028  7665              STRB     r5,[r4,#0x19]
;;;180    	}
00002a  bd30              POP      {r4,r5,pc}
;;;181    
                          ENDP


                          AREA ||i.fill_tcp_data||, CODE, READONLY, ALIGN=1

                  fill_tcp_data PROC
;;;419    // this string could be filled.
;;;420    unsigned  int fill_tcp_data(unsigned char *buf,unsigned  int pos, const char *s)
000000  b510              PUSH     {r4,lr}
;;;421    	{
000002  4603              MOV      r3,r0
;;;422    	// fill in tcp data at position pos
;;;423    	//
;;;424    	// with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;425    	while (*s) 
000004  e005              B        |L5.18|
                  |L5.6|
;;;426    		{
;;;427    	    buf[TCP_CHECKSUM_L_P+3+pos]=*s;
000006  7814              LDRB     r4,[r2,#0]
000008  f1010036          ADD      r0,r1,#0x36
00000c  541c              STRB     r4,[r3,r0]
;;;428    	    pos++;
00000e  1c49              ADDS     r1,r1,#1
;;;429    	    s++;
000010  1c52              ADDS     r2,r2,#1
                  |L5.18|
000012  7810              LDRB     r0,[r2,#0]            ;425
000014  2800              CMP      r0,#0                 ;425
000016  d1f6              BNE      |L5.6|
;;;430    		}
;;;431    	return(pos);
000018  4608              MOV      r0,r1
;;;432    	}
00001a  bd10              POP      {r4,pc}
;;;433    
                          ENDP


                          AREA ||i.fill_tcp_data_p||, CODE, READONLY, ALIGN=1

                  fill_tcp_data_p PROC
;;;402    // this string could be filled.
;;;403    unsigned  int fill_tcp_data_p(unsigned char *buf,unsigned  int pos, const unsigned char *progmem_s)
000000  b510              PUSH     {r4,lr}
;;;404    	{
000002  4603              MOV      r3,r0
;;;405    	char c;
;;;406    	// fill in tcp data at position pos
;;;407    	//
;;;408    	// with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;409    	while ((c = pgm_read_byte(progmem_s++))) 
000004  e003              B        |L6.14|
                  |L6.6|
;;;410    		{
;;;411    	    buf[TCP_CHECKSUM_L_P+3+pos]=c;
000006  f1010036          ADD      r0,r1,#0x36
00000a  541c              STRB     r4,[r3,r0]
;;;412    	    pos++;
00000c  1c49              ADDS     r1,r1,#1
                  |L6.14|
00000e  f8124b01          LDRB     r4,[r2],#1            ;409
000012  2c00              CMP      r4,#0                 ;409
000014  d1f7              BNE      |L6.6|
;;;413    		}
;;;414    	return(pos);
000016  4608              MOV      r0,r1
;;;415    	}
000018  bd10              POP      {r4,pc}
;;;416    
                          ENDP


                          AREA ||i.get_tcp_data_pointer||, CODE, READONLY, ALIGN=2

                  get_tcp_data_pointer PROC
;;;374    // You must call init_len_info once before calling this function
;;;375    unsigned  int get_tcp_data_pointer(void)
000000  4804              LDR      r0,|L7.20|
;;;376    	{
;;;377    	if (info_data_len)
000002  6800              LDR      r0,[r0,#0]  ; info_data_len
000004  b118              CBZ      r0,|L7.14|
;;;378    			{
;;;379    	        return((unsigned  int)TCP_SRC_PORT_H_P+info_hdr_len);
000006  4804              LDR      r0,|L7.24|
000008  6800              LDR      r0,[r0,#0]  ; info_hdr_len
00000a  3022              ADDS     r0,r0,#0x22
                  |L7.12|
;;;380    			}
;;;381    		else
;;;382    			{
;;;383    	        return(0);
;;;384    			}
;;;385    	}
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0                 ;383
000010  e7fc              B        |L7.12|
;;;386    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      info_data_len
                  |L7.24|
                          DCD      info_hdr_len

                          AREA ||i.init_ip_arp_udp_tcp||, CODE, READONLY, ALIGN=2

                  init_ip_arp_udp_tcp PROC
;;;86     // you must call this function once before you use any of the other functions:
;;;87     void init_ip_arp_udp_tcp(unsigned char *mymac,unsigned char *myip,unsigned char wwwp)
000000  b530              PUSH     {r4,r5,lr}
;;;88     	{
000002  4603              MOV      r3,r0
;;;89     	unsigned char i=0;
000004  2000              MOVS     r0,#0
;;;90     	wwwport=wwwp;
000006  4c0a              LDR      r4,|L8.48|
000008  7022              STRB     r2,[r4,#0]
;;;91     	while(i<4)
00000a  e004              B        |L8.22|
                  |L8.12|
;;;92     		{
;;;93             ipaddr[i]=myip[i];
00000c  5c0c              LDRB     r4,[r1,r0]
00000e  4d09              LDR      r5,|L8.52|
000010  542c              STRB     r4,[r5,r0]
;;;94             i++;
000012  1c44              ADDS     r4,r0,#1
000014  b2e0              UXTB     r0,r4
                  |L8.22|
000016  2804              CMP      r0,#4                 ;91
000018  dbf8              BLT      |L8.12|
;;;95     		}
;;;96     	i=0;
00001a  2000              MOVS     r0,#0
;;;97     	while(i<6)
00001c  e004              B        |L8.40|
                  |L8.30|
;;;98     		{
;;;99             macaddr[i]=mymac[i];
00001e  5c1c              LDRB     r4,[r3,r0]
000020  4d05              LDR      r5,|L8.56|
000022  542c              STRB     r4,[r5,r0]
;;;100            i++;
000024  1c44              ADDS     r4,r0,#1
000026  b2e0              UXTB     r0,r4
                  |L8.40|
000028  2806              CMP      r0,#6                 ;97
00002a  dbf8              BLT      |L8.30|
;;;101    		}
;;;102    	}
00002c  bd30              POP      {r4,r5,pc}
;;;103    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      wwwport
                  |L8.52|
                          DCD      ipaddr
                  |L8.56|
                          DCD      macaddr

                          AREA ||i.init_len_info||, CODE, READONLY, ALIGN=2

                  init_len_info PROC
;;;387    // do some basic length calculations and store the result in static varibales
;;;388    void init_len_info(unsigned char *buf)
000000  7c02              LDRB     r2,[r0,#0x10]
;;;389    	{
;;;390        info_data_len=(buf[IP_TOTLEN_H_P]<<8)|(buf[IP_TOTLEN_L_P]&0xff);
000002  7c41              LDRB     r1,[r0,#0x11]
000004  f362211f          BFI      r1,r2,#8,#24
000008  4a0b              LDR      r2,|L9.56|
00000a  6011              STR      r1,[r2,#0]  ; info_data_len
;;;391        info_data_len-=IP_HEADER_LEN;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]  ; info_data_len
000010  3914              SUBS     r1,r1,#0x14
000012  6011              STR      r1,[r2,#0]  ; info_data_len
;;;392        info_hdr_len=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
000014  f890102e          LDRB     r1,[r0,#0x2e]
000018  1109              ASRS     r1,r1,#4
00001a  0089              LSLS     r1,r1,#2
00001c  4a07              LDR      r2,|L9.60|
00001e  6011              STR      r1,[r2,#0]  ; info_hdr_len
;;;393        info_data_len-=info_hdr_len;
000020  4905              LDR      r1,|L9.56|
000022  6809              LDR      r1,[r1,#0]  ; info_data_len
000024  6812              LDR      r2,[r2,#0]  ; info_hdr_len
000026  1a89              SUBS     r1,r1,r2
000028  4a03              LDR      r2,|L9.56|
00002a  6011              STR      r1,[r2,#0]  ; info_data_len
;;;394        if (info_data_len<=0)
00002c  4611              MOV      r1,r2
00002e  6809              LDR      r1,[r1,#0]  ; info_data_len
000030  b909              CBNZ     r1,|L9.54|
;;;395    		{
;;;396            info_data_len=0;
000032  2100              MOVS     r1,#0
000034  6011              STR      r1,[r2,#0]  ; info_data_len
                  |L9.54|
;;;397        	}
;;;398    	}
000036  4770              BX       lr
;;;399    
                          ENDP

                  |L9.56|
                          DCD      info_data_len
                  |L9.60|
                          DCD      info_hdr_len

                          AREA ||i.make_arp_answer_from_request||, CODE, READONLY, ALIGN=2

                  make_arp_answer_from_request PROC
;;;274    
;;;275    void make_arp_answer_from_request(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;276    	{
000002  4605              MOV      r5,r0
;;;277    	unsigned char i=0;
000004  2400              MOVS     r4,#0
;;;278    	//
;;;279    	make_eth(buf);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       make_eth
;;;280    	buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;   //arp ÏìÓ¦
00000c  2000              MOVS     r0,#0
00000e  7528              STRB     r0,[r5,#0x14]
;;;281    	buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
000010  2002              MOVS     r0,#2
000012  7568              STRB     r0,[r5,#0x15]
;;;282    	// fill the mac addresses:
;;;283    	while(i<6)
000014  e00b              B        |L10.46|
                  |L10.22|
;;;284    		{
;;;285            buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
000016  f1040016          ADD      r0,r4,#0x16
00001a  5c29              LDRB     r1,[r5,r0]
00001c  300a              ADDS     r0,r0,#0xa
00001e  5429              STRB     r1,[r5,r0]
;;;286            buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
000020  480e              LDR      r0,|L10.92|
000022  5d01              LDRB     r1,[r0,r4]
000024  f1040016          ADD      r0,r4,#0x16
000028  5429              STRB     r1,[r5,r0]
;;;287            i++;
00002a  1c60              ADDS     r0,r4,#1
00002c  b2c4              UXTB     r4,r0
                  |L10.46|
00002e  2c06              CMP      r4,#6                 ;283
000030  dbf1              BLT      |L10.22|
;;;288    		}
;;;289    	i=0;
000032  2400              MOVS     r4,#0
;;;290    	while(i<4)
000034  e00b              B        |L10.78|
                  |L10.54|
;;;291    		{
;;;292            buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
000036  f104001c          ADD      r0,r4,#0x1c
00003a  5c29              LDRB     r1,[r5,r0]
00003c  300a              ADDS     r0,r0,#0xa
00003e  5429              STRB     r1,[r5,r0]
;;;293            buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
000040  4807              LDR      r0,|L10.96|
000042  5d01              LDRB     r1,[r0,r4]
000044  f104001c          ADD      r0,r4,#0x1c
000048  5429              STRB     r1,[r5,r0]
;;;294            i++;
00004a  1c60              ADDS     r0,r4,#1
00004c  b2c4              UXTB     r4,r0
                  |L10.78|
00004e  2c04              CMP      r4,#4                 ;290
000050  dbf1              BLT      |L10.54|
;;;295    		}
;;;296    	// eth+arp is 42 bytes:
;;;297    	enc28j60PacketSend(42,buf); 
000052  4629              MOV      r1,r5
000054  202a              MOVS     r0,#0x2a
000056  f7fffffe          BL       enc28j60PacketSend
;;;298    	}
00005a  bd70              POP      {r4-r6,pc}
;;;299    
                          ENDP

                  |L10.92|
                          DCD      macaddr
                  |L10.96|
                          DCD      ipaddr

                          AREA ||i.make_echo_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_echo_reply_from_request PROC
;;;299    
;;;300    void make_echo_reply_from_request(unsigned char *buf,unsigned  int len)
000000  b570              PUSH     {r4-r6,lr}
;;;301    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;302    	make_eth(buf);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       make_eth
;;;303    	make_ip(buf);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       make_ip
;;;304    	buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;	  //////»ØËÍÓ¦´ð////////////////////////////////////////////////////////////////////////////
000012  2000              MOVS     r0,#0
000014  f8840022          STRB     r0,[r4,#0x22]
;;;305    	// we changed only the icmp.type field from request(=8) to reply(=0).
;;;306    	// we can therefore easily correct the checksum:
;;;307    	if (buf[ICMP_CHECKSUM_P] > (0xff-0x08))
000018  f8940024          LDRB     r0,[r4,#0x24]
00001c  28f7              CMP      r0,#0xf7
00001e  dd04              BLE      |L11.42|
;;;308    		{
;;;309    	    buf[ICMP_CHECKSUM_P+1]++;
000020  f8940025          LDRB     r0,[r4,#0x25]
000024  1c40              ADDS     r0,r0,#1
000026  f8840025          STRB     r0,[r4,#0x25]
                  |L11.42|
;;;310    		}
;;;311    	buf[ICMP_CHECKSUM_P]+=0x08;
00002a  f8940024          LDRB     r0,[r4,#0x24]
00002e  3008              ADDS     r0,r0,#8
000030  f8840024          STRB     r0,[r4,#0x24]
;;;312    	//
;;;313    	enc28j60PacketSend(len,buf);
000034  4621              MOV      r1,r4
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       enc28j60PacketSend
;;;314    	}
00003c  bd70              POP      {r4-r6,pc}
;;;315    
                          ENDP


                          AREA ||i.make_eth||, CODE, READONLY, ALIGN=2

                  make_eth PROC
;;;154    // make a return eth header from a received eth packet
;;;155    void make_eth(unsigned char *buf)
000000  4601              MOV      r1,r0
;;;156    	{
;;;157    	unsigned char i=0;
000002  2000              MOVS     r0,#0
;;;158    	//
;;;159    	//copy the destination mac from the source and fill my mac into src
;;;160    	while(i<6)
000004  e008              B        |L12.24|
                  |L12.6|
;;;161    		{
;;;162            buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
000006  1d82              ADDS     r2,r0,#6
000008  5c8a              LDRB     r2,[r1,r2]
00000a  540a              STRB     r2,[r1,r0]
;;;163            buf[ETH_SRC_MAC +i]=macaddr[i];
00000c  4a04              LDR      r2,|L12.32|
00000e  5c13              LDRB     r3,[r2,r0]
000010  1d82              ADDS     r2,r0,#6
000012  548b              STRB     r3,[r1,r2]
;;;164            i++;
000014  1c42              ADDS     r2,r0,#1
000016  b2d0              UXTB     r0,r2
                  |L12.24|
000018  2806              CMP      r0,#6                 ;160
00001a  dbf4              BLT      |L12.6|
;;;165    		}
;;;166    	}
00001c  4770              BX       lr
;;;167    void fill_ip_hdr_checksum(unsigned char *buf)
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      macaddr

                          AREA ||i.make_ip||, CODE, READONLY, ALIGN=2

                  make_ip PROC
;;;182    // make a return ip header from a received ip packet
;;;183    void make_ip(unsigned char *buf)
000000  b530              PUSH     {r4,r5,lr}
;;;184    	{
000002  4605              MOV      r5,r0
;;;185    	unsigned char i=0;
000004  2400              MOVS     r4,#0
;;;186    	while(i<4)
000006  e00b              B        |L13.32|
                  |L13.8|
;;;187    		{
;;;188            buf[IP_DST_P+i]=buf[IP_SRC_P+i];
000008  f104001a          ADD      r0,r4,#0x1a
00000c  5c29              LDRB     r1,[r5,r0]
00000e  1d00              ADDS     r0,r0,#4
000010  5429              STRB     r1,[r5,r0]
;;;189            buf[IP_SRC_P+i]=ipaddr[i];
000012  4806              LDR      r0,|L13.44|
000014  5d01              LDRB     r1,[r0,r4]
000016  f104001a          ADD      r0,r4,#0x1a
00001a  5429              STRB     r1,[r5,r0]
;;;190            i++;
00001c  1c60              ADDS     r0,r4,#1
00001e  b2c4              UXTB     r4,r0
                  |L13.32|
000020  2c04              CMP      r4,#4                 ;186
000022  dbf1              BLT      |L13.8|
;;;191    		}
;;;192    	fill_ip_hdr_checksum(buf);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       fill_ip_hdr_checksum
;;;193    	}
00002a  bd30              POP      {r4,r5,pc}
;;;194    
                          ENDP

                  |L13.44|
                          DCD      ipaddr

                          AREA ||i.make_tcp_ack_from_any||, CODE, READONLY, ALIGN=2

                  make_tcp_ack_from_any PROC
;;;435    // This will modify the eth/ip/tcp header 
;;;436    void make_tcp_ack_from_any(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;437    	{
000002  4604              MOV      r4,r0
;;;438    	unsigned  int j;
;;;439    	make_eth(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       make_eth
;;;440    	// fill the header:
;;;441    	buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V;
00000a  2010              MOVS     r0,#0x10
00000c  f884002f          STRB     r0,[r4,#0x2f]
;;;442    	if (info_data_len==0)
000010  4814              LDR      r0,|L14.100|
000012  6800              LDR      r0,[r0,#0]  ; info_data_len
000014  b930              CBNZ     r0,|L14.36|
;;;443    			{
;;;444    	        // if there is no data then we must still acknoledge one packet
;;;445    	        make_tcphead(buf,1,0,1); // no options
000016  2301              MOVS     r3,#1
000018  2200              MOVS     r2,#0
00001a  4619              MOV      r1,r3
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       make_tcphead
000022  e006              B        |L14.50|
                  |L14.36|
;;;446    			}
;;;447    		else
;;;448    			{
;;;449    	        make_tcphead(buf,info_data_len,0,1); // no options
000024  2301              MOVS     r3,#1
000026  2200              MOVS     r2,#0
000028  480e              LDR      r0,|L14.100|
00002a  6801              LDR      r1,[r0,#0]  ; info_data_len
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       make_tcphead
                  |L14.50|
;;;450    			}
;;;451    	
;;;452    	// total length field in the IP header must be set:
;;;453    	// 20 bytes IP + 20 bytes tcp (when no options) 
;;;454    	j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
000032  2528              MOVS     r5,#0x28
;;;455    	buf[IP_TOTLEN_H_P]=j>>8;
000034  0a28              LSRS     r0,r5,#8
000036  7420              STRB     r0,[r4,#0x10]
;;;456    	buf[IP_TOTLEN_L_P]=j& 0xff;
000038  7465              STRB     r5,[r4,#0x11]
;;;457    	make_ip(buf);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       make_ip
;;;458    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;459    	j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
000040  2202              MOVS     r2,#2
000042  211c              MOVS     r1,#0x1c
000044  f104001a          ADD      r0,r4,#0x1a
000048  f7fffffe          BL       checksum
00004c  4605              MOV      r5,r0
;;;460    	buf[TCP_CHECKSUM_H_P]=j>>8;
00004e  0a28              LSRS     r0,r5,#8
000050  f8840032          STRB     r0,[r4,#0x32]
;;;461    	buf[TCP_CHECKSUM_L_P]=j& 0xff;
000054  f8845033          STRB     r5,[r4,#0x33]
;;;462    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
000058  4621              MOV      r1,r4
00005a  2036              MOVS     r0,#0x36
00005c  f7fffffe          BL       enc28j60PacketSend
;;;463    	}
000060  bd70              POP      {r4-r6,pc}
;;;464    
                          ENDP

000062  0000              DCW      0x0000
                  |L14.100|
                          DCD      info_data_len

                          AREA ||i.make_tcp_ack_with_data||, CODE, READONLY, ALIGN=1

                  make_tcp_ack_with_data PROC
;;;469    // length and checksum
;;;470    void make_tcp_ack_with_data(unsigned char *buf,unsigned  int dlen)
000000  b570              PUSH     {r4-r6,lr}
;;;471    	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;472    	unsigned  int j;
;;;473    	// fill the header:
;;;474    	// This code requires that we send only one data packet
;;;475    	// because we keep no state information. We must therefore set
;;;476    	// the fin here:
;;;477    	buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
000006  2019              MOVS     r0,#0x19
000008  f884002f          STRB     r0,[r4,#0x2f]
;;;478    	
;;;479    	// total length field in the IP header must be set:
;;;480    	// 20 bytes IP + 20 bytes tcp (when no options) + len of data
;;;481    	j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
00000c  f1050628          ADD      r6,r5,#0x28
;;;482    	buf[IP_TOTLEN_H_P]=j>>8;
000010  0a30              LSRS     r0,r6,#8
000012  7420              STRB     r0,[r4,#0x10]
;;;483    	buf[IP_TOTLEN_L_P]=j& 0xff;
000014  7466              STRB     r6,[r4,#0x11]
;;;484    	fill_ip_hdr_checksum(buf);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       fill_ip_hdr_checksum
;;;485    	// zero the checksum
;;;486    	buf[TCP_CHECKSUM_H_P]=0;
00001c  2000              MOVS     r0,#0
00001e  f8840032          STRB     r0,[r4,#0x32]
;;;487    	buf[TCP_CHECKSUM_L_P]=0;
000022  f8840033          STRB     r0,[r4,#0x33]
;;;488    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;489    	j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
000026  f105011c          ADD      r1,r5,#0x1c
00002a  2202              MOVS     r2,#2
00002c  f104001a          ADD      r0,r4,#0x1a
000030  f7fffffe          BL       checksum
000034  4606              MOV      r6,r0
;;;490    	buf[TCP_CHECKSUM_H_P]=j>>8;
000036  0a30              LSRS     r0,r6,#8
000038  f8840032          STRB     r0,[r4,#0x32]
;;;491    	buf[TCP_CHECKSUM_L_P]=j& 0xff;
00003c  f8846033          STRB     r6,[r4,#0x33]
;;;492    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
000040  f1050036          ADD      r0,r5,#0x36
000044  4621              MOV      r1,r4
000046  f7fffffe          BL       enc28j60PacketSend
;;;493    	}
00004a  bd70              POP      {r4-r6,pc}
;;;494    
                          ENDP


                          AREA ||i.make_tcp_synack_from_syn||, CODE, READONLY, ALIGN=1

                  make_tcp_synack_from_syn PROC
;;;352    
;;;353    void make_tcp_synack_from_syn(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;354    	{
000002  4604              MOV      r4,r0
;;;355    	unsigned  int ck;
;;;356    	make_eth(buf);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       make_eth
;;;357    	// total length field in the IP header must be set:
;;;358    	// 20 bytes IP + 24 bytes (20tcp+4tcp options)
;;;359    	buf[IP_TOTLEN_H_P]=0;
00000a  2000              MOVS     r0,#0
00000c  7420              STRB     r0,[r4,#0x10]
;;;360    	buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
00000e  202c              MOVS     r0,#0x2c
000010  7460              STRB     r0,[r4,#0x11]
;;;361    	make_ip(buf);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       make_ip
;;;362    	buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
000018  2012              MOVS     r0,#0x12
00001a  f884002f          STRB     r0,[r4,#0x2f]
;;;363    	make_tcphead(buf,1,1,0);
00001e  2300              MOVS     r3,#0
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       make_tcphead
;;;364    	// calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
;;;365    	ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
00002a  2202              MOVS     r2,#2
00002c  2120              MOVS     r1,#0x20
00002e  f104001a          ADD      r0,r4,#0x1a
000032  f7fffffe          BL       checksum
000036  4605              MOV      r5,r0
;;;366    	buf[TCP_CHECKSUM_H_P]=ck>>8;
000038  0a28              LSRS     r0,r5,#8
00003a  f8840032          STRB     r0,[r4,#0x32]
;;;367    	buf[TCP_CHECKSUM_L_P]=ck& 0xff;
00003e  f8845033          STRB     r5,[r4,#0x33]
;;;368    	// add 4 for option mss:
;;;369    	enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
000042  4621              MOV      r1,r4
000044  203a              MOVS     r0,#0x3a
000046  f7fffffe          BL       enc28j60PacketSend
;;;370    	}
00004a  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP


                          AREA ||i.make_tcphead||, CODE, READONLY, ALIGN=2

                  make_tcphead PROC
;;;202    // otherwise it is copied from the packet we received
;;;203    void make_tcphead(unsigned char *buf,unsigned  int rel_ack_num,unsigned char mss,unsigned char cp_seq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;204    	{
000002  460c              MOV      r4,r1
;;;205    	unsigned char i=0;
000004  2100              MOVS     r1,#0
;;;206    	unsigned char tseq;
;;;207    	while(i<2)
000006  e009              B        |L17.28|
                  |L17.8|
;;;208    		{
;;;209    	    buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
000008  f1010622          ADD      r6,r1,#0x22
00000c  5d87              LDRB     r7,[r0,r6]
00000e  1cb6              ADDS     r6,r6,#2
000010  5587              STRB     r7,[r0,r6]
;;;210    	    buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
000012  2700              MOVS     r7,#0
000014  1eb6              SUBS     r6,r6,#2
000016  5587              STRB     r7,[r0,r6]
;;;211    	    i++;
000018  1c4e              ADDS     r6,r1,#1
00001a  b2f1              UXTB     r1,r6
                  |L17.28|
00001c  2902              CMP      r1,#2                 ;207
00001e  dbf3              BLT      |L17.8|
;;;212    		}
;;;213    	// set source port  (http):
;;;214    	buf[TCP_SRC_PORT_L_P]=wwwport;
000020  4e20              LDR      r6,|L17.164|
000022  7836              LDRB     r6,[r6,#0]  ; wwwport
000024  f8806023          STRB     r6,[r0,#0x23]
;;;215    	i=4;
000028  2104              MOVS     r1,#4
;;;216    	// sequence numbers:
;;;217    	// add the rel ack num to SEQACK
;;;218    	while(i>0)
00002a  e012              B        |L17.82|
                  |L17.44|
;;;219    		{
;;;220    	    rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
00002c  f1010625          ADD      r6,r1,#0x25
000030  5d86              LDRB     r6,[r0,r6]
000032  4434              ADD      r4,r4,r6
;;;221    	    tseq=buf[TCP_SEQACK_H_P+i-1];
000034  f1010629          ADD      r6,r1,#0x29
000038  5d85              LDRB     r5,[r0,r6]
;;;222    	    buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
00003a  5584              STRB     r4,[r0,r6]
;;;223    	    if (cp_seq)
00003c  b113              CBZ      r3,|L17.68|
;;;224    				{
;;;225    		        // copy the acknum sent to us into the sequence number
;;;226    		        buf[TCP_SEQ_H_P+i-1]=tseq;
00003e  1f36              SUBS     r6,r6,#4
000040  5585              STRB     r5,[r0,r6]
000042  e003              B        |L17.76|
                  |L17.68|
;;;227    		    	}
;;;228    			else
;;;229    				{
;;;230    	            buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
000044  2700              MOVS     r7,#0
000046  f1010625          ADD      r6,r1,#0x25
00004a  5587              STRB     r7,[r0,r6]
                  |L17.76|
;;;231    	    		}
;;;232    	    rel_ack_num=rel_ack_num>>8;
00004c  0a24              LSRS     r4,r4,#8
;;;233    	    i--;
00004e  1e4e              SUBS     r6,r1,#1
000050  b2f1              UXTB     r1,r6
                  |L17.82|
000052  2900              CMP      r1,#0                 ;218
000054  dcea              BGT      |L17.44|
;;;234    		}
;;;235    	if (cp_seq==0)
000056  b973              CBNZ     r3,|L17.118|
;;;236    		{
;;;237    	    // put inital seq number
;;;238    	    buf[TCP_SEQ_H_P+0]= 0;
000058  2600              MOVS     r6,#0
00005a  f8006f26          STRB     r6,[r0,#0x26]!
;;;239    	    buf[TCP_SEQ_H_P+1]= 0;
00005e  7046              STRB     r6,[r0,#1]
;;;240    	    // we step only the second byte, this allows us to send packts 
;;;241    	    // with 255 bytes or 512 (if we step the initial seqnum by 2)
;;;242    	    buf[TCP_SEQ_H_P+2]= seqnum; 
000060  4e11              LDR      r6,|L17.168|
000062  7836              LDRB     r6,[r6,#0]  ; seqnum
000064  7086              STRB     r6,[r0,#2]
;;;243    	    buf[TCP_SEQ_H_P+3]= 0;
000066  2600              MOVS     r6,#0
000068  70c6              STRB     r6,[r0,#3]
00006a  3826              SUBS     r0,r0,#0x26
;;;244    	    // step the inititial seq num by something we will not use
;;;245    	    // during this tcp session:
;;;246    	    seqnum+=2;
00006c  4e0e              LDR      r6,|L17.168|
00006e  7836              LDRB     r6,[r6,#0]  ; seqnum
000070  1cb6              ADDS     r6,r6,#2
000072  4f0d              LDR      r7,|L17.168|
000074  703e              STRB     r6,[r7,#0]
                  |L17.118|
;;;247    		}
;;;248    	// zero the checksum
;;;249    	buf[TCP_CHECKSUM_H_P]=0;
000076  2600              MOVS     r6,#0
000078  f8806032          STRB     r6,[r0,#0x32]
;;;250    	buf[TCP_CHECKSUM_L_P]=0;
00007c  f8806033          STRB     r6,[r0,#0x33]
;;;251    	
;;;252    	// The tcp header length is only a 4 bit field (the upper 4 bits).
;;;253    	// It is calculated in units of 4 bytes. 
;;;254    	// E.g 24 bytes: 24/4=6 => 0x60=header len field
;;;255    	//buf[TCP_HEADER_LEN_P]=(((TCP_HEADER_LEN_PLAIN+4)/4)) <<4; // 0x60
;;;256    	if (mss)
000080  b162              CBZ      r2,|L17.156|
;;;257    			{
;;;258    		    // the only option we set is MSS to 1408:
;;;259    		    // 1408 in hex is 0x580
;;;260    		    buf[TCP_OPTIONS_P]=2;
000082  2602              MOVS     r6,#2
000084  302e              ADDS     r0,r0,#0x2e
000086  7206              STRB     r6,[r0,#8]
;;;261    		    buf[TCP_OPTIONS_P+1]=4;
000088  2604              MOVS     r6,#4
00008a  7246              STRB     r6,[r0,#9]
;;;262    		    buf[TCP_OPTIONS_P+2]=0x05; 
00008c  2605              MOVS     r6,#5
00008e  7286              STRB     r6,[r0,#0xa]
;;;263    		    buf[TCP_OPTIONS_P+3]=0x80;
000090  2680              MOVS     r6,#0x80
000092  72c6              STRB     r6,[r0,#0xb]
;;;264    		    // 24 bytes:
;;;265    		    buf[TCP_HEADER_LEN_P]=0x60;
000094  2660              MOVS     r6,#0x60
000096  f800692e          STRB     r6,[r0],#-0x2e
00009a  e002              B        |L17.162|
                  |L17.156|
;;;266    			}
;;;267    		else
;;;268    			{
;;;269    		    // no options:
;;;270    		    // 20 bytes:
;;;271    		    buf[TCP_HEADER_LEN_P]=0x50;
00009c  2650              MOVS     r6,#0x50
00009e  f880602e          STRB     r6,[r0,#0x2e]
                  |L17.162|
;;;272    			}
;;;273    	}
0000a2  bdf0              POP      {r4-r7,pc}
;;;274    
                          ENDP

                  |L17.164|
                          DCD      wwwport
                  |L17.168|
                          DCD      seqnum

                          AREA ||i.make_udp_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_udp_reply_from_request PROC
;;;316    // you can send a max of 220 bytes of data
;;;317    void make_udp_reply_from_request(unsigned char *buf,char *data,unsigned int datalen,unsigned  int port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;318    	{
000004  4604              MOV      r4,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;319    	unsigned int i=0;
00000c  2600              MOVS     r6,#0
;;;320    	unsigned  int ck;
;;;321    	make_eth(buf);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       make_eth
;;;322    	//if (datalen>220)
;;;323    	//	{
;;;324    	//    datalen=220;
;;;325    	//	}
;;;326    	
;;;327    	// total length field in the IP header must be set:
;;;328    	i= IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
000014  f105061c          ADD      r6,r5,#0x1c
;;;329    	buf[IP_TOTLEN_H_P]=i>>8;
000018  0a30              LSRS     r0,r6,#8
00001a  7420              STRB     r0,[r4,#0x10]
;;;330    	buf[IP_TOTLEN_L_P]=i;
00001c  7466              STRB     r6,[r4,#0x11]
;;;331    	make_ip(buf);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       make_ip
;;;332    	buf[UDP_DST_PORT_H_P]=port>>8;
000024  0a38              LSRS     r0,r7,#8
000026  f8040f24          STRB     r0,[r4,#0x24]!
;;;333    	buf[UDP_DST_PORT_L_P]=port & 0xff;
00002a  7067              STRB     r7,[r4,#1]
;;;334    	// source port does not matter and is what the sender used.
;;;335    	// calculte the udp length:
;;;336    	buf[UDP_LEN_H_P]=datalen>>8;
00002c  0a28              LSRS     r0,r5,#8
00002e  70a0              STRB     r0,[r4,#2]
;;;337    	buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
000030  f1050008          ADD      r0,r5,#8
000034  70e0              STRB     r0,[r4,#3]
;;;338    	// zero the checksum
;;;339    	buf[UDP_CHECKSUM_H_P]=0;
000036  2000              MOVS     r0,#0
000038  7120              STRB     r0,[r4,#4]
;;;340    	buf[UDP_CHECKSUM_L_P]=0;
00003a  7160              STRB     r0,[r4,#5]
00003c  3c24              SUBS     r4,r4,#0x24
;;;341    	// copy the data:
;;;342    	while(i<datalen)
00003e  e005              B        |L18.76|
                  |L18.64|
;;;343    		{
;;;344            buf[UDP_DATA_P+i]=data[i];
000040  f8191006          LDRB     r1,[r9,r6]
000044  f106002a          ADD      r0,r6,#0x2a
000048  5421              STRB     r1,[r4,r0]
;;;345            i++;
00004a  1c76              ADDS     r6,r6,#1
                  |L18.76|
00004c  42ae              CMP      r6,r5                 ;342
00004e  d3f7              BCC      |L18.64|
;;;346    		}
;;;347    	ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
000050  f1050110          ADD      r1,r5,#0x10
000054  2201              MOVS     r2,#1
000056  f104001a          ADD      r0,r4,#0x1a
00005a  f7fffffe          BL       checksum
00005e  4680              MOV      r8,r0
;;;348    	buf[UDP_CHECKSUM_H_P]=ck>>8;
000060  ea4f2018          LSR      r0,r8,#8
000064  f8840028          STRB     r0,[r4,#0x28]
;;;349    	buf[UDP_CHECKSUM_L_P]=ck& 0xff;
000068  f8848029          STRB     r8,[r4,#0x29]
;;;350    	enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
00006c  f105002a          ADD      r0,r5,#0x2a
000070  4621              MOV      r1,r4
000072  f7fffffe          BL       enc28j60PacketSend
;;;351    	}
000076  e8bd87f0          POP      {r4-r10,pc}
;;;352    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  wwwport
000000  8d                DCB      0x8d
                  macaddr
000001  000000            DCB      0x00,0x00,0x00
000004  000000            DCB      0x00,0x00,0x00
                  ipaddr
000007  00                DCB      0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  info_hdr_len
                          DCD      0x00000000
                  info_data_len
                          DCD      0x00000000
                  seqnum
000014  0a                DCB      0x0a
