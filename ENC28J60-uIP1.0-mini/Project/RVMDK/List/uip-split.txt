; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uip-split.o --asm_dir=.\List\ --list_dir=.\List\ --depend=.\obj\uip-split.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\CMSIS\Core\CM3 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Source\inc -I..\..\Libraries\uIP-1.0\apps\webserver -I..\..\Libraries\uIP-1.0\uip -I..\..\Source\src\uIP_enc28j60 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\uip-split.crf ..\..\Libraries\uIP-1.0\uip\uip-split.c]
                          THUMB

                          AREA ||i.uip_split_output||, CODE, READONLY, ALIGN=2

                  uip_split_output PROC
;;;48     void
;;;49     uip_split_output(void)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
;;;51       u16_t tcplen, len1, len2;
;;;52     
;;;53       /* We only try to split maximum sized TCP segments. */
;;;54       if(BUF->proto == UIP_PROTO_TCP &&
000002  483e              LDR      r0,|L1.252|
000004  7dc0              LDRB     r0,[r0,#0x17]
000006  2806              CMP      r0,#6
000008  d174              BNE      |L1.244|
;;;55          uip_len == UIP_BUFSIZE - UIP_LLH_LEN) {
00000a  483d              LDR      r0,|L1.256|
00000c  8800              LDRH     r0,[r0,#0]  ; uip_len
00000e  f64071f2          MOV      r1,#0xff2
000012  4288              CMP      r0,r1
000014  d16e              BNE      |L1.244|
;;;56     
;;;57         tcplen = uip_len - UIP_TCPIP_HLEN;
000016  483a              LDR      r0,|L1.256|
000018  8800              LDRH     r0,[r0,#0]  ; uip_len
00001a  3828              SUBS     r0,r0,#0x28
00001c  b286              UXTH     r6,r0
;;;58         /* Split the segment in two. If the original packet length was
;;;59            odd, we make the second packet one byte larger. */
;;;60         len1 = len2 = tcplen / 2;
00001e  4630              MOV      r0,r6
000020  eb0671d0          ADD      r1,r6,r0,LSR #31
000024  104c              ASRS     r4,r1,#1
000026  4625              MOV      r5,r4
;;;61         if(len1 + len2 < tcplen) {
000028  1960              ADDS     r0,r4,r5
00002a  42b0              CMP      r0,r6
00002c  da01              BGE      |L1.50|
;;;62           ++len2;
00002e  1c68              ADDS     r0,r5,#1
000030  b285              UXTH     r5,r0
                  |L1.50|
;;;63         }
;;;64     
;;;65         /* Create the first packet. This is done by altering the length
;;;66            field of the IP header and updating the checksums. */
;;;67         uip_len = len1 + UIP_TCPIP_HLEN;
000032  f1040028          ADD      r0,r4,#0x28
000036  4932              LDR      r1,|L1.256|
000038  8008              STRH     r0,[r1,#0]
;;;68     #if UIP_CONF_IPV6
;;;69         /* For IPv6, the IP length field does not include the IPv6 IP header
;;;70            length. */
;;;71         BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;72         BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;73     #else /* UIP_CONF_IPV6 */
;;;74         BUF->len[0] = uip_len >> 8;
00003a  4608              MOV      r0,r1
00003c  8800              LDRH     r0,[r0,#0]  ; uip_len
00003e  1201              ASRS     r1,r0,#8
000040  482e              LDR      r0,|L1.252|
000042  7401              STRB     r1,[r0,#0x10]
;;;75         BUF->len[1] = uip_len & 0xff;
000044  482e              LDR      r0,|L1.256|
000046  7801              LDRB     r1,[r0,#0]  ; uip_len
000048  482c              LDR      r0,|L1.252|
00004a  7441              STRB     r1,[r0,#0x11]
;;;76     #endif /* UIP_CONF_IPV6 */
;;;77     
;;;78         /* Recalculate the TCP checksum. */
;;;79         BUF->tcpchksum = 0;
00004c  2100              MOVS     r1,#0
00004e  8641              STRH     r1,[r0,#0x32]
;;;80         BUF->tcpchksum = ~(uip_tcpchksum());
000050  f7fffffe          BL       uip_tcpchksum
000054  43c0              MVNS     r0,r0
000056  b281              UXTH     r1,r0
000058  4828              LDR      r0,|L1.252|
00005a  8641              STRH     r1,[r0,#0x32]
;;;81     
;;;82     #if !UIP_CONF_IPV6
;;;83         /* Recalculate the IP checksum. */
;;;84         BUF->ipchksum = 0;
00005c  2100              MOVS     r1,#0
00005e  8301              STRH     r1,[r0,#0x18]
;;;85         BUF->ipchksum = ~(uip_ipchksum());
000060  f7fffffe          BL       uip_ipchksum
000064  43c0              MVNS     r0,r0
000066  b281              UXTH     r1,r0
000068  4824              LDR      r0,|L1.252|
00006a  8301              STRH     r1,[r0,#0x18]
;;;86     #endif /* UIP_CONF_IPV6 */
;;;87     
;;;88         /* Transmit the first packet. */
;;;89         uip_fw_output(); /* fd */
00006c  f7fffffe          BL       uip_fw_output
;;;90         //tcpip_output();
;;;91     
;;;92         /* Now, create the second packet. To do this, it is not enough to
;;;93            just alter the length field, but we must also update the TCP
;;;94            sequence number and point the uip_appdata to a new place in
;;;95            memory. This place is detemined by the length of the first
;;;96            packet (len1). */
;;;97         uip_len = len2 + UIP_TCPIP_HLEN;
000070  f1050028          ADD      r0,r5,#0x28
000074  4922              LDR      r1,|L1.256|
000076  8008              STRH     r0,[r1,#0]
;;;98     #if UIP_CONF_IPV6
;;;99         /* For IPv6, the IP length field does not include the IPv6 IP header
;;;100           length. */
;;;101        BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;102        BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;103    #else /* UIP_CONF_IPV6 */
;;;104        BUF->len[0] = uip_len >> 8;
000078  4608              MOV      r0,r1
00007a  8800              LDRH     r0,[r0,#0]  ; uip_len
00007c  1201              ASRS     r1,r0,#8
00007e  481f              LDR      r0,|L1.252|
000080  7401              STRB     r1,[r0,#0x10]
;;;105        BUF->len[1] = uip_len & 0xff;
000082  481f              LDR      r0,|L1.256|
000084  7801              LDRB     r1,[r0,#0]  ; uip_len
000086  481d              LDR      r0,|L1.252|
000088  7441              STRB     r1,[r0,#0x11]
;;;106    #endif /* UIP_CONF_IPV6 */
;;;107    
;;;108        /*    uip_appdata += len1;*/
;;;109        memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
00008a  481e              LDR      r0,|L1.260|
00008c  6800              LDR      r0,[r0,#0]  ; uip_appdata
00008e  1901              ADDS     r1,r0,r4
000090  462a              MOV      r2,r5
000092  481c              LDR      r0,|L1.260|
000094  6800              LDR      r0,[r0,#0]  ; uip_appdata
000096  f7fffffe          BL       __aeabi_memcpy
;;;110    
;;;111        uip_add32(BUF->seqno, len1);
00009a  4621              MOV      r1,r4
00009c  4817              LDR      r0,|L1.252|
00009e  3026              ADDS     r0,r0,#0x26
0000a0  f7fffffe          BL       uip_add32
;;;112        BUF->seqno[0] = uip_acc32[0];
0000a4  4818              LDR      r0,|L1.264|
0000a6  7801              LDRB     r1,[r0,#0]  ; uip_acc32
0000a8  4814              LDR      r0,|L1.252|
0000aa  f8801026          STRB     r1,[r0,#0x26]
;;;113        BUF->seqno[1] = uip_acc32[1];
0000ae  4816              LDR      r0,|L1.264|
0000b0  7841              LDRB     r1,[r0,#1]  ; uip_acc32
0000b2  4812              LDR      r0,|L1.252|
0000b4  f8801027          STRB     r1,[r0,#0x27]
;;;114        BUF->seqno[2] = uip_acc32[2];
0000b8  4813              LDR      r0,|L1.264|
0000ba  7881              LDRB     r1,[r0,#2]  ; uip_acc32
0000bc  480f              LDR      r0,|L1.252|
0000be  f8801028          STRB     r1,[r0,#0x28]
;;;115        BUF->seqno[3] = uip_acc32[3];
0000c2  4811              LDR      r0,|L1.264|
0000c4  78c1              LDRB     r1,[r0,#3]  ; uip_acc32
0000c6  480d              LDR      r0,|L1.252|
0000c8  f8801029          STRB     r1,[r0,#0x29]
;;;116    
;;;117        /* Recalculate the TCP checksum. */
;;;118        BUF->tcpchksum = 0;
0000cc  2100              MOVS     r1,#0
0000ce  8641              STRH     r1,[r0,#0x32]
;;;119        BUF->tcpchksum = ~(uip_tcpchksum());
0000d0  f7fffffe          BL       uip_tcpchksum
0000d4  43c0              MVNS     r0,r0
0000d6  b281              UXTH     r1,r0
0000d8  4808              LDR      r0,|L1.252|
0000da  8641              STRH     r1,[r0,#0x32]
;;;120    
;;;121    #if !UIP_CONF_IPV6
;;;122        /* Recalculate the IP checksum. */
;;;123        BUF->ipchksum = 0;
0000dc  2100              MOVS     r1,#0
0000de  8301              STRH     r1,[r0,#0x18]
;;;124        BUF->ipchksum = ~(uip_ipchksum());
0000e0  f7fffffe          BL       uip_ipchksum
0000e4  43c0              MVNS     r0,r0
0000e6  b281              UXTH     r1,r0
0000e8  4804              LDR      r0,|L1.252|
0000ea  8301              STRH     r1,[r0,#0x18]
;;;125    #endif /* UIP_CONF_IPV6 */
;;;126    
;;;127        /* Transmit the second packet. */
;;;128        uip_fw_output(); /* fd*/
0000ec  f7fffffe          BL       uip_fw_output
0000f0  e002              B        |L1.248|
0000f2  e7ff              B        |L1.244|
                  |L1.244|
;;;129        /* tcpip_output(); */
;;;130      } else {
;;;131        uip_fw_output();  /* fd */
0000f4  f7fffffe          BL       uip_fw_output
                  |L1.248|
;;;132        /* tcpip_output(); */
;;;133      }
;;;134    
;;;135    }
0000f8  bd70              POP      {r4-r6,pc}
;;;136    /*-----------------------------------------------------------------------------*/
                          ENDP

0000fa  0000              DCW      0x0000
                  |L1.252|
                          DCD      uip_buf
                  |L1.256|
                          DCD      uip_len
                  |L1.260|
                          DCD      uip_appdata
                  |L1.264|
                          DCD      uip_acc32
