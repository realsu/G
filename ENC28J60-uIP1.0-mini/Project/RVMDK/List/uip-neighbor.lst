L 1 "..\..\Libraries\uIP-1.0\uip\uip-neighbor.c"
N/*
N * Copyright (c) 2006, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * $Id: uip-neighbor.c,v 1.2 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \file
N *         Database of link-local neighbors, used by IPv6 code and
N *         to be used by a future ARP code rewrite.
N * \author
N *         Adam Dunkels <adam@sics.se>
N */
N
N#include "uip-neighbor.h"
L 1 "..\..\Libraries\uIP-1.0\uip\uip-neighbor.h" 1
N/*
N * Copyright (c) 2006, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * $Id: uip-neighbor.h,v 1.2 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \file
N *         Header file for database of link-local neighbors, used by
N *         IPv6 code and to be used by future ARP code.
N * \author
N *         Adam Dunkels <adam@sics.se>
N */
N
N#ifndef __UIP_NEIGHBOR_H__
N#define __UIP_NEIGHBOR_H__
N
N#include "uip.h"
L 1 "..\..\Libraries\uIP-1.0\uip\uip.h" 1
N
N/**
N * \addtogroup uip
N * @{
N */
N
N/**
N * \file
N * Header file for the uIP TCP/IP stack.
N * \author Adam Dunkels <adam@dunkels.com>
N *
N * The uIP TCP/IP stack header file contains definitions for a number
N * of C macros that are used by uIP programs as well as internal uIP
N * structures, TCP/IP header structures and function declarations.
N *
N */
N
N
N/*
N * Copyright (c) 2001-2003, Adam Dunkels.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote
N *    products derived from this software without specific prior
N *    written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
N * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack.
N *
N * $Id: uip.h,v 1.40 2006/06/08 07:12:07 adam Exp $
N *
N */
N
N#ifndef __UIP_H__
N#define __UIP_H__
N
N#include "uipopt.h"
L 1 "..\..\Libraries\uIP-1.0\uip\uipopt.h" 1
N/**
N * \defgroup uipopt Configuration options for uIP
N * @{
N *
N * uIP is configured using the per-project configuration file
N * uipopt.h. This file contains all compile-time options for uIP and
N * should be tweaked to match each specific project. The uIP
N * distribution contains a documented example "uipopt.h" that can be
N * copied and modified for each project.
N *
N * \note Most of the configuration options in the uipopt.h should not
N * be changed, but rather the per-project uip-conf.h file.
N */
N
N/**
N * \file
N * Configuration options for uIP.
N * \author Adam Dunkels <adam@dunkels.com>
N *
N * This file is used for tweaking various configuration options for
N * uIP. You should make a copy of this file into one of your project's
N * directories instead of editing this example "uipopt.h" file that
N * comes with the uIP distribution.
N */
N
N/*
N * Copyright (c) 2001-2003, Adam Dunkels.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote
N *    products derived from this software without specific prior
N *    written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
N * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack.
N *
N * $Id: uipopt.h,v 1.4 2006/06/12 08:00:31 adam Exp $
N *
N */
N
N#ifndef __UIPOPT_H__
N#define __UIPOPT_H__
N
N#ifndef UIP_LITTLE_ENDIAN
N#define UIP_LITTLE_ENDIAN  3412
N#endif /* UIP_LITTLE_ENDIAN */
N#ifndef UIP_BIG_ENDIAN
N#define UIP_BIG_ENDIAN     1234
N#endif /* UIP_BIG_ENDIAN */
N
N#include "uip-conf.h"
L 1 "..\..\Source\src\uIP_enc28j60\uip-conf.h" 1
N/**
N * \addtogroup uipopt
N * @{
N */
N
N/**
N * \name Project-specific configuration options
N * @{
N *
N * uIP has a number of configuration options that can be overridden
N * for each project. These are kept in a project-specific uip-conf.h
N * file and all configuration names have the prefix UIP_CONF.
N */
N
N/*
N * Copyright (c) 2006, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * $Id: uip-conf.h,v 1.6 2006/06/12 08:00:31 adam Exp $
N */
N
N/**
N * \file
N *         An example uIP configuration file
N * \author
N *         Adam Dunkels <adam@sics.se>
N */
N
N#ifndef __UIP_CONF_H__
N#define __UIP_CONF_H__
N
N#include <inttypes.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\inttypes.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180113 $
N * Checkin $Date: 2013-05-22 14:27:44 +0100 (Wed, 22 May 2013) $
N * Revising $Author: agrant $
N */
N
N/* Based on WG14/N843 (C9X) Committee Draft August 3, 1998 */
N
N#ifndef __inttypes_h
N#define __inttypes_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#include <stdint.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 180721 $
N * Checkin $Date: 2013-06-24 09:41:57 +0100 (Mon, 24 Jun 2013) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5040049
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 20 "D:\Keil_v5\ARM\ARMCC\bin\..\include\inttypes.h" 2
N
N#if !defined(__cplusplus) || defined(__STDC_FORMAT_MACROS)
X#if !0L || 0L
N
N    /* 7.8.1 */
N
N#define PRId8         "d"
N#define PRId16        "d"
N#define PRId32        "d"
N#define PRId64      "lld"
N#define PRIdLEAST8    "d"
N#define PRIdLEAST16   "d"
N#define PRIdLEAST32   "d"
N#define PRIdLEAST64 "lld"
N#define PRIdFAST8     "d"
N#define PRIdFAST16    "d"
N#define PRIdFAST32    "d"
N#define PRIdFAST64  "lld"
N#define PRIdMAX      "jd"
N#define PRIdPTR       "d"
N
N#define PRIi8         "i"
N#define PRIi16        "i"
N#define PRIi32        "i"
N#define PRIi64      "lli"
N#define PRIiLEAST8    "i"
N#define PRIiLEAST16   "i"
N#define PRIiLEAST32   "i"
N#define PRIiLEAST64 "lli"
N#define PRIiFAST8     "i"
N#define PRIiFAST16    "i"
N#define PRIiFAST32    "i"
N#define PRIiFAST64  "lli"
N#define PRIiMAX      "ji"
N#define PRIiPTR       "i"
N
N#define PRIo8         "o"
N#define PRIo16        "o"
N#define PRIo32        "o"
N#define PRIo64      "llo"
N#define PRIoLEAST8    "o"
N#define PRIoLEAST16   "o"
N#define PRIoLEAST32   "o"
N#define PRIoLEAST64 "llo"
N#define PRIoFAST8     "o"
N#define PRIoFAST16    "o"
N#define PRIoFAST32    "o"
N#define PRIoFAST64  "llo"
N#define PRIoMAX      "jo"
N#define PRIoPTR       "o"
N
N#define PRIu8         "d"
N#define PRIu16        "d"
N#define PRIu32        "u"
N#define PRIu64      "llu"
N#define PRIuLEAST8    "d"
N#define PRIuLEAST16   "d"
N#define PRIuLEAST32   "u"
N#define PRIuLEAST64 "llu"
N#define PRIuFAST8     "u"
N#define PRIuFAST16    "u"
N#define PRIuFAST32    "u"
N#define PRIuFAST64  "llu"
N#define PRIuMAX      "ju"
N#define PRIuPTR       "u"
N
N#define PRIx8         "x"
N#define PRIx16        "x"
N#define PRIx32        "x"
N#define PRIx64      "llx"
N#define PRIxLEAST8    "x"
N#define PRIxLEAST16   "x"
N#define PRIxLEAST32   "x"
N#define PRIxLEAST64 "llx"
N#define PRIxFAST8     "x"
N#define PRIxFAST16    "x"
N#define PRIxFAST32    "x"
N#define PRIxFAST64  "llx"
N#define PRIxMAX      "jx"
N#define PRIxPTR       "x"
N
N#define PRIX8         "X"
N#define PRIX16        "X"
N#define PRIX32        "X"
N#define PRIX64      "llX"
N#define PRIXLEAST8    "X"
N#define PRIXLEAST16   "X"
N#define PRIXLEAST32   "X"
N#define PRIXLEAST64 "llX"
N#define PRIXFAST8     "X"
N#define PRIXFAST16    "X"
N#define PRIXFAST32    "X"
N#define PRIXFAST64  "llX"
N#define PRIXMAX      "jX"
N#define PRIXPTR       "X"
N
N#define SCNd8       "hhd"
N#define SCNd16       "hd"
N#define SCNd32        "d"
N#define SCNd64      "lld"
N#define SCNdLEAST8  "hhd"
N#define SCNdLEAST16  "hd"
N#define SCNdLEAST32   "d"
N#define SCNdLEAST64 "lld"
N#define SCNdFAST8     "d"
N#define SCNdFAST16    "d"
N#define SCNdFAST32    "d"
N#define SCNdFAST64  "lld"
N#define SCNdMAX      "jd"
N#define SCNdPTR       "d"
N
N#define SCNi8       "hhd"
N#define SCNi16       "hi"
N#define SCNi32        "i"
N#define SCNi64      "lli"
N#define SCNiLEAST8  "hhi"
N#define SCNiLEAST16  "hi"
N#define SCNiLEAST32   "i"
N#define SCNiLEAST64 "lli"
N#define SCNiFAST8     "i"
N#define SCNiFAST16    "i"
N#define SCNiFAST32    "i"
N#define SCNiFAST64  "lli"
N#define SCNiMAX      "ji"
N#define SCNiPTR       "i"
N
N#define SCNo8       "hho"
N#define SCNo16       "ho"
N#define SCNo32        "o"
N#define SCNo64      "llo"
N#define SCNoLEAST8  "hho"
N#define SCNoLEAST16  "ho"
N#define SCNoLEAST32   "o"
N#define SCNoLEAST64 "llo"
N#define SCNoFAST8     "o"
N#define SCNoFAST16    "o"
N#define SCNoFAST32    "o"
N#define SCNoFAST64  "llo"
N#define SCNoMAX      "jo"
N#define SCNoPTR       "o"
N
N#define SCNu8       "hhu"
N#define SCNu16       "hu"
N#define SCNu32        "u"
N#define SCNu64      "llu"
N#define SCNuLEAST8  "hhu"
N#define SCNuLEAST16  "hu"
N#define SCNuLEAST32   "u"
N#define SCNuLEAST64 "llu"
N#define SCNuFAST8     "u"
N#define SCNuFAST16    "u"
N#define SCNuFAST32    "u"
N#define SCNuFAST64  "llu"
N#define SCNuMAX      "ju"
N#define SCNuPTR       "u"
N
N#define SCNx8       "hhx"
N#define SCNx16       "hx"
N#define SCNx32        "x"
N#define SCNx64      "llx"
N#define SCNxLEAST8  "hhx"
N#define SCNxLEAST16  "hx"
N#define SCNxLEAST32   "x"
N#define SCNxLEAST64 "llx"
N#define SCNxFAST8     "x"
N#define SCNxFAST16    "x"
N#define SCNxFAST32    "x"
N#define SCNxFAST64  "llx"
N#define SCNxMAX      "jx"
N#define SCNxPTR       "x"
N
N#endif /* __STDC_FORMAT_MACROS */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
N    #else
N      typedef unsigned short wchar_t; /* see <stddef.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* see <stddef.h> */
S    #else
S      typedef unsigned short wchar_t; /* see <stddef.h> */
S    #endif
N  #endif
N#endif
N
Ntypedef struct imaxdiv_t { intmax_t quot, rem; } imaxdiv_t;
N   /* type of the value returned by the imaxdiv function. */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N_ARMABI intmax_t strtoimax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t strtoimax(const char * __restrict  ,
N                   char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtol */
N_ARMABI uintmax_t strtoumax(const char * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t strtoumax(const char * __restrict  ,
N                    char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    /* as for strtoul */
N
N_ARMABI intmax_t wcstoimax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) intmax_t wcstoimax(const wchar_t * __restrict  ,
N                   wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N_ARMABI uintmax_t wcstoumax(const wchar_t * __restrict /*nptr*/,
X__declspec(__nothrow) uintmax_t wcstoumax(const wchar_t * __restrict  ,
N                    wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N
Nextern _ARMABI_PURE intmax_t imaxabs(intmax_t /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) intmax_t imaxabs(intmax_t  );
N   /*
N    * computes the absolute value of an intmax_t j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
Nextern _ARMABI_PURE imaxdiv_t imaxdiv(intmax_t /*numer*/, intmax_t /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) imaxdiv_t imaxdiv(intmax_t  , intmax_t  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type imaxdiv_t, comprising both the quotient and
N    *          the remainder. the structure shall contain the following
N    *          members, in either order.
N    *          intmax_t quot; intmax_t rem;
N    */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __inttypes_h */
N
N/* end of inttypes.h */
N
L 59 "..\..\Source\src\uIP_enc28j60\uip-conf.h" 2
N
N/**
N * 8 bit datatype
N *
N * This typedef defines the 8-bit type used throughout uIP.
N *
N * \hideinitializer
N */
Ntypedef uint8_t u8_t;
N
N/**
N * 16 bit datatype
N *
N * This typedef defines the 16-bit type used throughout uIP.
N *
N * \hideinitializer
N */
Ntypedef uint16_t u16_t;
N
N/**
N * Statistics datatype
N *
N * This typedef defines the dataype used for keeping statistics in
N * uIP.
N *
N * \hideinitializer
N */
Ntypedef unsigned short uip_stats_t;
N
N/**
N * Maximum number of TCP connections.
N *
N * \hideinitializer
N */
N#define UIP_CONF_MAX_CONNECTIONS 40
N
N/**
N * Maximum number of listening TCP ports.
N *
N * \hideinitializer
N */
N#define UIP_CONF_MAX_LISTENPORTS 40
N
N/**
N * uIP buffer size.
N *
N * \hideinitializer
N */
N//#define UIP_CONF_BUFFER_SIZE     420
N//#define UIP_CONF_BUFFER_SIZE     1500
N#define UIP_CONF_BUFFER_SIZE     4096
N
N/**
N * CPU byte order.
N *
N * \hideinitializer
N */
N
N//#define UIP_CONF_BYTE_ORDER      LITTLE_ENDIAN
N#define UIP_CONF_BYTE_ORDER  UIP_LITTLE_ENDIAN
N
N/**
N * Logging on or off
N *
N * \hideinitializer
N */
N#define UIP_CONF_LOGGING         1
N
N/**
N * UDP support on or off
N *
N * \hideinitializer
N */
N#define UIP_CONF_UDP             0
N
N/**
N * UDP checksums on or off
N *
N * \hideinitializer
N */
N#define UIP_CONF_UDP_CHECKSUMS   1
N
N//#define UIP_CONF_PINGADDRCONF   1
N
N/**
N * uIP statistics on or off
N *
N * \hideinitializer
N */
N#define UIP_CONF_STATISTICS      1
N
N/* Here we include the header file for the application(s) we use in
N   our project. */
N/*#include "smtp.h"*/
N/*#include "hello-world.h"*/
N/*#include "telnetd.h"*/
N//#include "webserver.h"
N/*#include "dhcpc.h"*/
N/*#include "resolv.h"*/
N/*#include "webclient.h"*/
N#include "tcp_demo.h"
L 1 "..\..\Source\inc\tcp_demo.h" 1
N
N
N#ifndef __TCP_DEMO_H__
N#define __TCP_DEMO_H__
N
N/* Since this file will be included by uip.h, we cannot include uip.h
N   here. But we might need to include uipopt.h if we need the u8_t and
N   u16_t datatypes. */
N#include "uipopt.h"
L 1 "..\..\Libraries\uIP-1.0\uip\uipopt.h" 1
N/**
N * \defgroup uipopt Configuration options for uIP
N * @{
N *
N * uIP is configured using the per-project configuration file
N * uipopt.h. This file contains all compile-time options for uIP and
N * should be tweaked to match each specific project. The uIP
N * distribution contains a documented example "uipopt.h" that can be
N * copied and modified for each project.
N *
N * \note Most of the configuration options in the uipopt.h should not
N * be changed, but rather the per-project uip-conf.h file.
N */
N
N/**
N * \file
N * Configuration options for uIP.
N * \author Adam Dunkels <adam@dunkels.com>
N *
N * This file is used for tweaking various configuration options for
N * uIP. You should make a copy of this file into one of your project's
N * directories instead of editing this example "uipopt.h" file that
N * comes with the uIP distribution.
N */
N
N/*
N * Copyright (c) 2001-2003, Adam Dunkels.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. The name of the author may not be used to endorse or promote
N *    products derived from this software without specific prior
N *    written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
N * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
N * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
N * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack.
N *
N * $Id: uipopt.h,v 1.4 2006/06/12 08:00:31 adam Exp $
N *
N */
N
N#ifndef __UIPOPT_H__
S#define __UIPOPT_H__
S
S#ifndef UIP_LITTLE_ENDIAN
S#define UIP_LITTLE_ENDIAN  3412
S#endif /* UIP_LITTLE_ENDIAN */
S#ifndef UIP_BIG_ENDIAN
S#define UIP_BIG_ENDIAN     1234
S#endif /* UIP_BIG_ENDIAN */
S
S#include "uip-conf.h"
S
S/*------------------------------------------------------------------------------*/
S
S/**
S * \name Static configuration options
S * @{
S *
S * These configuration options can be used for setting the IP address
S * settings statically, but only if UIP_FIXEDADDR is set to 1. The
S * configuration options for a specific node includes IP address,
S * netmask and default router as well as the Ethernet address. The
S * netmask, default router and Ethernet address are appliciable only
S * if uIP should be run over Ethernet.
S *
S * All of these should be changed to suit your project.
S*/
S
S/**
S * Determines if uIP should use a fixed IP address or not.
S *
S * If uIP should use a fixed IP address, the settings are set in the
S * uipopt.h file. If not, the macros uip_sethostaddr(),
S * uip_setdraddr() and uip_setnetmask() should be used instead.
S *
S * \hideinitializer
S */
S#define UIP_FIXEDADDR    0
S
S/**
S * Ping IP address asignment.
S *
S * uIP uses a "ping" packets for setting its own IP address if this
S * option is set. If so, uIP will start with an empty IP address and
S * the destination IP address of the first incoming "ping" (ICMP echo)
S * packet will be used for setting the hosts IP address.
S *
S * \note This works only if UIP_FIXEDADDR is 0.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_PINGADDRCONF
S#define UIP_PINGADDRCONF UIP_CONF_PINGADDRCONF
S#else /* UIP_CONF_PINGADDRCONF */
S#define UIP_PINGADDRCONF 0
S#endif /* UIP_CONF_PINGADDRCONF */
S
S
S/**
S * Specifies if the uIP ARP module should be compiled with a fixed
S * Ethernet MAC address or not.
S *
S * If this configuration option is 0, the macro uip_setethaddr() can
S * be used to specify the Ethernet address at run-time.
S *
S * \hideinitializer
S */
S#define UIP_FIXEDETHADDR 0
S
S/** @} */
S/*------------------------------------------------------------------------------*/
S/**
S * \name IP configuration options
S * @{
S *
S */
S/**
S * The IP TTL (time to live) of IP packets sent by uIP.
S *
S * This should normally not be changed.
S */
S#define UIP_TTL         64
S
S/**
S * Turn on support for IP packet reassembly.
S *
S * uIP supports reassembly of fragmented IP packets. This features
S * requires an additonal amount of RAM to hold the reassembly buffer
S * and the reassembly code size is approximately 700 bytes.  The
S * reassembly buffer is of the same size as the uip_buf buffer
S * (configured by UIP_BUFSIZE).
S *
S * \note IP packet reassembly is not heavily tested.
S *
S * \hideinitializer
S */
S#define UIP_REASSEMBLY 0
S
S/**
S * The maximum time an IP fragment should wait in the reassembly
S * buffer before it is dropped.
S *
S */
S#define UIP_REASS_MAXAGE 40
S
S/** @} */
S
S/*------------------------------------------------------------------------------*/
S/**
S * \name UDP configuration options
S * @{
S */
S
S/**
S * Toggles wether UDP support should be compiled in or not.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_UDP
S#define UIP_UDP UIP_CONF_UDP
S#else /* UIP_CONF_UDP */
S#define UIP_UDP           0
S#endif /* UIP_CONF_UDP */
S
S/**
S * Toggles if UDP checksums should be used or not.
S *
S * \note Support for UDP checksums is currently not included in uIP,
S * so this option has no function.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_UDP_CHECKSUMS
S#define UIP_UDP_CHECKSUMS UIP_CONF_UDP_CHECKSUMS
S#else
S#define UIP_UDP_CHECKSUMS 0
S#endif
S
S/**
S * The maximum amount of concurrent UDP connections.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_UDP_CONNS
S#define UIP_UDP_CONNS UIP_CONF_UDP_CONNS
S#else /* UIP_CONF_UDP_CONNS */
S#define UIP_UDP_CONNS    10
S#endif /* UIP_CONF_UDP_CONNS */
S
S/**
S * The name of the function that should be called when UDP datagrams arrive.
S *
S * \hideinitializer
S */
S
S
S/** @} */
S/*------------------------------------------------------------------------------*/
S/**
S * \name TCP configuration options
S * @{
S */
S
S/**
S * Determines if support for opening connections from uIP should be
S * compiled in.
S *
S * If the applications that are running on top of uIP for this project
S * do not need to open outgoing TCP connections, this configration
S * option can be turned off to reduce the code size of uIP.
S *
S * \hideinitializer
S */
S#define UIP_ACTIVE_OPEN 1
S
S/**
S * The maximum number of simultaneously open TCP connections.
S *
S * Since the TCP connections are statically allocated, turning this
S * configuration knob down results in less RAM used. Each TCP
S * connection requires approximatly 30 bytes of memory.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_MAX_CONNECTIONS
S#define UIP_CONNS       10
S#else /* UIP_CONF_MAX_CONNECTIONS */
S#define UIP_CONNS UIP_CONF_MAX_CONNECTIONS
S#endif /* UIP_CONF_MAX_CONNECTIONS */
S
S
S/**
S * The maximum number of simultaneously listening TCP ports.
S *
S * Each listening TCP port requires 2 bytes of memory.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_MAX_LISTENPORTS
S#define UIP_LISTENPORTS 20
S#else /* UIP_CONF_MAX_LISTENPORTS */
S#define UIP_LISTENPORTS UIP_CONF_MAX_LISTENPORTS
S#endif /* UIP_CONF_MAX_LISTENPORTS */
S
S/**
S * Determines if support for TCP urgent data notification should be
S * compiled in.
S *
S * Urgent data (out-of-band data) is a rarely used TCP feature that
S * very seldom would be required.
S *
S * \hideinitializer
S */
S#define UIP_URGDATA      0
S
S/**
S * The initial retransmission timeout counted in timer pulses.
S *
S * This should not be changed.
S */
S#define UIP_RTO         3
S
S/**
S * The maximum number of times a segment should be retransmitted
S * before the connection should be aborted.
S *
S * This should not be changed.
S */
S#define UIP_MAXRTX      8
S
S/**
S * The maximum number of times a SYN segment should be retransmitted
S * before a connection request should be deemed to have been
S * unsuccessful.
S *
S * This should not need to be changed.
S */
S#define UIP_MAXSYNRTX      5
S
S/**
S * The TCP maximum segment size.
S *
S * This is should not be to set to more than
S * UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN.
S */
S#define UIP_TCP_MSS     (UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN)
S
S/**
S * The size of the advertised receiver's window.
S *
S * Should be set low (i.e., to the size of the uip_buf buffer) is the
S * application is slow to process incoming data, or high (32768 bytes)
S * if the application processes data quickly.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_RECEIVE_WINDOW
S#define UIP_RECEIVE_WINDOW UIP_TCP_MSS
S#else
S#define UIP_RECEIVE_WINDOW UIP_CONF_RECEIVE_WINDOW
S#endif
S
S/**
S * How long a connection should stay in the TIME_WAIT state.
S *
S * This configiration option has no real implication, and it should be
S * left untouched.
S */
S#define UIP_TIME_WAIT_TIMEOUT 120
S
S
S/** @} */
S/*------------------------------------------------------------------------------*/
S/**
S * \name ARP configuration options
S * @{
S */
S
S/**
S * The size of the ARP table.
S *
S * This option should be set to a larger value if this uIP node will
S * have many connections from the local network.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_ARPTAB_SIZE
S#define UIP_ARPTAB_SIZE UIP_CONF_ARPTAB_SIZE
S#else
S#define UIP_ARPTAB_SIZE 8
S#endif
S
S/**
S * The maxium age of ARP table entries measured in 10ths of seconds.
S *
S * An UIP_ARP_MAXAGE of 120 corresponds to 20 minutes (BSD
S * default).
S */
S#define UIP_ARP_MAXAGE 120
S
S/** @} */
S
S/*------------------------------------------------------------------------------*/
S
S/**
S * \name General configuration options
S * @{
S */
S
S/**
S * The size of the uIP packet buffer.
S *
S * The uIP packet buffer should not be smaller than 60 bytes, and does
S * not need to be larger than 1500 bytes. Lower size results in lower
S * TCP throughput, larger size results in higher TCP throughput.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_BUFFER_SIZE
S#define UIP_BUFSIZE     400
S#else /* UIP_CONF_BUFFER_SIZE */
S#define UIP_BUFSIZE UIP_CONF_BUFFER_SIZE
S#endif /* UIP_CONF_BUFFER_SIZE */
S
S
S/**
S * Determines if statistics support should be compiled in.
S *
S * The statistics is useful for debugging and to show the user.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_STATISTICS
S#define UIP_STATISTICS  0
S#else /* UIP_CONF_STATISTICS */
S#define UIP_STATISTICS UIP_CONF_STATISTICS
S#endif /* UIP_CONF_STATISTICS */
S
S/**
S * Determines if logging of certain events should be compiled in.
S *
S * This is useful mostly for debugging. The function uip_log()
S * must be implemented to suit the architecture of the project, if
S * logging is turned on.
S *
S * \hideinitializer
S */
S#ifndef UIP_CONF_LOGGING
S#define UIP_LOGGING     0
S#else /* UIP_CONF_LOGGING */
S#define UIP_LOGGING     UIP_CONF_LOGGING
S#endif /* UIP_CONF_LOGGING */
S
S/**
S * Broadcast support.
S *
S * This flag configures IP broadcast support. This is useful only
S * together with UDP.
S *
S * \hideinitializer
S *
S */
S#ifndef UIP_CONF_BROADCAST
S#define UIP_BROADCAST 0
S#else /* UIP_CONF_BROADCAST */
S#define UIP_BROADCAST UIP_CONF_BROADCAST
S#endif /* UIP_CONF_BROADCAST */
S
S/**
S * Print out a uIP log message.
S *
S * This function must be implemented by the module that uses uIP, and
S * is called by uIP whenever a log message is generated.
S */
Svoid uip_log(char *msg);
S
S/**
S * The link level header length.
S *
S * This is the offset into the uip_buf where the IP header can be
S * found. For Ethernet, this should be set to 14. For SLIP, this
S * should be set to 0.
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_LLH_LEN
S#define UIP_LLH_LEN UIP_CONF_LLH_LEN
S#else /* UIP_CONF_LLH_LEN */
S#define UIP_LLH_LEN     14
S#endif /* UIP_CONF_LLH_LEN */
S
S/** @} */
S/*------------------------------------------------------------------------------*/
S/**
S * \name CPU architecture configuration
S * @{
S *
S * The CPU architecture configuration is where the endianess of the
S * CPU on which uIP is to be run is specified. Most CPUs today are
S * little endian, and the most notable exception are the Motorolas
S * which are big endian. The BYTE_ORDER macro should be changed to
S * reflect the CPU architecture on which uIP is to be run.
S */
S
S/**
S * The byte order of the CPU architecture on which uIP is to be run.
S *
S * This option can be either BIG_ENDIAN (Motorola byte order) or
S * LITTLE_ENDIAN (Intel byte order).
S *
S * \hideinitializer
S */
S#ifdef UIP_CONF_BYTE_ORDER
S#define UIP_BYTE_ORDER     UIP_CONF_BYTE_ORDER
S#else /* UIP_CONF_BYTE_ORDER */
S#define UIP_BYTE_ORDER     UIP_LITTLE_ENDIAN
S#endif /* UIP_CONF_BYTE_ORDER */
S
S/** @} */
S/*------------------------------------------------------------------------------*/
S
S/**
S * \name Appication specific configurations
S * @{
S *
S * An uIP application is implemented using a single application
S * function that is called by uIP whenever a TCP/IP event occurs. The
S * name of this function must be registered with uIP at compile time
S * using the UIP_APPCALL definition.
S *
S * uIP applications can store the application state within the
S * uip_conn structure by specifying the type of the application
S * structure by typedef:ing the type uip_tcp_appstate_t and uip_udp_appstate_t.
S *
S * The file containing the definitions must be included in the
S * uipopt.h file.
S *
S * The following example illustrates how this can look.
S \code
S
Svoid httpd_appcall(void);
S#define UIP_APPCALL     httpd_appcall
S
Sstruct httpd_state {
S  u8_t state;
S  u16_t count;
S  char *dataptr;
S  char *script;
S};
Stypedef struct httpd_state uip_tcp_appstate_t
S \endcode
S */
S
S/**
S * \var #define UIP_APPCALL
S *
S * The name of the application function that uIP should call in
S * response to TCP/IP events.
S *
S */
S
S/**
S * \var typedef uip_tcp_appstate_t
S *
S * The type of the application state that is to be stored in the
S * uip_conn structure. This usually is typedef:ed to a struct holding
S * application state information.
S */
S
S/**
S * \var typedef uip_udp_appstate_t
S *
S * The type of the application state that is to be stored in the
S * uip_conn structure. This usually is typedef:ed to a struct holding
S * application state information.
S */
S/** @} */
S/** @} */
S
N#endif /* __UIPOPT_H__ */
L 10 "..\..\Source\inc\tcp_demo.h" 2
N
N#include "psock.h"
L 1 "..\..\Libraries\uIP-1.0\uip\psock.h" 1
N/*
N * Copyright (c) 2004, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: psock.h,v 1.3 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \defgroup psock Protosockets library
N * @{
N *
N * The protosocket library provides an interface to the uIP stack that is
N * similar to the traditional BSD socket interface. Unlike programs
N * written for the ordinary uIP event-driven interface, programs
N * written with the protosocket library are executed in a sequential
N * fashion and does not have to be implemented as explicit state
N * machines.
N *
N * Protosockets only work with TCP connections.
N *
N * The protosocket library uses \ref pt protothreads to provide
N * sequential control flow. This makes the protosockets lightweight in
N * terms of memory, but also means that protosockets inherits the
N * functional limitations of protothreads. Each protosocket lives only
N * within a single function. Automatic variables (stack variables) are
N * not retained across a protosocket library function call.
N *
N * \note Because the protosocket library uses protothreads, local
N * variables will not always be saved across a call to a protosocket
N * library function. It is therefore advised that local variables are
N * used with extreme care.
N *
N * The protosocket library provides functions for sending data without
N * having to deal with retransmissions and acknowledgements, as well
N * as functions for reading data without having to deal with data
N * being split across more than one TCP segment.
N *
N * Because each protosocket runs as a protothread, the protosocket has to be
N * started with a call to PSOCK_BEGIN() at the start of the function
N * in which the protosocket is used. Similarly, the protosocket protothread can
N * be terminated by a call to PSOCK_EXIT().
N *
N */
N
N/**
N * \file
N * Protosocket library header file
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifndef __PSOCK_H__
N#define __PSOCK_H__
N
N#include "uipopt.h"
N#include "pt.h"
L 1 "..\..\Libraries\uIP-1.0\uip\pt.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: pt.h,v 1.2 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \addtogroup pt
N * @{
N */
N
N/**
N * \file
N * Protothreads implementation.
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifndef __PT_H__
N#define __PT_H__
N
N#include "lc.h"
L 1 "..\..\Libraries\uIP-1.0\uip\lc.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: lc.h,v 1.2 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \addtogroup pt
N * @{
N */
N
N/**
N * \defgroup lc Local continuations
N * @{
N *
N * Local continuations form the basis for implementing protothreads. A
N * local continuation can be <i>set</i> in a specific function to
N * capture the state of the function. After a local continuation has
N * been set can be <i>resumed</i> in order to restore the state of the
N * function at the point where the local continuation was set.
N *
N *
N */
N
N/**
N * \file lc.h
N * Local continuations
N * \author
N * Adam Dunkels <adam@sics.se>
N *
N */
N
N#ifdef DOXYGEN
S/**
S * Initialize a local continuation.
S *
S * This operation initializes the local continuation, thereby
S * unsetting any previously set continuation state.
S *
S * \hideinitializer
S */
S#define LC_INIT(lc)
S
S/**
S * Set a local continuation.
S *
S * The set operation saves the state of the function at the point
S * where the operation is executed. As far as the set operation is
S * concerned, the state of the function does <b>not</b> include the
S * call-stack or local (automatic) variables, but only the program
S * counter and such CPU registers that needs to be saved.
S *
S * \hideinitializer
S */
S#define LC_SET(lc)
S
S/**
S * Resume a local continuation.
S *
S * The resume operation resumes a previously set local continuation, thus
S * restoring the state in which the function was when the local
S * continuation was set. If the local continuation has not been
S * previously set, the resume operation does nothing.
S *
S * \hideinitializer
S */
S#define LC_RESUME(lc)
S
S/**
S * Mark the end of local continuation usage.
S *
S * The end operation signifies that local continuations should not be
S * used any more in the function. This operation is not needed for
S * most implementations of local continuation, but is required by a
S * few implementations.
S *
S * \hideinitializer
S */
S#define LC_END(lc)
S
S/**
S * \var typedef lc_t;
S *
S * The local continuation type.
S *
S * \hideinitializer
S */
N#endif /* DOXYGEN */
N
N#ifndef __LC_H__
N#define __LC_H__
N
N#ifdef LC_CONF_INCLUDE
S#include LC_CONF_INCLUDE
N#else
N#include "lc-switch.h"
L 1 "..\..\Libraries\uIP-1.0\uip\lc-switch.h" 1
N/*
N * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions
N * are met:
N * 1. Redistributions of source code must retain the above copyright
N *    notice, this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright
N *    notice, this list of conditions and the following disclaimer in the
N *    documentation and/or other materials provided with the distribution.
N * 3. Neither the name of the Institute nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
N * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
N * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
N * SUCH DAMAGE.
N *
N * This file is part of the uIP TCP/IP stack
N *
N * Author: Adam Dunkels <adam@sics.se>
N *
N * $Id: lc-switch.h,v 1.2 2006/06/12 08:00:30 adam Exp $
N */
N
N/**
N * \addtogroup lc
N * @{
N */
N
N/**
N * \file
N * Implementation of local continuations based on switch() statment
N * \author Adam Dunkels <adam@sics.se>
N *
N * This implementation of local continuations uses the C switch()
N * statement to resume execution of a function somewhere inside the
N * function's body. The implementation is based on the fact that
N * switch() statements are able to jump directly into the bodies of
N * control structures such as if() or while() statmenets.
N *
N * This implementation borrows heavily from Simon Tatham's coroutines
N * implementation in C:
N * http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
N */
N
N#ifndef __LC_SWITCH_H__
N#define __LC_SWTICH_H__
N
N/* WARNING! lc implementation using switch() does not work if an
N   LC_SET() is done within another switch() statement! */
N
N/** \hideinitializer */
Ntypedef unsigned short lc_t;
N
N#define LC_INIT(s) s = 0;
N
N#define LC_RESUME(s) switch(s) { case 0:
N
N#define LC_SET(s) s = __LINE__; case __LINE__:
N
N#define LC_END(s) }
N
N#endif /* __LC_SWITCH_H__ */
N
N/** @} */
L 126 "..\..\Libraries\uIP-1.0\uip\lc.h" 2
N#endif /* LC_CONF_INCLUDE */
N
N#endif /* __LC_H__ */
N
N/** @} */
N/** @} */
L 53 "..\..\Libraries\uIP-1.0\uip\pt.h" 2
N
Nstruct pt {
N  lc_t lc;
N};
N
N#define PT_WAITING 0
N#define PT_EXITED  1
N#define PT_ENDED   2
N#define PT_YIELDED 3
N
N/**
N * \name Initialization
N * @{
N */
N
N/**
N * Initialize a protothread.
N *
N * Initializes a protothread. Initialization must be done prior to
N * starting to execute the protothread.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \sa PT_SPAWN()
N *
N * \hideinitializer
N */
N#define PT_INIT(pt)   LC_INIT((pt)->lc)
N
N/** @} */
N
N/**
N * \name Declaration and definition
N * @{
N */
N
N/**
N * Declaration of a protothread.
N *
N * This macro is used to declare a protothread. All protothreads must
N * be declared with this macro.
N *
N * \param name_args The name and arguments of the C function
N * implementing the protothread.
N *
N * \hideinitializer
N */
N#define PT_THREAD(name_args) char name_args
N
N/**
N * Declare the start of a protothread inside the C function
N * implementing the protothread.
N *
N * This macro is used to declare the starting point of a
N * protothread. It should be placed at the start of the function in
N * which the protothread runs. All C statements above the PT_BEGIN()
N * invokation will be executed each time the protothread is scheduled.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)->lc)
N
N/**
N * Declare the end of a protothread.
N *
N * This macro is used for declaring that a protothread ends. It must
N * always be used together with a matching PT_BEGIN() macro.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \
N                   PT_INIT(pt); return PT_ENDED; }
X#define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0;                    PT_INIT(pt); return PT_ENDED; }
N
N/** @} */
N
N/**
N * \name Blocked wait
N * @{
N */
N
N/**
N * Block and wait until condition is true.
N *
N * This macro blocks the protothread until the specified condition is
N * true.
N *
N * \param pt A pointer to the protothread control structure.
N * \param condition The condition.
N *
N * \hideinitializer
N */
N#define PT_WAIT_UNTIL(pt, condition)	        \
N  do {						\
N    LC_SET((pt)->lc);				\
N    if(!(condition)) {				\
N      return PT_WAITING;			\
N    }						\
N  } while(0)
X#define PT_WAIT_UNTIL(pt, condition)	          do {						    LC_SET((pt)->lc);				    if(!(condition)) {				      return PT_WAITING;			    }						  } while(0)
N
N/**
N * Block and wait while condition is true.
N *
N * This function blocks and waits while condition is true. See
N * PT_WAIT_UNTIL().
N *
N * \param pt A pointer to the protothread control structure.
N * \param cond The condition.
N *
N * \hideinitializer
N */
N#define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))
N
N/** @} */
N
N/**
N * \name Hierarchical protothreads
N * @{
N */
N
N/**
N * Block and wait until a child protothread completes.
N *
N * This macro schedules a child protothread. The current protothread
N * will block until the child protothread completes.
N *
N * \note The child protothread must be manually initialized with the
N * PT_INIT() function before this function is used.
N *
N * \param pt A pointer to the protothread control structure.
N * \param thread The child protothread with arguments
N *
N * \sa PT_SPAWN()
N *
N * \hideinitializer
N */
N#define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))
N
N/**
N * Spawn a child protothread and wait until it exits.
N *
N * This macro spawns a child protothread and waits until it exits. The
N * macro can only be used within a protothread.
N *
N * \param pt A pointer to the protothread control structure.
N * \param child A pointer to the child protothread's control structure.
N * \param thread The child protothread with arguments
N *
N * \hideinitializer
N */
N#define PT_SPAWN(pt, child, thread)		\
N  do {						\
N    PT_INIT((child));				\
N    PT_WAIT_THREAD((pt), (thread));		\
N  } while(0)
X#define PT_SPAWN(pt, child, thread)		  do {						    PT_INIT((child));				    PT_WAIT_THREAD((pt), (thread));		  } while(0)
N
N/** @} */
N
N/**
N * \name Exiting and restarting
N * @{
N */
N
N/**
N * Restart the protothread.
N *
N * This macro will block and cause the running protothread to restart
N * its execution at the place of the PT_BEGIN() call.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_RESTART(pt)				\
N  do {						\
N    PT_INIT(pt);				\
N    return PT_WAITING;			\
N  } while(0)
X#define PT_RESTART(pt)				  do {						    PT_INIT(pt);				    return PT_WAITING;			  } while(0)
N
N/**
N * Exit the protothread.
N *
N * This macro causes the protothread to exit. If the protothread was
N * spawned by another protothread, the parent protothread will become
N * unblocked and can continue to run.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_EXIT(pt)				\
N  do {						\
N    PT_INIT(pt);				\
N    return PT_EXITED;			\
N  } while(0)
X#define PT_EXIT(pt)				  do {						    PT_INIT(pt);				    return PT_EXITED;			  } while(0)
N
N/** @} */
N
N/**
N * \name Calling a protothread
N * @{
N */
N
N/**
N * Schedule a protothread.
N *
N * This function shedules a protothread. The return value of the
N * function is non-zero if the protothread is running or zero if the
N * protothread has exited.
N *
N * \param f The call to the C function implementing the protothread to
N * be scheduled
N *
N * \hideinitializer
N */
N#define PT_SCHEDULE(f) ((f) == PT_WAITING)
N
N/** @} */
N
N/**
N * \name Yielding from a protothread
N * @{
N */
N
N/**
N * Yield from the current protothread.
N *
N * This function will yield the protothread, thereby allowing other
N * processing to take place in the system.
N *
N * \param pt A pointer to the protothread control structure.
N *
N * \hideinitializer
N */
N#define PT_YIELD(pt)				\
N  do {						\
N    PT_YIELD_FLAG = 0;				\
N    LC_SET((pt)->lc);				\
N    if(PT_YIELD_FLAG == 0) {			\
N      return PT_YIELDED;			\
N    }						\
N  } while(0)
X#define PT_YIELD(pt)				  do {						    PT_YIELD_FLAG = 0;				    LC_SET((pt)->lc);				    if(PT_YIELD_FLAG == 0) {			      return PT_YIELDED;			    }						  } while(0)
N
N/**
N * \brief      Yield from the protothread until a condition occurs.
N * \param pt   A pointer to the protothread control structure.
N * \param cond The condition.
N *
N *             This function will yield the protothread, until the
N *             specified condition evaluates to true.
N *
N *
N * \hideinitializer
N */
N#define PT_YIELD_UNTIL(pt, cond)		\
N  do {						\
N    PT_YIELD_FLAG = 0;				\
N    LC_SET((pt)->lc);				\
N    if((PT_YIELD_FLAG == 0) || !(cond)) {	\
N      return PT_YIELDED;			\
N    }						\
N  } while(0)
X#define PT_YIELD_UNTIL(pt, cond)		  do {						    PT_YIELD_FLAG = 0;				    LC_SET((pt)->lc);				    if((PT_YIELD_FLAG == 0) || !(cond)) {	      return PT_YIELDED;			    }						  } while(0)
N
N/** @} */
N
N#endif /* __PT_H__ */
N
N/** @} */
L 86 "..\..\Libraries\uIP-1.0\uip\psock.h" 2
N
N /*
N * The structure that holds the state of a buffer.
N *
N * This structure holds the state of a uIP buffer. The structure has
N * no user-visible elements, but is used through the functions
N * provided by the library.
N *
N */
Nstruct psock_buf {
N  u8_t *ptr;
N  unsigned short left;
N};
N
N/**
N * The representation of a protosocket.
N *
N * The protosocket structrure is an opaque structure with no user-visible
N * elements.
N */
Nstruct psock {
N  struct pt pt, psockpt; /* Protothreads - one that's using the psock
N			    functions, and one that runs inside the
N			    psock functions. */
N  const u8_t *sendptr;   /* Pointer to the next data to be sent. */
N  u8_t *readptr;         /* Pointer to the next data to be read. */
N
N  char *bufptr;          /* Pointer to the buffer used for buffering
N			    incoming data. */
N
N  u16_t sendlen;         /* The number of bytes left to be sent. */
N  u16_t readlen;         /* The number of bytes left to be read. */
N
N  struct psock_buf buf;  /* The structure holding the state of the
N			    input buffer. */
N  unsigned int bufsize;  /* The size of the input buffer. */
N
N  unsigned char state;   /* The state of the protosocket. */
N};
N
Nvoid psock_init(struct psock *psock, char *buffer, unsigned int buffersize);
N/**
N * Initialize a protosocket.
N *
N * This macro initializes a protosocket and must be called before the
N * protosocket is used. The initialization also specifies the input buffer
N * for the protosocket.
N *
N * \param psock (struct psock *) A pointer to the protosocket to be
N * initialized
N *
N * \param buffer (char *) A pointer to the input buffer for the
N * protosocket.
N *
N * \param buffersize (unsigned int) The size of the input buffer.
N *
N * \hideinitializer
N */
N#define PSOCK_INIT(psock, buffer, buffersize) \
N  psock_init(psock, buffer, buffersize)
X#define PSOCK_INIT(psock, buffer, buffersize)   psock_init(psock, buffer, buffersize)
N
N/**
N * Start the protosocket protothread in a function.
N *
N * This macro starts the protothread associated with the protosocket and
N * must come before other protosocket calls in the function it is used.
N *
N * \param psock (struct psock *) A pointer to the protosocket to be
N * started.
N *
N * \hideinitializer
N */
N#define PSOCK_BEGIN(psock) PT_BEGIN(&((psock)->pt))
N
NPT_THREAD(psock_send(struct psock *psock, const char *buf, unsigned int len));
Xchar psock_send(struct psock *psock, const char *buf, unsigned int len);
N/**
N * Send data.
N *
N * This macro sends data over a protosocket. The protosocket protothread blocks
N * until all data has been sent and is known to have been received by
N * the remote end of the TCP connection.
N *
N * \param psock (struct psock *) A pointer to the protosocket over which
N * data is to be sent.
N *
N * \param data (char *) A pointer to the data that is to be sent.
N *
N * \param datalen (unsigned int) The length of the data that is to be
N * sent.
N *
N * \hideinitializer
N */
N#define PSOCK_SEND(psock, data, datalen)		\
N    PT_WAIT_THREAD(&((psock)->pt), psock_send(psock, data, datalen))
X#define PSOCK_SEND(psock, data, datalen)		    PT_WAIT_THREAD(&((psock)->pt), psock_send(psock, data, datalen))
N
N/**
N * \brief      Send a null-terminated string.
N * \param psock Pointer to the protosocket.
N * \param str  The string to be sent.
N *
N *             This function sends a null-terminated string over the
N *             protosocket.
N *
N * \hideinitializer
N */
N#define PSOCK_SEND_STR(psock, str)      		\
N    PT_WAIT_THREAD(&((psock)->pt), psock_send(psock, str, strlen(str)))
X#define PSOCK_SEND_STR(psock, str)      		    PT_WAIT_THREAD(&((psock)->pt), psock_send(psock, str, strlen(str)))
N
NPT_THREAD(psock_generator_send(struct psock *psock,
N				unsigned short (*f)(void *), void *arg));
Xchar psock_generator_send(struct psock *psock, unsigned short (*f)(void *), void *arg);
N
N/**
N * \brief      Generate data with a function and send it
N * \param psock Pointer to the protosocket.
N * \param generator Pointer to the generator function
N * \param arg   Argument to the generator function
N *
N *             This function generates data and sends it over the
N *             protosocket. This can be used to dynamically generate
N *             data for a transmission, instead of generating the data
N *             in a buffer beforehand. This function reduces the need for
N *             buffer memory. The generator function is implemented by
N *             the application, and a pointer to the function is given
N *             as an argument with the call to PSOCK_GENERATOR_SEND().
N *
N *             The generator function should place the generated data
N *             directly in the uip_appdata buffer, and return the
N *             length of the generated data. The generator function is
N *             called by the protosocket layer when the data first is
N *             sent, and once for every retransmission that is needed.
N *
N * \hideinitializer
N */
N#define PSOCK_GENERATOR_SEND(psock, generator, arg)     \
N    PT_WAIT_THREAD(&((psock)->pt),					\
N		   psock_generator_send(psock, generator, arg))
X#define PSOCK_GENERATOR_SEND(psock, generator, arg)         PT_WAIT_THREAD(&((psock)->pt),							   psock_generator_send(psock, generator, arg))
N
N
N/**
N * Close a protosocket.
N *
N * This macro closes a protosocket and can only be called from within the
N * protothread in which the protosocket lives.
N *
N * \param psock (struct psock *) A pointer to the protosocket that is to
N * be closed.
N *
N * \hideinitializer
N */
N#define PSOCK_CLOSE(psock) uip_close()
N
NPT_THREAD(psock_readbuf(struct psock *psock));
Xchar psock_readbuf(struct psock *psock);
N/**
N * Read data until the buffer is full.
N *
N * This macro will block waiting for data and read the data into the
N * input buffer specified with the call to PSOCK_INIT(). Data is read
N * until the buffer is full..
N *
N * \param psock (struct psock *) A pointer to the protosocket from which
N * data should be read.
N *
N * \hideinitializer
N */
N#define PSOCK_READBUF(psock)				\
N  PT_WAIT_THREAD(&((psock)->pt), psock_readbuf(psock))
X#define PSOCK_READBUF(psock)				  PT_WAIT_THREAD(&((psock)->pt), psock_readbuf(psock))
N
NPT_THREAD(psock_readto(struct psock *psock, unsigned char c));
Xchar psock_readto(struct psock *psock, unsigned char c);
N/**
N * Read data up to a specified character.
N *
N * This macro will block waiting for data and read the data into the
N * input buffer specified with the call to PSOCK_INIT(). Data is only
N * read until the specifieed character appears in the data stream.
N *
N * \param psock (struct psock *) A pointer to the protosocket from which
N * data should be read.
N *
N * \param c (char) The character at which to stop reading.
N *
N * \hideinitializer
N */
N#define PSOCK_READTO(psock, c)				\
N  PT_WAIT_THREAD(&((psock)->pt), psock_readto(psock, c))
X#define PSOCK_READTO(psock, c)				  PT_WAIT_THREAD(&((psock)->pt), psock_readto(psock, c))
N
N/**
N * The length of the data that was previously read.
N *
N * This macro returns the length of the data that was previously read
N * using PSOCK_READTO() or PSOCK_READ().
N *
N * \param psock (struct psock *) A pointer to the protosocket holding the data.
N *
N * \hideinitializer
N */
N#define PSOCK_DATALEN(psock) psock_datalen(psock)
N
Nu16_t psock_datalen(struct psock *psock);
N
N/**
N * Exit the protosocket's protothread.
N *
N * This macro terminates the protothread of the protosocket and should
N * almost always be used in conjunction with PSOCK_CLOSE().
N *
N * \sa PSOCK_CLOSE_EXIT()
N *
N * \param psock (struct psock *) A pointer to the protosocket.
N *
N * \hideinitializer
N */
N#define PSOCK_EXIT(psock) PT_EXIT(&((psock)->pt))
N
N/**
N * Close a protosocket and exit the protosocket's protothread.
N *
N * This macro closes a protosocket and exits the protosocket's protothread.
N *
N * \param psock (struct psock *) A pointer to the protosocket.
N *
N * \hideinitializer
N */
N#define PSOCK_CLOSE_EXIT(psock)		\
N  do {						\
N    PSOCK_CLOSE(psock);			\
N    PSOCK_EXIT(psock);			\
N  } while(0)
X#define PSOCK_CLOSE_EXIT(psock)		  do {						    PSOCK_CLOSE(psock);			    PSOCK_EXIT(psock);			  } while(0)
N
N/**
N * Declare the end of a protosocket's protothread.
N *
N * This macro is used for declaring that the protosocket's protothread
N * ends. It must always be used together with a matching PSOCK_BEGIN()
N * macro.
N *
N * \param psock (struct psock *) A pointer to the protosocket.
N *
N * \hideinitializer
N */
N#define PSOCK_END(psock) PT_END(&((psock)->pt))
N
Nchar psock_newdata(struct psock *s);
N
N/**
N * Check if new data has arrived on a protosocket.
N *
N * This macro is used in conjunction with the PSOCK_WAIT_UNTIL()
N * macro to check if data has arrived on a protosocket.
N *
N * \param psock (struct psock *) A pointer to the protosocket.
N *
N * \hideinitializer
N */
N#define PSOCK_NEWDATA(psock) psock_newdata(psock)
N
N/**
N * Wait until a condition is true.
N *
N * This macro blocks the protothread until the specified condition is
N * true. The macro PSOCK_NEWDATA() can be used to check if new data
N * arrives when the protosocket is waiting.
N *
N * Typically, this macro is used as follows:
N *
N \code
N PT_THREAD(thread(struct psock *s, struct timer *t))
N {
N   PSOCK_BEGIN(s);
N
N   PSOCK_WAIT_UNTIL(s, PSOCK_NEWADATA(s) || timer_expired(t));
N
N   if(PSOCK_NEWDATA(s)) {
N     PSOCK_READTO(s, '\n');
N   } else {
N     handle_timed_out(s);
N   }
N
N   PSOCK_END(s);
N }
N \endcode
N *
N * \param psock (struct psock *) A pointer to the protosocket.
N * \param condition The condition to wait for.
N *
N * \hideinitializer
N */
N#define PSOCK_WAIT_UNTIL(psock, condition)    \
N  PT_WAIT_UNTIL(&((psock)->pt), (condition));
X#define PSOCK_WAIT_UNTIL(psock, condition)      PT_WAIT_UNTIL(&((psock)->pt), (condition));
N
N#define PSOCK_WAIT_THREAD(psock, condition)   \
N  PT_WAIT_THREAD(&((psock)->pt), (condition))
X#define PSOCK_WAIT_THREAD(psock, condition)     PT_WAIT_THREAD(&((psock)->pt), (condition))
N
N#endif /* __PSOCK_H__ */
N
N/** @} */
L 12 "..\..\Source\inc\tcp_demo.h" 2
N
N/* () */
Nenum
N{
N	STATE_CMD		= 0,	/*  */
N	STATE_TX_TEST	= 1,	/* () */
N	STATE_RX_TEST	= 2		/* () */
N};
N
N/*
N	 uip_tcp_appstate_t 
N	uip
N
N	uip.h  	struct uip_conn   uip_tcp_appstate_t
N*/
Nstruct tcp_demo_appstate
N{
N	u8_t state;
N	u8_t *textptr;
N	int textlen;
N};
N
Ntypedef struct tcp_demo_appstate uip_tcp_appstate_t;
N
Nvoid tcp_demo_appcall(void);
N
N/*  */
N#ifndef UIP_APPCALL
N
N#define UIP_APPCALL tcp_server_appcall
N#endif
N
Nvoid tcp_demo_init(void);
N
N#endif
L 160 "..\..\Source\src\uIP_enc28j60\uip-conf.h" 2
N
N#endif /* __UIP_CONF_H__ */
N
N/** @} */
N/** @} */
L 71 "..\..\Libraries\uIP-1.0\uip\uipopt.h" 2
N
N/*------------------------------------------------------------------------------*/
N
N/**
N * \name Static configuration options
N * @{
N *
N * These configuration options can be used for setting the IP address
N * settings statically, but only if UIP_FIXEDADDR is set to 1. The
N * configuration options for a specific node includes IP address,
N * netmask and default router as well as the Ethernet address. The
N * netmask, default router and Ethernet address are appliciable only
N * if uIP should be run over Ethernet.
N *
N * All of these should be changed to suit your project.
N*/
N
N/**
N * Determines if uIP should use a fixed IP address or not.
N *
N * If uIP should use a fixed IP address, the settings are set in the
N * uipopt.h file. If not, the macros uip_sethostaddr(),
N * uip_setdraddr() and uip_setnetmask() should be used instead.
N *
N * \hideinitializer
N */
N#define UIP_FIXEDADDR    0
N
N/**
N * Ping IP address asignment.
N *
N * uIP uses a "ping" packets for setting its own IP address if this
N * option is set. If so, uIP will start with an empty IP address and
N * the destination IP address of the first incoming "ping" (ICMP echo)
N * packet will be used for setting the hosts IP address.
N *
N * \note This works only if UIP_FIXEDADDR is 0.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_PINGADDRCONF
S#define UIP_PINGADDRCONF UIP_CONF_PINGADDRCONF
N#else /* UIP_CONF_PINGADDRCONF */
N#define UIP_PINGADDRCONF 0
N#endif /* UIP_CONF_PINGADDRCONF */
N
N
N/**
N * Specifies if the uIP ARP module should be compiled with a fixed
N * Ethernet MAC address or not.
N *
N * If this configuration option is 0, the macro uip_setethaddr() can
N * be used to specify the Ethernet address at run-time.
N *
N * \hideinitializer
N */
N#define UIP_FIXEDETHADDR 0
N
N/** @} */
N/*------------------------------------------------------------------------------*/
N/**
N * \name IP configuration options
N * @{
N *
N */
N/**
N * The IP TTL (time to live) of IP packets sent by uIP.
N *
N * This should normally not be changed.
N */
N#define UIP_TTL         64
N
N/**
N * Turn on support for IP packet reassembly.
N *
N * uIP supports reassembly of fragmented IP packets. This features
N * requires an additonal amount of RAM to hold the reassembly buffer
N * and the reassembly code size is approximately 700 bytes.  The
N * reassembly buffer is of the same size as the uip_buf buffer
N * (configured by UIP_BUFSIZE).
N *
N * \note IP packet reassembly is not heavily tested.
N *
N * \hideinitializer
N */
N#define UIP_REASSEMBLY 0
N
N/**
N * The maximum time an IP fragment should wait in the reassembly
N * buffer before it is dropped.
N *
N */
N#define UIP_REASS_MAXAGE 40
N
N/** @} */
N
N/*------------------------------------------------------------------------------*/
N/**
N * \name UDP configuration options
N * @{
N */
N
N/**
N * Toggles wether UDP support should be compiled in or not.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_UDP
N#define UIP_UDP UIP_CONF_UDP
N#else /* UIP_CONF_UDP */
S#define UIP_UDP           0
N#endif /* UIP_CONF_UDP */
N
N/**
N * Toggles if UDP checksums should be used or not.
N *
N * \note Support for UDP checksums is currently not included in uIP,
N * so this option has no function.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_UDP_CHECKSUMS
N#define UIP_UDP_CHECKSUMS UIP_CONF_UDP_CHECKSUMS
N#else
S#define UIP_UDP_CHECKSUMS 0
N#endif
N
N/**
N * The maximum amount of concurrent UDP connections.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_UDP_CONNS
S#define UIP_UDP_CONNS UIP_CONF_UDP_CONNS
N#else /* UIP_CONF_UDP_CONNS */
N#define UIP_UDP_CONNS    10
N#endif /* UIP_CONF_UDP_CONNS */
N
N/**
N * The name of the function that should be called when UDP datagrams arrive.
N *
N * \hideinitializer
N */
N
N
N/** @} */
N/*------------------------------------------------------------------------------*/
N/**
N * \name TCP configuration options
N * @{
N */
N
N/**
N * Determines if support for opening connections from uIP should be
N * compiled in.
N *
N * If the applications that are running on top of uIP for this project
N * do not need to open outgoing TCP connections, this configration
N * option can be turned off to reduce the code size of uIP.
N *
N * \hideinitializer
N */
N#define UIP_ACTIVE_OPEN 1
N
N/**
N * The maximum number of simultaneously open TCP connections.
N *
N * Since the TCP connections are statically allocated, turning this
N * configuration knob down results in less RAM used. Each TCP
N * connection requires approximatly 30 bytes of memory.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_MAX_CONNECTIONS
S#define UIP_CONNS       10
N#else /* UIP_CONF_MAX_CONNECTIONS */
N#define UIP_CONNS UIP_CONF_MAX_CONNECTIONS
N#endif /* UIP_CONF_MAX_CONNECTIONS */
N
N
N/**
N * The maximum number of simultaneously listening TCP ports.
N *
N * Each listening TCP port requires 2 bytes of memory.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_MAX_LISTENPORTS
S#define UIP_LISTENPORTS 20
N#else /* UIP_CONF_MAX_LISTENPORTS */
N#define UIP_LISTENPORTS UIP_CONF_MAX_LISTENPORTS
N#endif /* UIP_CONF_MAX_LISTENPORTS */
N
N/**
N * Determines if support for TCP urgent data notification should be
N * compiled in.
N *
N * Urgent data (out-of-band data) is a rarely used TCP feature that
N * very seldom would be required.
N *
N * \hideinitializer
N */
N#define UIP_URGDATA      0
N
N/**
N * The initial retransmission timeout counted in timer pulses.
N *
N * This should not be changed.
N */
N#define UIP_RTO         3
N
N/**
N * The maximum number of times a segment should be retransmitted
N * before the connection should be aborted.
N *
N * This should not be changed.
N */
N#define UIP_MAXRTX      8
N
N/**
N * The maximum number of times a SYN segment should be retransmitted
N * before a connection request should be deemed to have been
N * unsuccessful.
N *
N * This should not need to be changed.
N */
N#define UIP_MAXSYNRTX      5
N
N/**
N * The TCP maximum segment size.
N *
N * This is should not be to set to more than
N * UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN.
N */
N#define UIP_TCP_MSS     (UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN)
N
N/**
N * The size of the advertised receiver's window.
N *
N * Should be set low (i.e., to the size of the uip_buf buffer) is the
N * application is slow to process incoming data, or high (32768 bytes)
N * if the application processes data quickly.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_RECEIVE_WINDOW
N#define UIP_RECEIVE_WINDOW UIP_TCP_MSS
N#else
S#define UIP_RECEIVE_WINDOW UIP_CONF_RECEIVE_WINDOW
N#endif
N
N/**
N * How long a connection should stay in the TIME_WAIT state.
N *
N * This configiration option has no real implication, and it should be
N * left untouched.
N */
N#define UIP_TIME_WAIT_TIMEOUT 120
N
N
N/** @} */
N/*------------------------------------------------------------------------------*/
N/**
N * \name ARP configuration options
N * @{
N */
N
N/**
N * The size of the ARP table.
N *
N * This option should be set to a larger value if this uIP node will
N * have many connections from the local network.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_ARPTAB_SIZE
S#define UIP_ARPTAB_SIZE UIP_CONF_ARPTAB_SIZE
N#else
N#define UIP_ARPTAB_SIZE 8
N#endif
N
N/**
N * The maxium age of ARP table entries measured in 10ths of seconds.
N *
N * An UIP_ARP_MAXAGE of 120 corresponds to 20 minutes (BSD
N * default).
N */
N#define UIP_ARP_MAXAGE 120
N
N/** @} */
N
N/*------------------------------------------------------------------------------*/
N
N/**
N * \name General configuration options
N * @{
N */
N
N/**
N * The size of the uIP packet buffer.
N *
N * The uIP packet buffer should not be smaller than 60 bytes, and does
N * not need to be larger than 1500 bytes. Lower size results in lower
N * TCP throughput, larger size results in higher TCP throughput.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_BUFFER_SIZE
S#define UIP_BUFSIZE     400
N#else /* UIP_CONF_BUFFER_SIZE */
N#define UIP_BUFSIZE UIP_CONF_BUFFER_SIZE
N#endif /* UIP_CONF_BUFFER_SIZE */
N
N
N/**
N * Determines if statistics support should be compiled in.
N *
N * The statistics is useful for debugging and to show the user.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_STATISTICS
S#define UIP_STATISTICS  0
N#else /* UIP_CONF_STATISTICS */
N#define UIP_STATISTICS UIP_CONF_STATISTICS
N#endif /* UIP_CONF_STATISTICS */
N
N/**
N * Determines if logging of certain events should be compiled in.
N *
N * This is useful mostly for debugging. The function uip_log()
N * must be implemented to suit the architecture of the project, if
N * logging is turned on.
N *
N * \hideinitializer
N */
N#ifndef UIP_CONF_LOGGING
S#define UIP_LOGGING     0
N#else /* UIP_CONF_LOGGING */
N#define UIP_LOGGING     UIP_CONF_LOGGING
N#endif /* UIP_CONF_LOGGING */
N
N/**
N * Broadcast support.
N *
N * This flag configures IP broadcast support. This is useful only
N * together with UDP.
N *
N * \hideinitializer
N *
N */
N#ifndef UIP_CONF_BROADCAST
N#define UIP_BROADCAST 0
N#else /* UIP_CONF_BROADCAST */
S#define UIP_BROADCAST UIP_CONF_BROADCAST
N#endif /* UIP_CONF_BROADCAST */
N
N/**
N * Print out a uIP log message.
N *
N * This function must be implemented by the module that uses uIP, and
N * is called by uIP whenever a log message is generated.
N */
Nvoid uip_log(char *msg);
N
N/**
N * The link level header length.
N *
N * This is the offset into the uip_buf where the IP header can be
N * found. For Ethernet, this should be set to 14. For SLIP, this
N * should be set to 0.
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_LLH_LEN
S#define UIP_LLH_LEN UIP_CONF_LLH_LEN
N#else /* UIP_CONF_LLH_LEN */
N#define UIP_LLH_LEN     14
N#endif /* UIP_CONF_LLH_LEN */
N
N/** @} */
N/*------------------------------------------------------------------------------*/
N/**
N * \name CPU architecture configuration
N * @{
N *
N * The CPU architecture configuration is where the endianess of the
N * CPU on which uIP is to be run is specified. Most CPUs today are
N * little endian, and the most notable exception are the Motorolas
N * which are big endian. The BYTE_ORDER macro should be changed to
N * reflect the CPU architecture on which uIP is to be run.
N */
N
N/**
N * The byte order of the CPU architecture on which uIP is to be run.
N *
N * This option can be either BIG_ENDIAN (Motorola byte order) or
N * LITTLE_ENDIAN (Intel byte order).
N *
N * \hideinitializer
N */
N#ifdef UIP_CONF_BYTE_ORDER
N#define UIP_BYTE_ORDER     UIP_CONF_BYTE_ORDER
N#else /* UIP_CONF_BYTE_ORDER */
S#define UIP_BYTE_ORDER     UIP_LITTLE_ENDIAN
N#endif /* UIP_CONF_BYTE_ORDER */
N
N/** @} */
N/*------------------------------------------------------------------------------*/
N
N/**
N * \name Appication specific configurations
N * @{
N *
N * An uIP application is implemented using a single application
N * function that is called by uIP whenever a TCP/IP event occurs. The
N * name of this function must be registered with uIP at compile time
N * using the UIP_APPCALL definition.
N *
N * uIP applications can store the application state within the
N * uip_conn structure by specifying the type of the application
N * structure by typedef:ing the type uip_tcp_appstate_t and uip_udp_appstate_t.
N *
N * The file containing the definitions must be included in the
N * uipopt.h file.
N *
N * The following example illustrates how this can look.
N \code
N
Nvoid httpd_appcall(void);
N#define UIP_APPCALL     httpd_appcall
N
Nstruct httpd_state {
N  u8_t state;
N  u16_t count;
N  char *dataptr;
N  char *script;
N};
Ntypedef struct httpd_state uip_tcp_appstate_t
N \endcode
N */
N
N/**
N * \var #define UIP_APPCALL
N *
N * The name of the application function that uIP should call in
N * response to TCP/IP events.
N *
N */
N
N/**
N * \var typedef uip_tcp_appstate_t
N *
N * The type of the application state that is to be stored in the
N * uip_conn structure. This usually is typedef:ed to a struct holding
N * application state information.
N */
N
N/**
N * \var typedef uip_udp_appstate_t
N *
N * The type of the application state that is to be stored in the
N * uip_conn structure. This usually is typedef:ed to a struct holding
N * application state information.
N */
N/** @} */
N/** @} */
N
N#endif /* __UIPOPT_H__ */
L 57 "..\..\Libraries\uIP-1.0\uip\uip.h" 2
N
N/**
N * Repressentation of an IP address.
N *
N */
Ntypedef u16_t uip_ip4addr_t[2];
Ntypedef u16_t uip_ip6addr_t[8];
N#if UIP_CONF_IPV6
Stypedef uip_ip6addr_t uip_ipaddr_t;
N#else /* UIP_CONF_IPV6 */
Ntypedef uip_ip4addr_t uip_ipaddr_t;
N#endif /* UIP_CONF_IPV6 */
N
N/*---------------------------------------------------------------------------*/
N/* First, the functions that should be called from the
N * system. Initialization, the periodic timer and incoming packets are
N * handled by the following three functions.
N */
N
N/**
N * \defgroup uipconffunc uIP configuration functions
N * @{
N *
N * The uIP configuration functions are used for setting run-time
N * parameters in uIP such as IP addresses.
N */
N
N/**
N * Set the IP address of this host.
N *
N * The IP address is represented as a 4-byte array where the first
N * octet of the IP address is put in the first member of the 4-byte
N * array.
N *
N * Example:
N \code
N
N uip_ipaddr_t addr;
N
N uip_ipaddr(&addr, 192,168,1,2);
N uip_sethostaddr(&addr);
N
N \endcode
N * \param addr A pointer to an IP address of type uip_ipaddr_t;
N *
N * \sa uip_ipaddr()
N *
N * \hideinitializer
N */
N#define uip_sethostaddr(addr) uip_ipaddr_copy(uip_hostaddr, (addr))
N
N/**
N * Get the IP address of this host.
N *
N * The IP address is represented as a 4-byte array where the first
N * octet of the IP address is put in the first member of the 4-byte
N * array.
N *
N * Example:
N \code
N uip_ipaddr_t hostaddr;
N
N uip_gethostaddr(&hostaddr);
N \endcode
N * \param addr A pointer to a uip_ipaddr_t variable that will be
N * filled in with the currently configured IP address.
N *
N * \hideinitializer
N */
N#define uip_gethostaddr(addr) uip_ipaddr_copy((addr), uip_hostaddr)
N
N/**
N * Set the default router's IP address.
N *
N * \param addr A pointer to a uip_ipaddr_t variable containing the IP
N * address of the default router.
N *
N * \sa uip_ipaddr()
N *
N * \hideinitializer
N */
N#define uip_setdraddr(addr) uip_ipaddr_copy(uip_draddr, (addr))
N
N/**
N * Set the netmask.
N *
N * \param addr A pointer to a uip_ipaddr_t variable containing the IP
N * address of the netmask.
N *
N * \sa uip_ipaddr()
N *
N * \hideinitializer
N */
N#define uip_setnetmask(addr) uip_ipaddr_copy(uip_netmask, (addr))
N
N
N/**
N * Get the default router's IP address.
N *
N * \param addr A pointer to a uip_ipaddr_t variable that will be
N * filled in with the IP address of the default router.
N *
N * \hideinitializer
N */
N#define uip_getdraddr(addr) uip_ipaddr_copy((addr), uip_draddr)
N
N/**
N * Get the netmask.
N *
N * \param addr A pointer to a uip_ipaddr_t variable that will be
N * filled in with the value of the netmask.
N *
N * \hideinitializer
N */
N#define uip_getnetmask(addr) uip_ipaddr_copy((addr), uip_netmask)
N
N/** @} */
N
N/**
N * \defgroup uipinit uIP initialization functions
N * @{
N *
N * The uIP initialization functions are used for booting uIP.
N */
N
N/**
N * uIP initialization function.
N *
N * This function should be called at boot up to initilize the uIP
N * TCP/IP stack.
N */
Nvoid uip_init(void);
N
N/**
N * uIP initialization function.
N *
N * This function may be used at boot time to set the initial ip_id.
N */
Nvoid uip_setipid(u16_t id);
N
N/** @} */
N
N/**
N * \defgroup uipdevfunc uIP device driver functions
N * @{
N *
N * These functions are used by a network device driver for interacting
N * with uIP.
N */
N
N/**
N * Process an incoming packet.
N *
N * This function should be called when the device driver has received
N * a packet from the network. The packet from the device driver must
N * be present in the uip_buf buffer, and the length of the packet
N * should be placed in the uip_len variable.
N *
N * When the function returns, there may be an outbound packet placed
N * in the uip_buf packet buffer. If so, the uip_len variable is set to
N * the length of the packet. If no packet is to be sent out, the
N * uip_len variable is set to 0.
N *
N * The usual way of calling the function is presented by the source
N * code below.
N \code
N  uip_len = devicedriver_poll();
N  if(uip_len > 0) {
N    uip_input();
N    if(uip_len > 0) {
N      devicedriver_send();
N    }
N  }
N \endcode
N *
N * \note If you are writing a uIP device driver that needs ARP
N * (Address Resolution Protocol), e.g., when running uIP over
N * Ethernet, you will need to call the uIP ARP code before calling
N * this function:
N \code
N  #define BUF ((struct uip_eth_hdr *)&uip_buf[0])
N  uip_len = ethernet_devicedrver_poll();
N  if(uip_len > 0) {
N    if(BUF->type == HTONS(UIP_ETHTYPE_IP)) {
N      uip_arp_ipin();
N      uip_input();
N      if(uip_len > 0) {
N        uip_arp_out();
N	ethernet_devicedriver_send();
N      }
N    } else if(BUF->type == HTONS(UIP_ETHTYPE_ARP)) {
N      uip_arp_arpin();
N      if(uip_len > 0) {
N	ethernet_devicedriver_send();
N      }
N    }
N \endcode
N *
N * \hideinitializer
N */
N#define uip_input()        uip_process(UIP_DATA)
N
N/**
N * Periodic processing for a connection identified by its number.
N *
N * This function does the necessary periodic processing (timers,
N * polling) for a uIP TCP conneciton, and should be called when the
N * periodic uIP timer goes off. It should be called for every
N * connection, regardless of whether they are open of closed.
N *
N * When the function returns, it may have an outbound packet waiting
N * for service in the uIP packet buffer, and if so the uip_len
N * variable is set to a value larger than zero. The device driver
N * should be called to send out the packet.
N *
N * The ususal way of calling the function is through a for() loop like
N * this:
N \code
N  for(i = 0; i < UIP_CONNS; ++i) {
N    uip_periodic(i);
N    if(uip_len > 0) {
N      devicedriver_send();
N    }
N  }
N \endcode
N *
N * \note If you are writing a uIP device driver that needs ARP
N * (Address Resolution Protocol), e.g., when running uIP over
N * Ethernet, you will need to call the uip_arp_out() function before
N * calling the device driver:
N \code
N  for(i = 0; i < UIP_CONNS; ++i) {
N    uip_periodic(i);
N    if(uip_len > 0) {
N      uip_arp_out();
N      ethernet_devicedriver_send();
N    }
N  }
N \endcode
N *
N * \param conn The number of the connection which is to be periodically polled.
N *
N * \hideinitializer
N */
N#define uip_periodic(conn) do { uip_conn = &uip_conns[conn]; \
N                                uip_process(UIP_TIMER); } while (0)
X#define uip_periodic(conn) do { uip_conn = &uip_conns[conn];                                 uip_process(UIP_TIMER); } while (0)
N
N/**
N *
N *
N */
N#define uip_conn_active(conn) (uip_conns[conn].tcpstateflags != UIP_CLOSED)
N
N/**
N * Perform periodic processing for a connection identified by a pointer
N * to its structure.
N *
N * Same as uip_periodic() but takes a pointer to the actual uip_conn
N * struct instead of an integer as its argument. This function can be
N * used to force periodic processing of a specific connection.
N *
N * \param conn A pointer to the uip_conn struct for the connection to
N * be processed.
N *
N * \hideinitializer
N */
N#define uip_periodic_conn(conn) do { uip_conn = conn; \
N                                     uip_process(UIP_TIMER); } while (0)
X#define uip_periodic_conn(conn) do { uip_conn = conn;                                      uip_process(UIP_TIMER); } while (0)
N
N/**
N * Reuqest that a particular connection should be polled.
N *
N * Similar to uip_periodic_conn() but does not perform any timer
N * processing. The application is polled for new data.
N *
N * \param conn A pointer to the uip_conn struct for the connection to
N * be processed.
N *
N * \hideinitializer
N */
N#define uip_poll_conn(conn) do { uip_conn = conn; \
N                                 uip_process(UIP_POLL_REQUEST); } while (0)
X#define uip_poll_conn(conn) do { uip_conn = conn;                                  uip_process(UIP_POLL_REQUEST); } while (0)
N
N
N#if UIP_UDP
X#if 0
S/**
S * Periodic processing for a UDP connection identified by its number.
S *
S * This function is essentially the same as uip_periodic(), but for
S * UDP connections. It is called in a similar fashion as the
S * uip_periodic() function:
S \code
S  for(i = 0; i < UIP_UDP_CONNS; i++) {
S    uip_udp_periodic(i);
S    if(uip_len > 0) {
S      devicedriver_send();
S    }
S  }
S \endcode
S *
S * \note As for the uip_periodic() function, special care has to be
S * taken when using uIP together with ARP and Ethernet:
S \code
S  for(i = 0; i < UIP_UDP_CONNS; i++) {
S    uip_udp_periodic(i);
S    if(uip_len > 0) {
S      uip_arp_out();
S      ethernet_devicedriver_send();
S    }
S  }
S \endcode
S *
S * \param conn The number of the UDP connection to be processed.
S *
S * \hideinitializer
S */
S#define uip_udp_periodic(conn) do { uip_udp_conn = &uip_udp_conns[conn]; \
S                                uip_process(UIP_UDP_TIMER); } while (0)
X#define uip_udp_periodic(conn) do { uip_udp_conn = &uip_udp_conns[conn];                                 uip_process(UIP_UDP_TIMER); } while (0)
S
S/**
S * Periodic processing for a UDP connection identified by a pointer to
S * its structure.
S *
S * Same as uip_udp_periodic() but takes a pointer to the actual
S * uip_conn struct instead of an integer as its argument. This
S * function can be used to force periodic processing of a specific
S * connection.
S *
S * \param conn A pointer to the uip_udp_conn struct for the connection
S * to be processed.
S *
S * \hideinitializer
S */
S#define uip_udp_periodic_conn(conn) do { uip_udp_conn = conn; \
S                                         uip_process(UIP_UDP_TIMER); } while (0)
X#define uip_udp_periodic_conn(conn) do { uip_udp_conn = conn;                                          uip_process(UIP_UDP_TIMER); } while (0)
S
S
N#endif /* UIP_UDP */
N
N/**
N * The uIP packet buffer.
N *
N * The uip_buf array is used to hold incoming and outgoing
N * packets. The device driver should place incoming data into this
N * buffer. When sending data, the device driver should read the link
N * level headers and the TCP/IP headers from this buffer. The size of
N * the link level headers is configured by the UIP_LLH_LEN define.
N *
N * \note The application data need not be placed in this buffer, so
N * the device driver must read it from the place pointed to by the
N * uip_appdata pointer as illustrated by the following example:
N \code
N void
N devicedriver_send(void)
N {
N    hwsend(&uip_buf[0], UIP_LLH_LEN);
N    if(uip_len <= UIP_LLH_LEN + UIP_TCPIP_HLEN) {
N      hwsend(&uip_buf[UIP_LLH_LEN], uip_len - UIP_LLH_LEN);
N    } else {
N      hwsend(&uip_buf[UIP_LLH_LEN], UIP_TCPIP_HLEN);
N      hwsend(uip_appdata, uip_len - UIP_TCPIP_HLEN - UIP_LLH_LEN);
N    }
N }
N \endcode
N */
Nextern u8_t uip_buf[UIP_BUFSIZE+2];
Xextern u8_t uip_buf[4096+2];
N
N/** @} */
N
N/*---------------------------------------------------------------------------*/
N/* Functions that are used by the uIP application program. Opening and
N * closing connections, sending and receiving data, etc. is all
N * handled by the functions below.
N*/
N/**
N * \defgroup uipappfunc uIP application functions
N * @{
N *
N * Functions used by an application running of top of uIP.
N */
N
N/**
N * Start listening to the specified port.
N *
N * \note Since this function expects the port number in network byte
N * order, a conversion using HTONS() or htons() is necessary.
N *
N \code
N uip_listen(HTONS(80));
N \endcode
N *
N * \param port A 16-bit port number in network byte order.
N */
Nvoid uip_listen(u16_t port);
N
N/**
N * Stop listening to the specified port.
N *
N * \note Since this function expects the port number in network byte
N * order, a conversion using HTONS() or htons() is necessary.
N *
N \code
N uip_unlisten(HTONS(80));
N \endcode
N *
N * \param port A 16-bit port number in network byte order.
N */
Nvoid uip_unlisten(u16_t port);
N
N/**
N * Connect to a remote host using TCP.
N *
N * This function is used to start a new connection to the specified
N * port on the specied host. It allocates a new connection identifier,
N * sets the connection to the SYN_SENT state and sets the
N * retransmission timer to 0. This will cause a TCP SYN segment to be
N * sent out the next time this connection is periodically processed,
N * which usually is done within 0.5 seconds after the call to
N * uip_connect().
N *
N * \note This function is avaliable only if support for active open
N * has been configured by defining UIP_ACTIVE_OPEN to 1 in uipopt.h.
N *
N * \note Since this function requires the port number to be in network
N * byte order, a conversion using HTONS() or htons() is necessary.
N *
N \code
N uip_ipaddr_t ipaddr;
N
N uip_ipaddr(&ipaddr, 192,168,1,2);
N uip_connect(&ipaddr, HTONS(80));
N \endcode
N *
N * \param ripaddr The IP address of the remote hot.
N *
N * \param port A 16-bit port number in network byte order.
N *
N * \return A pointer to the uIP connection identifier for the new connection,
N * or NULL if no connection could be allocated.
N *
N */
Nstruct uip_conn *uip_connect(uip_ipaddr_t *ripaddr, u16_t port);
N
N
N
N/**
N * \internal
N *
N * Check if a connection has outstanding (i.e., unacknowledged) data.
N *
N * \param conn A pointer to the uip_conn structure for the connection.
N *
N * \hideinitializer
N */
N#define uip_outstanding(conn) ((conn)->len)
N
N/**
N * Send data on the current connection.
N *
N * This function is used to send out a single segment of TCP
N * data. Only applications that have been invoked by uIP for event
N * processing can send data.
N *
N * The amount of data that actually is sent out after a call to this
N * funcion is determined by the maximum amount of data TCP allows. uIP
N * will automatically crop the data so that only the appropriate
N * amount of data is sent. The function uip_mss() can be used to query
N * uIP for the amount of data that actually will be sent.
N *
N * \note This function does not guarantee that the sent data will
N * arrive at the destination. If the data is lost in the network, the
N * application will be invoked with the uip_rexmit() event being
N * set. The application will then have to resend the data using this
N * function.
N *
N * \param data A pointer to the data which is to be sent.
N *
N * \param len The maximum amount of data bytes to be sent.
N *
N * \hideinitializer
N */
Nvoid uip_send(const void *data, int len);
N
N/**
N * The length of any incoming data that is currently avaliable (if avaliable)
N * in the uip_appdata buffer.
N *
N * The test function uip_data() must first be used to check if there
N * is any data available at all.
N *
N * \hideinitializer
N */
N/*void uip_datalen(void);*/
N#define uip_datalen()       uip_len
N
N/**
N * The length of any out-of-band data (urgent data) that has arrived
N * on the connection.
N *
N * \note The configuration parameter UIP_URGDATA must be set for this
N * function to be enabled.
N *
N * \hideinitializer
N */
N#define uip_urgdatalen()    uip_urglen
N
N/**
N * Close the current connection.
N *
N * This function will close the current connection in a nice way.
N *
N * \hideinitializer
N */
N#define uip_close()         (uip_flags = UIP_CLOSE)
N
N/**
N * Abort the current connection.
N *
N * This function will abort (reset) the current connection, and is
N * usually used when an error has occured that prevents using the
N * uip_close() function.
N *
N * \hideinitializer
N */
N#define uip_abort()         (uip_flags = UIP_ABORT)
N
N/**
N * Tell the sending host to stop sending data.
N *
N * This function will close our receiver's window so that we stop
N * receiving data for the current connection.
N *
N * \hideinitializer
N */
N#define uip_stop()          (uip_conn->tcpstateflags |= UIP_STOPPED)
N
N/**
N * Find out if the current connection has been previously stopped with
N * uip_stop().
N *
N * \hideinitializer
N */
N#define uip_stopped(conn)   ((conn)->tcpstateflags & UIP_STOPPED)
N
N/**
N * Restart the current connection, if is has previously been stopped
N * with uip_stop().
N *
N * This function will open the receiver's window again so that we
N * start receiving data for the current connection.
N *
N * \hideinitializer
N */
N#define uip_restart()         do { uip_flags |= UIP_NEWDATA; \
N                                   uip_conn->tcpstateflags &= ~UIP_STOPPED; \
N                              } while(0)
X#define uip_restart()         do { uip_flags |= UIP_NEWDATA;                                    uip_conn->tcpstateflags &= ~UIP_STOPPED;                               } while(0)
N
N
N/* uIP tests that can be made to determine in what state the current
N   connection is, and what the application function should do. */
N
N/**
N * Is the current connection a UDP connection?
N *
N * This function checks whether the current connection is a UDP connection.
N *
N * \hideinitializer
N *
N */
N#define uip_udpconnection() (uip_conn == NULL)
N
N/**
N * Is new incoming data available?
N *
N * Will reduce to non-zero if there is new data for the application
N * present at the uip_appdata pointer. The size of the data is
N * avaliable through the uip_len variable.
N *
N * \hideinitializer
N */
N#define uip_newdata()   (uip_flags & UIP_NEWDATA)
N
N/**
N * Has previously sent data been acknowledged?
N *
N * Will reduce to non-zero if the previously sent data has been
N * acknowledged by the remote host. This means that the application
N * can send new data.
N *
N * \hideinitializer
N */
N#define uip_acked()   (uip_flags & UIP_ACKDATA)
N
N/**
N * Has the connection just been connected?
N *
N * Reduces to non-zero if the current connection has been connected to
N * a remote host. This will happen both if the connection has been
N * actively opened (with uip_connect()) or passively opened (with
N * uip_listen()).
N *
N * \hideinitializer
N */
N#define uip_connected() (uip_flags & UIP_CONNECTED)
N
N/**
N * Has the connection been closed by the other end?
N *
N * Is non-zero if the connection has been closed by the remote
N * host. The application may then do the necessary clean-ups.
N *
N * \hideinitializer
N */
N#define uip_closed()    (uip_flags & UIP_CLOSE)
N
N/**
N * Has the connection been aborted by the other end?
N *
N * Non-zero if the current connection has been aborted (reset) by the
N * remote host.
N *
N * \hideinitializer
N */
N#define uip_aborted()    (uip_flags & UIP_ABORT)
N
N/**
N * Has the connection timed out?
N *
N * Non-zero if the current connection has been aborted due to too many
N * retransmissions.
N *
N * \hideinitializer
N */
N#define uip_timedout()    (uip_flags & UIP_TIMEDOUT)
N
N/**
N * Do we need to retransmit previously data?
N *
N * Reduces to non-zero if the previously sent data has been lost in
N * the network, and the application should retransmit it. The
N * application should send the exact same data as it did the last
N * time, using the uip_send() function.
N *
N * \hideinitializer
N */
N#define uip_rexmit()     (uip_flags & UIP_REXMIT)
N
N/**
N * Is the connection being polled by uIP?
N *
N * Is non-zero if the reason the application is invoked is that the
N * current connection has been idle for a while and should be
N * polled.
N *
N * The polling event can be used for sending data without having to
N * wait for the remote host to send data.
N *
N * \hideinitializer
N */
N#define uip_poll()       (uip_flags & UIP_POLL)
N
N/**
N * Get the initial maxium segment size (MSS) of the current
N * connection.
N *
N * \hideinitializer
N */
N#define uip_initialmss()             (uip_conn->initialmss)
N
N/**
N * Get the current maxium segment size that can be sent on the current
N * connection.
N *
N * The current maxiumum segment size that can be sent on the
N * connection is computed from the receiver's window and the MSS of
N * the connection (which also is available by calling
N * uip_initialmss()).
N *
N * \hideinitializer
N */
N#define uip_mss()             (uip_conn->mss)
N
N/**
N * Set up a new UDP connection.
N *
N * This function sets up a new UDP connection. The function will
N * automatically allocate an unused local port for the new
N * connection. However, another port can be chosen by using the
N * uip_udp_bind() call, after the uip_udp_new() function has been
N * called.
N *
N * Example:
N \code
N uip_ipaddr_t addr;
N struct uip_udp_conn *c;
N
N uip_ipaddr(&addr, 192,168,2,1);
N c = uip_udp_new(&addr, HTONS(12345));
N if(c != NULL) {
N   uip_udp_bind(c, HTONS(12344));
N }
N \endcode
N * \param ripaddr The IP address of the remote host.
N *
N * \param rport The remote port number in network byte order.
N *
N * \return The uip_udp_conn structure for the new connection or NULL
N * if no connection could be allocated.
N */
Nstruct uip_udp_conn *uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport);
N
N/**
N * Removed a UDP connection.
N *
N * \param conn A pointer to the uip_udp_conn structure for the connection.
N *
N * \hideinitializer
N */
N#define uip_udp_remove(conn) (conn)->lport = 0
N
N/**
N * Bind a UDP connection to a local port.
N *
N * \param conn A pointer to the uip_udp_conn structure for the
N * connection.
N *
N * \param port The local port number, in network byte order.
N *
N * \hideinitializer
N */
N#define uip_udp_bind(conn, port) (conn)->lport = port
N
N/**
N * Send a UDP datagram of length len on the current connection.
N *
N * This function can only be called in response to a UDP event (poll
N * or newdata). The data must be present in the uip_buf buffer, at the
N * place pointed to by the uip_appdata pointer.
N *
N * \param len The length of the data in the uip_buf buffer.
N *
N * \hideinitializer
N */
N#define uip_udp_send(len) uip_send((char *)uip_appdata, len)
N
N/** @} */
N
N/* uIP convenience and converting functions. */
N
N/**
N * \defgroup uipconvfunc uIP conversion functions
N * @{
N *
N * These functions can be used for converting between different data
N * formats used by uIP.
N */
N
N/**
N * Construct an IP address from four bytes.
N *
N * This function constructs an IP address of the type that uIP handles
N * internally from four bytes. The function is handy for specifying IP
N * addresses to use with e.g. the uip_connect() function.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr;
N struct uip_conn *c;
N
N uip_ipaddr(&ipaddr, 192,168,1,2);
N c = uip_connect(&ipaddr, HTONS(80));
N \endcode
N *
N * \param addr A pointer to a uip_ipaddr_t variable that will be
N * filled in with the IP address.
N *
N * \param addr0 The first octet of the IP address.
N * \param addr1 The second octet of the IP address.
N * \param addr2 The third octet of the IP address.
N * \param addr3 The forth octet of the IP address.
N *
N * \hideinitializer
N */
N#define uip_ipaddr(addr, addr0,addr1,addr2,addr3) do { \
N                     ((u16_t *)(addr))[0] = HTONS(((addr0) << 8) | (addr1)); \
N                     ((u16_t *)(addr))[1] = HTONS(((addr2) << 8) | (addr3)); \
N                  } while(0)
X#define uip_ipaddr(addr, addr0,addr1,addr2,addr3) do {                      ((u16_t *)(addr))[0] = HTONS(((addr0) << 8) | (addr1));                      ((u16_t *)(addr))[1] = HTONS(((addr2) << 8) | (addr3));                   } while(0)
N
N/**
N * Construct an IPv6 address from eight 16-bit words.
N *
N * This function constructs an IPv6 address.
N *
N * \hideinitializer
N */
N#define uip_ip6addr(addr, addr0,addr1,addr2,addr3,addr4,addr5,addr6,addr7) do { \
N                     ((u16_t *)(addr))[0] = HTONS((addr0)); \
N                     ((u16_t *)(addr))[1] = HTONS((addr1)); \
N                     ((u16_t *)(addr))[2] = HTONS((addr2)); \
N                     ((u16_t *)(addr))[3] = HTONS((addr3)); \
N                     ((u16_t *)(addr))[4] = HTONS((addr4)); \
N                     ((u16_t *)(addr))[5] = HTONS((addr5)); \
N                     ((u16_t *)(addr))[6] = HTONS((addr6)); \
N                     ((u16_t *)(addr))[7] = HTONS((addr7)); \
N                  } while(0)
X#define uip_ip6addr(addr, addr0,addr1,addr2,addr3,addr4,addr5,addr6,addr7) do {                      ((u16_t *)(addr))[0] = HTONS((addr0));                      ((u16_t *)(addr))[1] = HTONS((addr1));                      ((u16_t *)(addr))[2] = HTONS((addr2));                      ((u16_t *)(addr))[3] = HTONS((addr3));                      ((u16_t *)(addr))[4] = HTONS((addr4));                      ((u16_t *)(addr))[5] = HTONS((addr5));                      ((u16_t *)(addr))[6] = HTONS((addr6));                      ((u16_t *)(addr))[7] = HTONS((addr7));                   } while(0)
N
N/**
N * Copy an IP address to another IP address.
N *
N * Copies an IP address from one place to another.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr1, ipaddr2;
N
N uip_ipaddr(&ipaddr1, 192,16,1,2);
N uip_ipaddr_copy(&ipaddr2, &ipaddr1);
N \endcode
N *
N * \param dest The destination for the copy.
N * \param src The source from where to copy.
N *
N * \hideinitializer
N */
N#if !UIP_CONF_IPV6
N#define uip_ipaddr_copy(dest, src) do { \
N                     ((u16_t *)dest)[0] = ((u16_t *)src)[0]; \
N                     ((u16_t *)dest)[1] = ((u16_t *)src)[1]; \
N                  } while(0)
X#define uip_ipaddr_copy(dest, src) do {                      ((u16_t *)dest)[0] = ((u16_t *)src)[0];                      ((u16_t *)dest)[1] = ((u16_t *)src)[1];                   } while(0)
N#else /* !UIP_CONF_IPV6 */
S#define uip_ipaddr_copy(dest, src) memcpy(dest, src, sizeof(uip_ip6addr_t))
N#endif /* !UIP_CONF_IPV6 */
N
N/**
N * Compare two IP addresses
N *
N * Compares two IP addresses.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr1, ipaddr2;
N
N uip_ipaddr(&ipaddr1, 192,16,1,2);
N if(uip_ipaddr_cmp(&ipaddr2, &ipaddr1)) {
N    printf("They are the same");
N }
N \endcode
N *
N * \param addr1 The first IP address.
N * \param addr2 The second IP address.
N *
N * \hideinitializer
N */
N#if !UIP_CONF_IPV6
N#define uip_ipaddr_cmp(addr1, addr2) (((u16_t *)addr1)[0] == ((u16_t *)addr2)[0] && \
N				      ((u16_t *)addr1)[1] == ((u16_t *)addr2)[1])
X#define uip_ipaddr_cmp(addr1, addr2) (((u16_t *)addr1)[0] == ((u16_t *)addr2)[0] && 				      ((u16_t *)addr1)[1] == ((u16_t *)addr2)[1])
N#else /* !UIP_CONF_IPV6 */
S#define uip_ipaddr_cmp(addr1, addr2) (memcmp(addr1, addr2, sizeof(uip_ip6addr_t)) == 0)
N#endif /* !UIP_CONF_IPV6 */
N
N/**
N * Compare two IP addresses with netmasks
N *
N * Compares two IP addresses with netmasks. The masks are used to mask
N * out the bits that are to be compared.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr1, ipaddr2, mask;
N
N uip_ipaddr(&mask, 255,255,255,0);
N uip_ipaddr(&ipaddr1, 192,16,1,2);
N uip_ipaddr(&ipaddr2, 192,16,1,3);
N if(uip_ipaddr_maskcmp(&ipaddr1, &ipaddr2, &mask)) {
N    printf("They are the same");
N }
N \endcode
N *
N * \param addr1 The first IP address.
N * \param addr2 The second IP address.
N * \param mask The netmask.
N *
N * \hideinitializer
N */
N#define uip_ipaddr_maskcmp(addr1, addr2, mask) \
N                          (((((u16_t *)addr1)[0] & ((u16_t *)mask)[0]) == \
N                            (((u16_t *)addr2)[0] & ((u16_t *)mask)[0])) && \
N                           ((((u16_t *)addr1)[1] & ((u16_t *)mask)[1]) == \
N                            (((u16_t *)addr2)[1] & ((u16_t *)mask)[1])))
X#define uip_ipaddr_maskcmp(addr1, addr2, mask)                           (((((u16_t *)addr1)[0] & ((u16_t *)mask)[0]) ==                             (((u16_t *)addr2)[0] & ((u16_t *)mask)[0])) &&                            ((((u16_t *)addr1)[1] & ((u16_t *)mask)[1]) ==                             (((u16_t *)addr2)[1] & ((u16_t *)mask)[1])))
N
N
N/**
N * Mask out the network part of an IP address.
N *
N * Masks out the network part of an IP address, given the address and
N * the netmask.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr1, ipaddr2, netmask;
N
N uip_ipaddr(&ipaddr1, 192,16,1,2);
N uip_ipaddr(&netmask, 255,255,255,0);
N uip_ipaddr_mask(&ipaddr2, &ipaddr1, &netmask);
N \endcode
N *
N * In the example above, the variable "ipaddr2" will contain the IP
N * address 192.168.1.0.
N *
N * \param dest Where the result is to be placed.
N * \param src The IP address.
N * \param mask The netmask.
N *
N * \hideinitializer
N */
N#define uip_ipaddr_mask(dest, src, mask) do { \
N                     ((u16_t *)dest)[0] = ((u16_t *)src)[0] & ((u16_t *)mask)[0]; \
N                     ((u16_t *)dest)[1] = ((u16_t *)src)[1] & ((u16_t *)mask)[1]; \
N                  } while(0)
X#define uip_ipaddr_mask(dest, src, mask) do {                      ((u16_t *)dest)[0] = ((u16_t *)src)[0] & ((u16_t *)mask)[0];                      ((u16_t *)dest)[1] = ((u16_t *)src)[1] & ((u16_t *)mask)[1];                   } while(0)
N
N/**
N * Pick the first octet of an IP address.
N *
N * Picks out the first octet of an IP address.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr;
N u8_t octet;
N
N uip_ipaddr(&ipaddr, 1,2,3,4);
N octet = uip_ipaddr1(&ipaddr);
N \endcode
N *
N * In the example above, the variable "octet" will contain the value 1.
N *
N * \hideinitializer
N */
N#define uip_ipaddr1(addr) (htons(((u16_t *)(addr))[0]) >> 8)
N
N/**
N * Pick the second octet of an IP address.
N *
N * Picks out the second octet of an IP address.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr;
N u8_t octet;
N
N uip_ipaddr(&ipaddr, 1,2,3,4);
N octet = uip_ipaddr2(&ipaddr);
N \endcode
N *
N * In the example above, the variable "octet" will contain the value 2.
N *
N * \hideinitializer
N */
N#define uip_ipaddr2(addr) (htons(((u16_t *)(addr))[0]) & 0xff)
N
N/**
N * Pick the third octet of an IP address.
N *
N * Picks out the third octet of an IP address.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr;
N u8_t octet;
N
N uip_ipaddr(&ipaddr, 1,2,3,4);
N octet = uip_ipaddr3(&ipaddr);
N \endcode
N *
N * In the example above, the variable "octet" will contain the value 3.
N *
N * \hideinitializer
N */
N#define uip_ipaddr3(addr) (htons(((u16_t *)(addr))[1]) >> 8)
N
N/**
N * Pick the fourth octet of an IP address.
N *
N * Picks out the fourth octet of an IP address.
N *
N * Example:
N \code
N uip_ipaddr_t ipaddr;
N u8_t octet;
N
N uip_ipaddr(&ipaddr, 1,2,3,4);
N octet = uip_ipaddr4(&ipaddr);
N \endcode
N *
N * In the example above, the variable "octet" will contain the value 4.
N *
N * \hideinitializer
N */
N#define uip_ipaddr4(addr) (htons(((u16_t *)(addr))[1]) & 0xff)
N
N/**
N * Convert 16-bit quantity from host byte order to network byte order.
N *
N * This macro is primarily used for converting constants from host
N * byte order to network byte order. For converting variables to
N * network byte order, use the htons() function instead.
N *
N * \hideinitializer
N */
N#ifndef HTONS
N#   if UIP_BYTE_ORDER == UIP_BIG_ENDIAN
X#   if 3412 == 1234
S#      define HTONS(n) (n)
N#   else /* UIP_BYTE_ORDER == UIP_BIG_ENDIAN */
N#      define HTONS(n) (u16_t)((((u16_t) (n)) << 8) | (((u16_t) (n)) >> 8))
N#   endif /* UIP_BYTE_ORDER == UIP_BIG_ENDIAN */
N#else
S#error "HTONS already defined!"
N#endif /* HTONS */
N
N/**
N * Convert 16-bit quantity from host byte order to network byte order.
N *
N * This function is primarily used for converting variables from host
N * byte order to network byte order. For converting constants to
N * network byte order, use the HTONS() macro instead.
N */
N#ifndef htons
Nu16_t htons(u16_t val);
N#endif /* htons */
N#ifndef ntohs
N#define ntohs htons
N#endif
N
N/** @} */
N
N/**
N * Pointer to the application data in the packet buffer.
N *
N * This pointer points to the application data when the application is
N * called. If the application wishes to send data, the application may
N * use this space to write the data into before calling uip_send().
N */
Nextern void *uip_appdata;
N
N#if UIP_URGDATA > 0
X#if 0 > 0
S/* u8_t *uip_urgdata:
S *
S * This pointer points to any urgent data that has been received. Only
S * present if compiled with support for urgent data (UIP_URGDATA).
S */
Sextern void *uip_urgdata;
N#endif /* UIP_URGDATA > 0 */
N
N
N/**
N * \defgroup uipdrivervars Variables used in uIP device drivers
N * @{
N *
N * uIP has a few global variables that are used in device drivers for
N * uIP.
N */
N
N/**
N * The length of the packet in the uip_buf buffer.
N *
N * The global variable uip_len holds the length of the packet in the
N * uip_buf buffer.
N *
N * When the network device driver calls the uIP input function,
N * uip_len should be set to the length of the packet in the uip_buf
N * buffer.
N *
N * When sending packets, the device driver should use the contents of
N * the uip_len variable to determine the length of the outgoing
N * packet.
N *
N */
Nextern u16_t uip_len;
N
N/** @} */
N
N#if UIP_URGDATA > 0
X#if 0 > 0
Sextern u16_t uip_urglen, uip_surglen;
N#endif /* UIP_URGDATA > 0 */
N
N
N/**
N * Representation of a uIP TCP connection.
N *
N * The uip_conn structure is used for identifying a connection. All
N * but one field in the structure are to be considered read-only by an
N * application. The only exception is the appstate field whos purpose
N * is to let the application store application-specific state (e.g.,
N * file pointers) for the connection. The type of this field is
N * configured in the "uipopt.h" header file.
N */
Nstruct uip_conn {
N  uip_ipaddr_t ripaddr;   /**< The IP address of the remote host. */
N
N  u16_t lport;        /**< The local TCP port, in network byte order. */
N  u16_t rport;        /**< The local remote TCP port, in network byte
N			 order. */
N
N  u8_t rcv_nxt[4];    /**< The sequence number that we expect to
N			 receive next. */
N  u8_t snd_nxt[4];    /**< The sequence number that was last sent by
N                         us. */
N  u16_t len;          /**< Length of the data that was previously sent. */
N  u16_t mss;          /**< Current maximum segment size for the
N			 connection. */
N  u16_t initialmss;   /**< Initial maximum segment size for the
N			 connection. */
N  u8_t sa;            /**< Retransmission time-out calculation state
N			 variable. */
N  u8_t sv;            /**< Retransmission time-out calculation state
N			 variable. */
N  u8_t rto;           /**< Retransmission time-out. */
N  u8_t tcpstateflags; /**< TCP state and flags. */
N  u8_t timer;         /**< The retransmission timer. */
N  u8_t nrtx;          /**< The number of retransmissions for the last
N			 segment sent. */
N
N  /** The application state. */
N  uip_tcp_appstate_t appstate;
N};
N
N
N/**
N * Pointer to the current TCP connection.
N *
N * The uip_conn pointer can be used to access the current TCP
N * connection.
N */
Nextern struct uip_conn *uip_conn;
N/* The array containing all uIP connections. */
Nextern struct uip_conn uip_conns[UIP_CONNS];
Xextern struct uip_conn uip_conns[40];
N/**
N * \addtogroup uiparch
N * @{
N */
N
N/**
N * 4-byte array used for the 32-bit sequence number calculations.
N */
Nextern u8_t uip_acc32[4];
N
N/** @} */
N
N
N#if UIP_UDP
X#if 0
S/**
S * Representation of a uIP UDP connection.
S */
Sstruct uip_udp_conn {
S  uip_ipaddr_t ripaddr;   /**< The IP address of the remote peer. */
S  u16_t lport;        /**< The local port number in network byte order. */
S  u16_t rport;        /**< The remote port number in network byte order. */
S  u8_t  ttl;          /**< Default time-to-live. */
S
S  /** The application state. */
S  uip_udp_appstate_t appstate;
S};
S
S/**
S * The current UDP connection.
S */
Sextern struct uip_udp_conn *uip_udp_conn;
Sextern struct uip_udp_conn uip_udp_conns[UIP_UDP_CONNS];
N#endif /* UIP_UDP */
N
N/**
N * The structure holding the TCP/IP statistics that are gathered if
N * UIP_STATISTICS is set to 1.
N *
N */
Nstruct uip_stats {
N  struct {
N    uip_stats_t drop;     /**< Number of dropped packets at the IP
N			     layer. */
N    uip_stats_t recv;     /**< Number of received packets at the IP
N			     layer. */
N    uip_stats_t sent;     /**< Number of sent packets at the IP
N			     layer. */
N    uip_stats_t vhlerr;   /**< Number of packets dropped due to wrong
N			     IP version or header length. */
N    uip_stats_t hblenerr; /**< Number of packets dropped due to wrong
N			     IP length, high byte. */
N    uip_stats_t lblenerr; /**< Number of packets dropped due to wrong
N			     IP length, low byte. */
N    uip_stats_t fragerr;  /**< Number of packets dropped since they
N			     were IP fragments. */
N    uip_stats_t chkerr;   /**< Number of packets dropped due to IP
N			     checksum errors. */
N    uip_stats_t protoerr; /**< Number of packets dropped since they
N			     were neither ICMP, UDP nor TCP. */
N  } ip;                   /**< IP statistics. */
N  struct {
N    uip_stats_t drop;     /**< Number of dropped ICMP packets. */
N    uip_stats_t recv;     /**< Number of received ICMP packets. */
N    uip_stats_t sent;     /**< Number of sent ICMP packets. */
N    uip_stats_t typeerr;  /**< Number of ICMP packets with a wrong
N			     type. */
N  } icmp;                 /**< ICMP statistics. */
N  struct {
N    uip_stats_t drop;     /**< Number of dropped TCP segments. */
N    uip_stats_t recv;     /**< Number of recived TCP segments. */
N    uip_stats_t sent;     /**< Number of sent TCP segments. */
N    uip_stats_t chkerr;   /**< Number of TCP segments with a bad
N			     checksum. */
N    uip_stats_t ackerr;   /**< Number of TCP segments with a bad ACK
N			     number. */
N    uip_stats_t rst;      /**< Number of recevied TCP RST (reset) segments. */
N    uip_stats_t rexmit;   /**< Number of retransmitted TCP segments. */
N    uip_stats_t syndrop;  /**< Number of dropped SYNs due to too few
N			     connections was avaliable. */
N    uip_stats_t synrst;   /**< Number of SYNs for closed ports,
N			     triggering a RST. */
N  } tcp;                  /**< TCP statistics. */
N#if UIP_UDP
X#if 0
S  struct {
S    uip_stats_t drop;     /**< Number of dropped UDP segments. */
S    uip_stats_t recv;     /**< Number of recived UDP segments. */
S    uip_stats_t sent;     /**< Number of sent UDP segments. */
S    uip_stats_t chkerr;   /**< Number of UDP segments with a bad
S			     checksum. */
S  } udp;                  /**< UDP statistics. */
N#endif /* UIP_UDP */
N};
N
N/**
N * The uIP TCP/IP statistics.
N *
N * This is the variable in which the uIP TCP/IP statistics are gathered.
N */
Nextern struct uip_stats uip_stat;
N
N
N/*---------------------------------------------------------------------------*/
N/* All the stuff below this point is internal to uIP and should not be
N * used directly by an application or by a device driver.
N */
N/*---------------------------------------------------------------------------*/
N/* u8_t uip_flags:
N *
N * When the application is called, uip_flags will contain the flags
N * that are defined in this file. Please read below for more
N * infomation.
N */
Nextern u8_t uip_flags;
N
N/* The following flags may be set in the global variable uip_flags
N   before calling the application callback. The UIP_ACKDATA,
N   UIP_NEWDATA, and UIP_CLOSE flags may both be set at the same time,
N   whereas the others are mutualy exclusive. Note that these flags
N   should *NOT* be accessed directly, but only through the uIP
N   functions/macros. */
N
N#define UIP_ACKDATA   1     /* Signifies that the outstanding data was
N			       acked and the application should send
N			       out new data instead of retransmitting
N			       the last data. */
N#define UIP_NEWDATA   2     /* Flags the fact that the peer has sent
N			       us new data. */
N#define UIP_REXMIT    4     /* Tells the application to retransmit the
N			       data that was last sent. */
N#define UIP_POLL      8     /* Used for polling the application, to
N			       check if the application has data that
N			       it wants to send. */
N#define UIP_CLOSE     16    /* The remote host has closed the
N			       connection, thus the connection has
N			       gone away. Or the application signals
N			       that it wants to close the
N			       connection. */
N#define UIP_ABORT     32    /* The remote host has aborted the
N			       connection, thus the connection has
N			       gone away. Or the application signals
N			       that it wants to abort the
N			       connection. */
N#define UIP_CONNECTED 64    /* We have got a connection from a remote
N                               host and have set up a new connection
N                               for it, or an active connection has
N                               been successfully established. */
N
N#define UIP_TIMEDOUT  128   /* The connection has been aborted due to
N			       too many retransmissions. */
N
N/* uip_process(flag):
N *
N * The actual uIP function which does all the work.
N */
Nvoid uip_process(u8_t flag);
N
N/* The following flags are passed as an argument to the uip_process()
N   function. They are used to distinguish between the two cases where
N   uip_process() is called. It can be called either because we have
N   incoming data that should be processed, or because the periodic
N   timer has fired. These values are never used directly, but only in
N   the macrose defined in this file. */
N
N#define UIP_DATA          1     /* Tells uIP that there is incoming
N				   data in the uip_buf buffer. The
N				   length of the data is stored in the
N				   global variable uip_len. */
N#define UIP_TIMER         2     /* Tells uIP that the periodic timer
N				   has fired. */
N#define UIP_POLL_REQUEST  3     /* Tells uIP that a connection should
N				   be polled. */
N#define UIP_UDP_SEND_CONN 4     /* Tells uIP that a UDP datagram
N				   should be constructed in the
N				   uip_buf buffer. */
N#if UIP_UDP
X#if 0
S#define UIP_UDP_TIMER     5
N#endif /* UIP_UDP */
N
N/* The TCP states used in the uip_conn->tcpstateflags. */
N#define UIP_CLOSED      0
N#define UIP_SYN_RCVD    1
N#define UIP_SYN_SENT    2
N#define UIP_ESTABLISHED 3
N#define UIP_FIN_WAIT_1  4
N#define UIP_FIN_WAIT_2  5
N#define UIP_CLOSING     6
N#define UIP_TIME_WAIT   7
N#define UIP_LAST_ACK    8
N#define UIP_TS_MASK     15
N
N#define UIP_STOPPED      16
N
N/* The TCP and IP headers. */
Nstruct uip_tcpip_hdr {
N#if UIP_CONF_IPV6
S  /* IPv6 header. */
S  u8_t vtc,
S    tcflow;
S  u16_t flow;
S  u8_t len[2];
S  u8_t proto, ttl;
S  uip_ip6addr_t srcipaddr, destipaddr;
N#else /* UIP_CONF_IPV6 */
N  /* IPv4 header. */
N  u8_t vhl,
N    tos,
N    len[2],
N    ipid[2],
N    ipoffset[2],
N    ttl,
N    proto;
N  u16_t ipchksum;
N  u16_t srcipaddr[2],
N    destipaddr[2];
N#endif /* UIP_CONF_IPV6 */
N
N  /* TCP header. */
N  u16_t srcport,
N    destport;
N  u8_t seqno[4],
N    ackno[4],
N    tcpoffset,
N    flags,
N    wnd[2];
N  u16_t tcpchksum;
N  u8_t urgp[2];
N  u8_t optdata[4];
N};
N
N/* The ICMP and IP headers. */
Nstruct uip_icmpip_hdr {
N#if UIP_CONF_IPV6
S  /* IPv6 header. */
S  u8_t vtc,
S    tcf;
S  u16_t flow;
S  u8_t len[2];
S  u8_t proto, ttl;
S  uip_ip6addr_t srcipaddr, destipaddr;
N#else /* UIP_CONF_IPV6 */
N  /* IPv4 header. */
N  u8_t vhl,
N    tos,
N    len[2],
N    ipid[2],
N    ipoffset[2],
N    ttl,
N    proto;
N  u16_t ipchksum;
N  u16_t srcipaddr[2],
N    destipaddr[2];
N#endif /* UIP_CONF_IPV6 */
N
N  /* ICMP (echo) header. */
N  u8_t type, icode;
N  u16_t icmpchksum;
N#if !UIP_CONF_IPV6
N  u16_t id, seqno;
N#else /* !UIP_CONF_IPV6 */
S  u8_t flags, reserved1, reserved2, reserved3;
S  u8_t icmp6data[16];
S  u8_t options[1];
N#endif /* !UIP_CONF_IPV6 */
N};
N
N
N/* The UDP and IP headers. */
Nstruct uip_udpip_hdr {
N#if UIP_CONF_IPV6
S  /* IPv6 header. */
S  u8_t vtc,
S    tcf;
S  u16_t flow;
S  u8_t len[2];
S  u8_t proto, ttl;
S  uip_ip6addr_t srcipaddr, destipaddr;
N#else /* UIP_CONF_IPV6 */
N  /* IP header. */
N  u8_t vhl,
N    tos,
N    len[2],
N    ipid[2],
N    ipoffset[2],
N    ttl,
N    proto;
N  u16_t ipchksum;
N  u16_t srcipaddr[2],
N    destipaddr[2];
N#endif /* UIP_CONF_IPV6 */
N
N  /* UDP header. */
N  u16_t srcport,
N    destport;
N  u16_t udplen;
N  u16_t udpchksum;
N};
N
N
N
N/**
N * The buffer size available for user data in the \ref uip_buf buffer.
N *
N * This macro holds the available size for user data in the \ref
N * uip_buf buffer. The macro is intended to be used for checking
N * bounds of available user data.
N *
N * Example:
N \code
N snprintf(uip_appdata, UIP_APPDATA_SIZE, "%u\n", i);
N \endcode
N *
N * \hideinitializer
N */
N#define UIP_APPDATA_SIZE (UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN)
N
N
N#define UIP_PROTO_ICMP  1
N#define UIP_PROTO_TCP   6
N#define UIP_PROTO_UDP   17
N#define UIP_PROTO_ICMP6 58
N
N/* Header sizes. */
N#if UIP_CONF_IPV6
S#define UIP_IPH_LEN    40
N#else /* UIP_CONF_IPV6 */
N#define UIP_IPH_LEN    20    /* Size of IP header */
N#endif /* UIP_CONF_IPV6 */
N#define UIP_UDPH_LEN    8    /* Size of UDP header */
N#define UIP_TCPH_LEN   20    /* Size of TCP header */
N#define UIP_IPUDPH_LEN (UIP_UDPH_LEN + UIP_IPH_LEN)    /* Size of IP +
N							  UDP
N							  header */
N#define UIP_IPTCPH_LEN (UIP_TCPH_LEN + UIP_IPH_LEN)    /* Size of IP +
N							  TCP
N							  header */
N#define UIP_TCPIP_HLEN UIP_IPTCPH_LEN
N
N
N#if UIP_FIXEDADDR
X#if 0
Sextern const uip_ipaddr_t uip_hostaddr, uip_netmask, uip_draddr;
N#else /* UIP_FIXEDADDR */
Nextern uip_ipaddr_t uip_hostaddr, uip_netmask, uip_draddr;
N
Nextern struct uip_eth_addr uip_ethaddr;
N#endif /* UIP_FIXEDADDR */
N
N
N
N/**
N * Representation of a 48-bit Ethernet address.
N */
Nstruct uip_eth_addr {
N  u8_t addr[6];
N};
N
N/**
N * Calculate the Internet checksum over a buffer.
N *
N * The Internet checksum is the one's complement of the one's
N * complement sum of all 16-bit words in the buffer.
N *
N * See RFC1071.
N *
N * \param buf A pointer to the buffer over which the checksum is to be
N * computed.
N *
N * \param len The length of the buffer over which the checksum is to
N * be computed.
N *
N * \return The Internet checksum of the buffer.
N */
Nu16_t uip_chksum(u16_t *buf, u16_t len);
N
N/**
N * Calculate the IP header checksum of the packet header in uip_buf.
N *
N * The IP header checksum is the Internet checksum of the 20 bytes of
N * the IP header.
N *
N * \return The IP header checksum of the IP header in the uip_buf
N * buffer.
N */
Nu16_t uip_ipchksum(void);
N
N/**
N * Calculate the TCP checksum of the packet in uip_buf and uip_appdata.
N *
N * The TCP checksum is the Internet checksum of data contents of the
N * TCP segment, and a pseudo-header as defined in RFC793.
N *
N * \return The TCP checksum of the TCP segment in uip_buf and pointed
N * to by uip_appdata.
N */
Nu16_t uip_tcpchksum(void);
N
N/**
N * Calculate the UDP checksum of the packet in uip_buf and uip_appdata.
N *
N * The UDP checksum is the Internet checksum of data contents of the
N * UDP segment, and a pseudo-header as defined in RFC768.
N *
N * \return The UDP checksum of the UDP segment in uip_buf and pointed
N * to by uip_appdata.
N */
Nu16_t uip_udpchksum(void);
N
N
N#endif /* __UIP_H__ */
N
N
N/** @} */
L 46 "..\..\Libraries\uIP-1.0\uip\uip-neighbor.h" 2
N
Nstruct uip_neighbor_addr {
N#if UIP_NEIGHBOR_CONF_ADDRTYPE
S  UIP_NEIGHBOR_CONF_ADDRTYPE addr;
N#else
N  struct uip_eth_addr addr;
N#endif
N};
N
Nvoid uip_neighbor_init(void);
Nvoid uip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr);
Nvoid uip_neighbor_update(uip_ipaddr_t ipaddr);
Nstruct uip_neighbor_addr *uip_neighbor_lookup(uip_ipaddr_t ipaddr);
Nvoid uip_neighbor_periodic(void);
N
N#endif /* __UIP-NEIGHBOR_H__ */
L 43 "..\..\Libraries\uIP-1.0\uip\uip-neighbor.c" 2
N
N#include <string.h>
L 1 "D:\Keil_v5\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5040049
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 45 "..\..\Libraries\uIP-1.0\uip\uip-neighbor.c" 2
N
N#define MAX_TIME 128
N
N#ifdef UIP_NEIGHBOR_CONF_ENTRIES
S#define ENTRIES UIP_NEIGHBOR_CONF_ENTRIES
N#else /* UIP_NEIGHBOR_CONF_ENTRIES */
N#define ENTRIES 8
N#endif /* UIP_NEIGHBOR_CONF_ENTRIES */
N
Nstruct neighbor_entry {
N  uip_ipaddr_t ipaddr;
N  struct uip_neighbor_addr addr;
N  u8_t time;
N};
Nstatic struct neighbor_entry entries[ENTRIES];
Xstatic struct neighbor_entry entries[8];
N
N/*---------------------------------------------------------------------------*/
Nvoid
Nuip_neighbor_init(void)
N{
N  int i;
N
N  for(i = 0; i < ENTRIES; ++i) {
X  for(i = 0; i < 8; ++i) {
N    entries[i].time = MAX_TIME;
X    entries[i].time = 128;
N  }
N}
N/*---------------------------------------------------------------------------*/
Nvoid
Nuip_neighbor_periodic(void)
N{
N  int i;
N
N  for(i = 0; i < ENTRIES; ++i) {
X  for(i = 0; i < 8; ++i) {
N    if(entries[i].time < MAX_TIME) {
X    if(entries[i].time < 128) {
N      entries[i].time++;
N    }
N  }
N}
N/*---------------------------------------------------------------------------*/
Nvoid
Nuip_neighbor_add(uip_ipaddr_t ipaddr, struct uip_neighbor_addr *addr)
N{
N  int i, oldest;
N  u8_t oldest_time;
N
W "..\..\Libraries\uIP-1.0\uip\uip-neighbor.c" 90 3 function "printf" declared implicitly
N  printf("Adding neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n",
N	 addr->addr.addr[0], addr->addr.addr[1], addr->addr.addr[2], addr->addr.addr[3],
N	 addr->addr.addr[4], addr->addr.addr[5]);
N
N  /* Find the first unused entry or the oldest used entry. */
N  oldest_time = 0;
N  oldest = 0;
N  for(i = 0; i < ENTRIES; ++i) {
X  for(i = 0; i < 8; ++i) {
N    if(entries[i].time == MAX_TIME) {
X    if(entries[i].time == 128) {
N      oldest = i;
N      break;
N    }
N    if(uip_ipaddr_cmp(entries[i].ipaddr, addr)) {
X    if((((u16_t *)entries[i]. ipaddr)[0] == ((u16_t *)addr)[0] && ((u16_t *)entries[i]. ipaddr)[1] == ((u16_t *)addr)[1])) {
N      oldest = i;
N      break;
N    }
N    if(entries[i].time > oldest_time) {
N      oldest = i;
N      oldest_time = entries[i].time;
N    }
N  }
N
N  /* Use the oldest or first free entry (either pointed to by the
N     "oldest" variable). */
N  entries[oldest].time = 0;
N  uip_ipaddr_copy(entries[oldest].ipaddr, ipaddr);
X  do { ((u16_t *)entries[oldest]. ipaddr)[0] = ((u16_t *)ipaddr)[0]; ((u16_t *)entries[oldest]. ipaddr)[1] = ((u16_t *)ipaddr)[1]; } while(0);
N  memcpy(&entries[oldest].addr, addr, sizeof(struct uip_neighbor_addr));
N}
N/*---------------------------------------------------------------------------*/
Nstatic struct neighbor_entry *
Nfind_entry(uip_ipaddr_t ipaddr)
N{
N  int i;
N
N  for(i = 0; i < ENTRIES; ++i) {
X  for(i = 0; i < 8; ++i) {
N    if(uip_ipaddr_cmp(entries[i].ipaddr, ipaddr)) {
X    if((((u16_t *)entries[i]. ipaddr)[0] == ((u16_t *)ipaddr)[0] && ((u16_t *)entries[i]. ipaddr)[1] == ((u16_t *)ipaddr)[1])) {
N      return &entries[i];
N    }
N  }
N  return NULL;
X  return 0;
N}
N/*---------------------------------------------------------------------------*/
Nvoid
Nuip_neighbor_update(uip_ipaddr_t ipaddr)
N{
N  struct neighbor_entry *e;
N
N  e = find_entry(ipaddr);
N  if(e != NULL) {
X  if(e != 0) {
N    e->time = 0;
N  }
N}
N/*---------------------------------------------------------------------------*/
Nstruct uip_neighbor_addr *
Nuip_neighbor_lookup(uip_ipaddr_t ipaddr)
N{
N  struct neighbor_entry *e;
N
N  e = find_entry(ipaddr);
N  if(e != NULL) {
X  if(e != 0) {
N    /*    printf("Lookup neighbor with link address %02x:%02x:%02x:%02x:%02x:%02x\n",
N	   e->addr.addr.addr[0], e->addr.addr.addr[1], e->addr.addr.addr[2], e->addr.addr.addr[3],
N	   e->addr.addr.addr[4], e->addr.addr.addr[5]);*/
N
N    return &e->addr;
N  }
N  return NULL;
X  return 0;
N}
N/*---------------------------------------------------------------------------*/
